\documentclass{article}
% \usepackage{times}  % for embeddable fonts, Also use: dvips -P pdf -G0

\hbadness=10000 
\sloppy \hfuzz=30pt

\usepackage{calc}
% set the page width and height for the paper (The covers will have their own size)
\setlength{\textwidth}{7in}  
\setlength{\textheight}{9.5in} 
% here we automatically compute the offsets in order to centre the page
\setlength{\oddsidemargin}{(\paperwidth-\textwidth)/2 - 1in}
% \setlength{\topmargin}{(\paperheight-\textheight -\headheight-\headsep-\footskip)/2 - 1in + .8in }
\setlength{\topmargin}{(\paperheight-\textheight -\headheight-\headsep-\footskip)/2 - 1in -.2in }

\input homeHenshaw


\usepackage{html}

\usepackage{makeidx} % index
\makeindex
\newcommand{\Index}[1]{#1\index{#1}}

% \pagestyle{headings}            % section headings at top of each page
% \input documentationPageSize.tex

% \hbadness=10000 % \tolerance=10000
% \sloppy \hfuzz=30pt

\begin{document}

\begin{titlepage}
\index{grids}
\begin{center}
   ~~ \\
   ~~ \\
   ~~ \\
   ~~ \\
   ~~ \\
   ~~ \\
{\Large The Overture Grid Classes \\
        Reference Guide, Version 1.0} \\
\vspace{ 2\baselineskip}
Geoffrey S. Chesshire \\
\vspace{\baselineskip}
Scientific Computing Group (CIC-19) \\
Los Alamos National Laboratory \\
Los Alamos, New Mexico 87545, USA \\
\vspace{2\baselineskip}
William D. Henshaw \\
\vspace{\baselineskip}
Centre for Applied Scientific Computing \\
Lawrence Livermore National Laboratory    \\
Livermore, CA, 94551   \\
henshaw@llnl.gov \\
http://www.llnl.gov/casc/people/henshaw \\
http://www.llnl.gov/casc/Overture 
\vspace{\baselineskip}
\today
\vspace{\baselineskip}
UCRL-MA-134448
\end{center}

\vspace{ 8\baselineskip}
\begin{abstract}

Overture is a library containing classes for grids, overlapping grid
generation and the discretization and solution of PDEs on overlapping
grids.  This document describes the Overture grid classes, including
classes for single grids and classes for collections of grids.
 The primary
classes described are the {\bf MappedGrid}, {\bf GridCollection} and {\bf CompositeGrid} classes.
These classes hold the geometry arrays required by PDE solvers such as the {\bf vertex} (grid vertices),
{\bf vertexDerivative} (jacobian derivatives), and {\bf vertexBoundaryNormal} (normals
on the boundary), etc. The geometry arrays can be optionally generated as required by
the application. The grid classes have support for multigrid levels and for adaptive mesh refinement.

\end{abstract}
\end{titlepage}

% generate a table of contents and list of figures
\tableofcontents
%\listoffigures
%\listoftables
\vfill\eject
\input wdhDefinitions

\section{Introduction}
\label{Introduction}

The Overture grid classes include classes for single grids and classes
for collections of grids.  The single-grid classes are related to each
other through the C++ inheritance mechanism.  The base class is
{\bf{}\hyperref{GenericGrid}{GenericGrid \rm(\S}{)}{GenericGrid}},
and the class
{\bf{}\hyperref{MappedGrid}{MappedGrid \rm(\S}{)}{MappedGrid}}
is derived from \textbf{GenericGrid}.
The collections of grids are also related to each other through
inheritance.  The base class for collections of grids is
{\bf{}\hyperref{GenericGridCollection}{GenericGridCollection \rm(\S}{)}{GenericGridCollection}},
which contains a list of \textbf{GenericGrid}s.  The class
{\bf{}\hyperref{GridCollection}{GridCollection \rm(\S}{)}{GridCollection}}
is derived from GenericGridCollection, and contains a list of
\textbf{MappedGrid}s.  All other Overture grid classes that
contain collections of \textbf{MappedGrid}s are derived from
\textbf{GridCollection}.  In particular, the class
{\bf{}\hyperref{CompositeGrid}{CompositeGrid \rm(\S}{)}{CompositeGrid}}
is derived from \textbf{GridCollection}.
All of these classes are described in this document.

All of the Overture grid classes are reference-counted, using the envelope-letter
paradigm.  To support this, the base grid classes \textbf{GenericGrid} and
\textbf{GenericGridCollection} are derived from the base class
{\bf{}\hyperref{ReferenceCounting}{ReferenceCounting \rm(Appendix }{)}{ReferenceCounting}}.

\section{Class GenericGrid}\index{Generic Grid}
\label{GenericGrid}

{\em Note:  You should not need to read this section unless you are designing a derived grid class.}

Class \textbf{GenericGrid} is the base class for all of the Overture
single-grid classes.  By itself it does not contain any geometric data.
It is useful only as a base class for other grid classes that may
contain data to describe particular kinds of grids.  We envision deriving
from \textbf{GenericGrid} separate classes for structured and unstructured
grids, and perhaps for other kinds of grids that we have not anticipated.
For example, the class
{\bf{}\hyperref{MappedGrid}{MappedGrid \rm(\S}{)}{MappedGrid}}
is derived from \textbf{GenericGrid} in order to describe curvilinear
structured grids.

Many of the public constants, member data and member functions of class
\textbf{GenericGrid} are overloaded in the derived classes.  They are
defined here in the base class for single grids because they are common
to all single grid classes.  The ordinary user (programmer) need not be
concerned with these constants, data and member functions, or with the
class \textbf{GenericGrid} at all, except where they are explicitly
referred to in the descriptions of derived grid classes such as
{\bf{}\hyperref{MappedGrid}{MappedGrid \rm(\S}{)}{MappedGrid}}.

\subsection{Public member functions}
\label{GenericGrid::PublicMemberFunctions}

  \subsubsection{GenericGrid()}
  \label{GenericGrid::GenericGrid()}
    Default constructor.
  \subsubsection{GenericGrid(const GenericGrid\&~x, const CopyType ct~=~DEEP)}
  \label{GenericGrid::GenericGrid(x,ct)}
    Copy constructor.  This does a deep copy by default.
    See also {\bf{}\hyperref{operator=(x)}{operator=(x) \rm(\S}{)}{GenericGrid::operator=(x)}}
    and {\bf{}\hyperref{reference(x)}{reference(x) \rm(\S}{)}{GenericGrid::reference(GenericGrid_x)}}.
  \subsubsection{virtual $\sim$GenericGrid()}
  \label{GenericGrid::tilde_GenericGrid()}
    Destructor.
  \subsubsection{GenericGrid\& operator=(const GenericGrid\&~x)}
  \label{GenericGrid::operator=(x)}
    Assignment operator.  This is also called a deep copy.
  \subsubsection{void reference(const GenericGrid\&~x)}
  \label{GenericGrid::reference(GenericGrid_x)}
    Make a reference.  This is also called a shallow copy.  
    This \textbf{GenericGrid} shares the data of \textbf{x}.
  \subsubsection{virtual void breakReference()}
  \label{GenericGrid::breakReference()}
    Break a reference.  If this \textbf{GenericGrid} shares data with any other \textbf{GenericGrid},
    then this function replaces it with a new copy that does not share data.
  \subsubsection{virtual void consistencyCheck() const}
  \label{GenericGrid::consistencyCheck() const}
    Check the consistency of this \textbf{GenericGrid}.
  \subsubsection{virtual Integer get(const GenericDataBase\&~dir, const aString\&~name)}
  \label{GenericGrid::get(dir,name)}
    Copy a \textbf{GenericGrid} from a file.
  \subsubsection{virtual Integer put(GenericDataBase\&~dir, const aString\&~name) const}
  \label{GenericGrid::put(dir,name) const}
    Copy a \textbf{GenericGrid} into a file.
  \subsubsection{Integer update(const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{GenericGrid::update(what,how)}
    Update geometric data.
    The first argument (\textbf{what}) indicates which geometric data are to be updated.  Any combination of the constants
    {\bf{}\hyperref{NOTHING}{NOTHING \rm(\S}{)}{GenericGrid::NOTHING}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{GenericGrid::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{GenericGrid::EVERYTHING}}
    may be bitwise ORed together to form the first argument of \textbf{update}(), to indicate which geometric data should be updated.
    This function returns a value obtained by bitwise ORing some of these constants,
    to indicate for which of the optional geometric data new array space was allocated.
    In addition, the constant
    {\bf{}\hyperref{COMPUTEfailed}{COMPUTEfailed \rm(\S}{)}{GenericGrid::COMPUTEfailed}},
    may be bitwise ORed into the value returned by \textbf{update}() in order to indicate
    that the computation of some geometric data failed.  The second argument (\textbf{how})
    indicates whether and how any computation of geometric data should be done.
    Any combination of the constants
    {\bf{}\hyperref{COMPUTEnothing}{COMPUTEnothing \rm(\S}{)}{GenericGrid::COMPUTEnothing}} and
    {\bf{}\hyperref{COMPUTEtheUsual}{COMPUTEtheUsual \rm(\S}{)}{GenericGrid::COMPUTEtheUsual}}
    may be bitwise ORed together to form the optional second argument of \textbf{update}().
    In fact, a \textbf{GenericGrid} contains no geometric data, so all this is irrelevant.
  \subsubsection{virtual Integer update(GenericGrid\&~x, const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{GenericGrid::update(x,what,how)}
    Update geometric data, sharing space with the optional geometric data of another \textbf{GenericGrid} (\textbf{x}).
    If space for any indicated optional geometric data has not yet been allocated, or has
    the wrong dimensions, but \textbf{x} does contain the corresponding data, then the data
    for this \textbf{GenericGrid} will share space with the corresponding data of \textbf{x}.
    Any geometric data that already exists and has the correct dimensions
    is not forced to share space with the corresponding data of \textbf{x}.
    For the optional arguments \textbf{what} and \textbf{how}, see the description of the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}.
  \subsubsection{virtual void destroy(const Integer what~=~NOTHING)}
  \label{GenericGrid::destroy(what)}
    Destroy the indicated optional \textbf{GenericGrid} geometric data.
    The argument (\textbf{what}) indicates which optional
    geometric data are to be destroyed.  Any combination of the constants
    {\bf{}\hyperref{NOTHING}{NOTHING \rm(\S}{)}{GenericGrid::NOTHING}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{GenericGrid::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{GenericGrid::EVERYTHING}}
    may be bitwise ORed together to form the optional argument \textbf{what}.
  \subsubsection{void geometryHasChanged(const Integer what~=~$\sim$NOTHING)}
  \label{GenericGrid::geometryHasChanged(what)}
    Mark the geometric data out-of-date.  Any combination of the constants
    {\bf{}\hyperref{NOTHING}{NOTHING \rm(\S}{)}{GenericGrid::NOTHING}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{GenericGrid::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{GenericGrid::EVERYTHING}}
    may be bitwise ORed together to form the first argument of \textbf{geometryHasChanged}().
    By default, all geometric data of this \textbf{GenericGrid} and all derived classes is
    marked out-of-date.
    It is recommended that this function be called only from derived classes and grid-generation programs.
  \subsubsection{Logical operator==(const GenericGrid\&~x) const}
  \label{GenericGrid::operator==(x) const}
    This comparison function returns \textbf{LogicalTrue} (non-zero) if and only if \textbf{x} refers the same grid as \textbf{$\ast$this}.
  \subsubsection{Logical operator!=(const GenericGrid\&~x) const}
  \label{GenericGrid::operator!=(x) const}
    This comparison function returns \textbf{LogicalTrue} or (non-zero) if and only if \textbf{x} does not refer to the same grid as \textbf{$\ast$this}.
  \subsection{Public Member functions for access to data}
  \label{GenericGrid::PublicAccessToData}

  \subsubsection{const Integer\& computedGeometry() const}
  \label{GenericGrid::computedGeometry() const}
    This function returns a reference to a bit mask that indicates which geometrical data has been computed.
    This mask must be reset to zero to invalidate the data when the geometry changes.
    It is recommended that this data be used only by derived classes
    and grid-generation programs.
    See also {\bf{}\hyperref{geometryHasChanged(what)}{geometryHasChanged(what) \rm(\S}{)}{GenericGrid::geometryHasChanged(what)}}.
  \subsubsection{virtual aString getClassName() const}
  \label{GenericGrid::getClassName() const}
    Get the class name of the most-derived class for this object.
  \subsubsection{GenericGridData$*$ operator${-}{>}$()}
  \label{GenericGrid::operator->()}
    Access the reference-counted data.
  \subsubsection{GenericGridData\& operator$*$()}
  \label{GenericGrid::operator*()}
    Access the pointer to the reference-counted data.
  \subsection{Public member functions called only from derived classes}
  \label{GenericGrid::PublicDerivedClassMemberFunctions}

It is recommended that these functions be called only from derived classes.

  \subsubsection{void reference(GenericGridData\&~x)}
  \label{GenericGrid::reference(GenericGridData_x)}
    Make a reference to an object of class \textbf{GenericGridData}.
    This \textbf{GenericGrid} uses \textbf{x} for its data.
    It is recommended that this function be called only from derived classes.
  \subsubsection{void updateReferences(const Integer what~=~EVERYTHING)}
  \label{GenericGrid::updateReferences(what)}
    Update references to the reference-counted data.
    It is recommended that this function be called only from derived classes.

\subsection{Public data used only by derived classes}
\label{GenericGrid::PublicDerivedClassData}

It is recommended that these variables be used only by derived classes.

  \subsubsection{GenericGridData$*$ rcData}
  \label{GenericGrid::rcData}
    \textbf{rcData} is a pointer to the reference-counted data.
    It is recommended that this variable be used only by derived classes.
    See also the member functions
    {\bf{}\hyperref{operator${-}{>}$()}{operator${-}{>}$() \rm(\S}{)}{GenericGrid::operator->()}}
    and {\bf{}\hyperref{operator$*$()}{operator$*$() \rm(\S}{)}{GenericGrid::operator*()}},
    which are provided for access to \textbf{rcData}.

  \subsubsection{Logical isCounted}
  \label{GenericGrid::isCounted}
    \textbf{isCounted} is
    a flag that indicates whether the data pointed to by {\bf{}\hyperref{rcData}{rcData \rm(\S}{)}{GenericGrid::rcData}} is known to be reference-counted.
    It is recommended that this variable be used only by derived classes.

\subsection{Public constants}
\label{GenericGrid::PublicConstants}

  \subsubsection{NOTHING}
  \label{GenericGrid::NOTHING}
    \textbf{NOTHING} = 0 \\*[\parskip]
    \textbf{NOTHING} indicates no geometric data.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGrid::destroy(what)}}.

  \subsubsection{THEusualSuspects}
  \label{GenericGrid::THEusualSuspects}
    \textbf{THEusualSuspects} = {\bf{}\hyperref{NOTHING}{NOTHING \rm(\S}{)}{GenericGrid::NOTHING}} \\*[\parskip]
    \textbf{THEusualSuspects} indicates some of the geometric data of a \textbf{GenericGrid}.
    The particular data indicated by \textbf{THEusualSuspects} may change from time to time.
    For this reason the use of \textbf{THEusualSuspects} is not recommended.
    In fact, a \textbf{GenericGrid} contains no geometric data, so all this is moot.
    This constant is typically overloaded in a derived class, to indicate some of the
    geometric data of that class, in addition to the geometric data indicated by
    the constant \textbf{THEusualSuspects} defined in its base class.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGrid::destroy(what)}}.

  \subsubsection{EVERYTHING}
  \label{GenericGrid::EVERYTHING}
    \textbf{EVERYTHING} = {\bf{}\hyperref{NOTHING}{NOTHING \rm(\S}{)}{GenericGrid::NOTHING}} \\*[\parskip]
    \textbf{EVERYTHING} indicates all of the geometric data associated with a \textbf{GenericGrid}.
    In fact, a \textbf{GenericGrid} contains no geometric data.
    This constant is typically overloaded in a derived class, to indicate all of the
    geometric data of that class, in addition to the geometric data indicated by
    the constant \textbf{EVERYTHING} defined in its base class.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGrid::destroy(what)}}.

  \subsubsection{COMPUTEnothing}
  \label{GenericGrid::COMPUTEnothing}
    \textbf{COMPUTEnothing} = 0 \\*[\parskip]
    \textbf{COMPUTEnotning} indicates that no geometric data should be computed.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}.

  \subsubsection{COMPUTEtheUsual}
  \label{GenericGrid::COMPUTEtheUsual}
    \textbf{COMPUTEtheUsual} = {\bf{}\hyperref{COMPUTEnothing}{COMPUTEnothing \rm(\S}{)}{GenericGrid::COMPUTEnothing}} \\*[\parskip]
    \textbf{COMPUTEtheUsual} indicates that computation of geometric data should proceed in the ``usual way.''
    In fact, a \textbf{GenericGrid} contains no geometric data, so this is irrelevant.
    This constant is typically overloaded in a derived class, to indicate the ``usual way''
    of computing geometry relevant to that class, in addition to the usual way of computing the
    geometric data indicated by the constant \textbf{COMPUTEtheUsual} defined in and
    relevant to its base class.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}.

  \subsubsection{COMPUTEfailed}
  \label{GenericGrid::COMPUTEfailed}
    \textbf{COMPUTEfailed} indicates that computation of some geometric data failed.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}.

\section{Class MappedGrid}\index{MappedGrid}
\label{MappedGrid}

Class \textbf{MappedGrid} is used for all logically-rectangular grids.
This includes cartesian, rectangular and curvilinear grids.  Class
MappedGrid allows for grids with holes, unused vertices or cells within
a grid.  It is assumed that a continuous function exists which maps the
vertices of a uniform grid to the vertices of the MappedGrid.  This
is no restriction, becauase it is always possible to construct a function,
for example an interpolant, with this property.

Class \textbf{MappedGrid} is derived from class
{\bf{}\hyperref{GenericGrid}{GenericGrid \rm(\S}{)}{GenericGrid}}.
It overloads some of the \textbf{GenericGrid} public constants,
member data and member functions.

\subsection{Public member functions}
\label{MappedGrid::PublicMemberFunctions}

  \subsubsection{MappedGrid(const Integer numberOfDimensions\_~=~0)}
  \label{MappedGrid::MappedGrid(numberOfDimensions_)}
    Default constructor.
    If numberOfDimensions\_==0 ({\sl{}e.g.}, by default) then create a null \textbf{MappedGrid}.
    Otherwise, create a \textbf{MappedGrid} with the given number of dimensions.
  \subsubsection{MappedGrid(const MappedGrid\&~x, const CopyType ct =~DEEP)}
  \label{MappedGrid::MappedGrid(x,ct)}
    Copy constructor.  This does a deep copy by default.
    See also {\bf{}\hyperref{operator=(x)}{operator=(x) \rm(\S}{)}{MappedGrid::operator=(x)}}
    and {\bf{}\hyperref{reference(const MappedGrid\& x)}{reference(const MappedGrid\& x) \rm(\S}{)}{MappedGrid::reference(MappedGrid_x)}}.

  \subsubsection{MappedGrid(Mapping\&~mapping\_)}
  \label{MappedGrid::MappedGrid(Mapping_mapping_)}
    Constructor from a mapping.
  \subsubsection{MappedGrid(MappingRC\&~mapping\_)}
  \label{MappedGrid::MappedGrid(MappingRC_mapping_)}
    Constructor from a reference-counted mapping.
  \subsubsection{virtual $\sim$MappedGrid()}
  \label{MappedGrid::tilde_MappedGrid()}
    Destructor.
  \subsubsection{MappedGrid\& operator=(const MappedGrid\&~x)}
  \label{MappedGrid::operator=(x)}
    Assignment operator.  This is also called a deep copy.
  \subsubsection{void reference(const MappedGrid\&~x)}
  \label{MappedGrid::reference(MappedGrid_x)}
    Make a reference.  This is also called a shallow copy.  This \textbf{MappedGrid} shares the data of \textbf{x}.
  \subsubsection{void reference(Mapping\&~x)}
  \label{MappedGrid::reference(Mapping_x)}
    Use a given mapping.
  \subsubsection{void reference(MappingRC\&~x)}
  \label{MappedGrid::reference(MappingRC_x)}
    Use a given reference-counted mapping.
  \subsubsection{virtual void breakReference()}
  \label{MappedGrid::breakReference()}
    Break a reference.  If this \textbf{MappedGrid} shares data with any other \textbf{MappedGrid},
    then this function replaces it with a new copy that does not share data.
  \subsubsection{void changeToAllVertexCentered()}
  \label{MappedGrid::changeToAllVertexCentered()}
    Change the grid to be all vertex-centered.
  \subsubsection{void changeToAllCellCentered()}
  \label{MappedGrid::changeToAllCellCentered()}
    Change the grid to be all cell-centered.
  \subsubsection{virtual void consistencyCheck() const}
  \label{MappedGrid::consistencyCheck() const}
    Check the consistency of this \textbf{MappedGrid}.
  \subsubsection{virtual Integer get(const GenericDataBase\&~dir, const aString\&~name)}
  \label{MappedGrid::get(dir,name)}
    Copy a \textbf{MappedGrid} from a file.
  \subsubsection{virtual Integer put(GenericDataBase\&~dir, const aString\&~name) const}
  \label{MappedGrid::put(dir,name) const}
    Copy a \textbf{MappedGrid} into a file.
  \subsubsection{Integer update(const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{MappedGrid::update(what,how)}
    Update geometric data.
    The first argument (\textbf{what}) indicates which geometric data are to be updated.  Any combination of the constants
    {\bf{}\hyperref{THEmask}{THEmask \rm(\S}{)}{MappedGrid::THEmask}},
    {\bf{}\hyperref{THEvertex}{THEvertex \rm(\S}{)}{MappedGrid::THEvertex}},
    {\bf{}\hyperref{THEcenter}{THEcenter \rm(\S}{)}{MappedGrid::THEcenter}},
    {\bf{}\hyperref{THEcorner}{THEcorner \rm(\S}{)}{MappedGrid::THEcorner}},
    {\bf{}\hyperref{THEvertexDerivative}{THEvertexDerivative \rm(\S}{)}{MappedGrid::THEvertexDerivative}},
    {\bf{}\hyperref{THEcenterDerivative}{THEcenterDerivative \rm(\S}{)}{MappedGrid::THEcenterDerivative}},
    {\bf{}\hyperref{THEinverseVertexDerivative}{THEinverseVertexDerivative \rm(\S}{)}{MappedGrid::THEinverseVertexDerivative}},
    {\bf{}\hyperref{THEinverseCenterDerivative}{THEinverseCenterDerivative \rm(\S}{)}{MappedGrid::THEinverseCenterDerivative}},
    {\bf{}\hyperref{THEvertexJacobian}{THEvertexJacobian \rm(\S}{)}{MappedGrid::THEvertexJacobian}},
    {\bf{}\hyperref{THEcenterJacobian}{THEcenterJacobian \rm(\S}{)}{MappedGrid::THEcenterJacobian}},
    {\bf{}\hyperref{THEcellVolume}{THEcellVolume \rm(\S}{)}{MappedGrid::THEcellVolume}},
    {\bf{}\hyperref{THEfaceNormal}{THEfaceNormal \rm(\S}{)}{MappedGrid::THEfaceNormal}},
    {\bf{}\hyperref{THEcenterNormal}{THEcenterNormal \rm(\S}{)}{MappedGrid::THEcenterNormal}},
    {\bf{}\hyperref{THEfaceArea}{THEfaceArea \rm(\S}{)}{MappedGrid::THEfaceArea}},
    {\bf{}\hyperref{THEcenterArea}{THEcenterArea \rm(\S}{)}{MappedGrid::THEcenterArea}},
    {\bf{}\hyperref{THEvertexBoundaryNormal}{THEvertexBoundaryNormal \rm(\S}{)}{MappedGrid::THEvertexBoundaryNormal}},
    {\bf{}\hyperref{THEcenterBoundaryNormal}{THEcenterBoundaryNormal \rm(\S}{)}{MappedGrid::THEcenterBoundaryNormal}},
    {\bf{}\hyperref{THEcenterBoundaryTangent}{THEcenterBoundaryTangent \rm(\S}{)}{MappedGrid::THEcenterBoundaryTangent}},
    {\bf{}\hyperref{THEminMaxEdgeLength}{THEminMaxEdgeLength \rm(\S}{)}{MappedGrid::THEminMaxEdgeLength}},
    {\bf{}\hyperref{THEboundingBox}{THEboundingBox \rm(\S}{)}{MappedGrid::THEboundingBox}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{MappedGrid::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{MappedGrid::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGrid::update(what,how)}{GenericGrid::update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}},
    may be bitwise ORed together to form the first argument of \textbf{update}(),
    to indicate which geometric data should be updated.
    This function returns a value obtained by bitwise ORing some of these constants,
    to indicate for which of the optional geometric data new array space was allocated.
    In addition, the constant
    {\bf{}\hyperref{COMPUTEfailed}{COMPUTEfailed \rm(\S}{)}{GenericGrid::COMPUTEfailed}},
    may be bitwise ORed into the value returned by \textbf{update}() in order to indicate
    that the computation of some geometric data failed.  The second argument (\textbf{how})
    indicates whether and how any computation of geometric data should be done.
    Any combination of the constants
    {\bf{}\hyperref{USEdifferenceApproximation}{USEdifferenceApproximation \rm(\S}{)}{MappedGrid::USEdifferenceApproximation}},
    {\bf{}\hyperref{COMPUTEgeometry}{COMPUTEgeometry \rm(\S}{)}{MappedGrid::COMPUTEgeometry}},
    {\bf{}\hyperref{COMPUTEgeometryAsNeeded}{COMPUTEgeometryAsNeeded \rm(\S}{)}{MappedGrid::COMPUTEgeometryAsNeeded}},
    {\bf{}\hyperref{COMPUTEtheUsual}{COMPUTEtheUsual \rm(\S}{)}{MappedGrid::COMPUTEtheUsual}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGrid::update(what,how)}{GenericGrid::update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}},
    may be bitwise ORed together to form the optional second argument of \textbf{update}().
    The corresponding function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}
    is called with the same arguments for the base class \textbf{GenericGrid}.

  \subsubsection{Integer update(MappedGrid\&~x, const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{MappedGrid::update(x,what,how)}
    Update geometric data, sharing space with the optional geometric data of another grid (\textbf{x}).
    If space for any indicated optional geometric data has not yet been allocated, or has
    the wrong dimensions, but \textbf{x} does contain the corresponding data, then the data
    for this \textbf{MappedGrid} will share space with the corresponding data of \textbf{x}.
    Any geometric data that already exists and has the correct dimensions
    is not forced to share space with the corresponding data of \textbf{x}.
    The corresponding function
    {\bf{}\hyperref{update(x,what,how)}{update(x,what,how) \rm(\S}{)}{GenericGrid::update(x,what,how)}}
    is called with the same arguments for the base class \textbf{GenericGrid}.
    For the optional arguments \textbf{what} and \textbf{how}, see the description of the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{void destroy(const Integer what~=~NOTHING)}
  \label{MappedGrid::destroy(what)}
    Destroy the indicated optional geometric grid data.
    The argument (\textbf{what}) indicates which optional
    geometric data are to be destroyed.  Any combination of the constants
    {\bf{}\hyperref{THEmask}{THEmask \rm(\S}{)}{MappedGrid::THEmask}},
    {\bf{}\hyperref{THEvertex}{THEvertex \rm(\S}{)}{MappedGrid::THEvertex}},
    {\bf{}\hyperref{THEcenter}{THEcenter \rm(\S}{)}{MappedGrid::THEcenter}},
    {\bf{}\hyperref{THEcorner}{THEcorner \rm(\S}{)}{MappedGrid::THEcorner}},
    {\bf{}\hyperref{THEvertexDerivative}{THEvertexDerivative \rm(\S}{)}{MappedGrid::THEvertexDerivative}},
    {\bf{}\hyperref{THEcenterDerivative}{THEcenterDerivative \rm(\S}{)}{MappedGrid::THEcenterDerivative}},
    {\bf{}\hyperref{THEinverseVertexDerivative}{THEinverseVertexDerivative \rm(\S}{)}{MappedGrid::THEinverseVertexDerivative}},
    {\bf{}\hyperref{THEinverseCenterDerivative}{THEinverseCenterDerivative \rm(\S}{)}{MappedGrid::THEinverseCenterDerivative}},
    {\bf{}\hyperref{THEvertexJacobian}{THEvertexJacobian \rm(\S}{)}{MappedGrid::THEvertexJacobian}},
    {\bf{}\hyperref{THEcenterJacobian}{THEcenterJacobian \rm(\S}{)}{MappedGrid::THEcenterJacobian}},
    {\bf{}\hyperref{THEcellVolume}{THEcellVolume \rm(\S}{)}{MappedGrid::THEcellVolume}},
    {\bf{}\hyperref{THEfaceNormal}{THEfaceNormal \rm(\S}{)}{MappedGrid::THEfaceNormal}},
    {\bf{}\hyperref{THEcenterNormal}{THEcenterNormal \rm(\S}{)}{MappedGrid::THEcenterNormal}},
    {\bf{}\hyperref{THEfaceArea}{THEfaceArea \rm(\S}{)}{MappedGrid::THEfaceArea}},
    {\bf{}\hyperref{THEcenterArea}{THEcenterArea \rm(\S}{)}{MappedGrid::THEcenterArea}},
    {\bf{}\hyperref{THEvertexBoundaryNormal}{THEvertexBoundaryNormal \rm(\S}{)}{MappedGrid::THEvertexBoundaryNormal}},
    {\bf{}\hyperref{THEcenterBoundaryNormal}{THEcenterBoundaryNormal \rm(\S}{)}{MappedGrid::THEcenterBoundaryNormal}},
    {\bf{}\hyperref{THEcenterBoundaryTangent}{THEcenterBoundaryTangent \rm(\S}{)}{MappedGrid::THEcenterBoundaryTangent}},
    {\bf{}\hyperref{THEminMaxEdgeLength}{THEminMaxEdgeLength \rm(\S}{)}{MappedGrid::THEminMaxEdgeLength}},
    {\bf{}\hyperref{THEboundingBox}{THEboundingBox \rm(\S}{)}{MappedGrid::THEboundingBox}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{MappedGrid::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{MappedGrid::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGrid::destroy(what)}{GenericGrid::destroy(what) \rm(\S}{)}{GenericGrid::destroy(what)}},
    may be bitwise ORed together to form the optional argument \textbf{what}.
    The corresponding function
    {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGrid::destroy(what)}}
    is called with the same argument for the base class \textbf{GenericGrid}.

  \subsubsection{void getInverseCondition(MappedGrid\&~g2, const RealArray\&~xr1, const RealArray\&~rx2, const RealArray\&~condition)}
  \label{MappedGrid::getInverseCondition(g2,xr1,rx2,condition)}
    \begin{description}
      \item{\textbf{g2}  (INPUT)} The \textbf{MappedGrid} whose inverse mapping was used to compute \textbf{rx2}.
      \item{\textbf{xr1} (INPUT)} Dimensions:  $(N,0\colon2,0\colon2)$\\*
                            The derivative of the mapping of this \textbf{MappedGrid}.
                            The range of points $N$
                            for which the inverse condition is computed is determined by the
                            first dimension of \textbf{xr1}.  The first dimension of
                            \textbf{rx2} and \textbf{condition} should be the same as the first
                            the dimension of \textbf{xr1}.
      \item{\textbf{rx2} (INPUT)} Dimensions:  $(N,0\colon2,0\colon2)$\\*
                            The inverse derivative of the mapping of \textbf{MappedGrid} \textbf{g2}.
      \item{\textbf{condition} (OUTPUT)} Dimensions:  $(N)$\\*
                            The condition number of the inverse.
    \end{description}
    This function computes the condition number of the mapping inverse.
    \def\diag{\mathop{\rm diag}\nolimits}
    \[
      \textbf{condition}(i) = \left\| \diag \big( 1/\textbf{g2.gridSpacing}(\ast) \big)
                                              \big[ \textbf{rx2}(i,\ast,\ast) \big]
                                              \big[ \textbf{xr1}(i,\ast,\ast) \big]
                                        \diag \big( \textbf{gridSpacing}(\ast) \big) \right\|_\infty
    \]
  \subsubsection{void specifyProcesses(const Range\&~range)}
  \label{MappedGrid::specifyProcesses(range)}
    Specify the set of processes over which \textbf{MappedGridFunction}s are distributed.
    We now support only the specification of a contiguous range of virtual process IDs.

  \subsubsection{virtual void initialize(const Integer\&~numberOfDimensions\_)}
  \label{MappedGrid::initialize(numberOfDimensions_)}
    Initialize the MappedGrid with the given number of dimensions.
    The number of dimensions given must be consistent with the number of dimensions of the \textbf{Mapping} used by the grid.

\subsection{Public Member functions for access to data}
\label{MappedGrid::PublicAccessToData}

  \subsubsection{const Integer\& numberOfDimensions() const}
  \label{MappedGrid::numberOfDimensions() const}
    This function returns a reference to the number of dimensions of the domain.

  \subsubsection{const IntegerArray\& dimension() const}
  \label{MappedGrid::dimension()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{dimension}() holds the dimensions (lower and upper index bounds)
    for the indices corresponding to coordinates in the parameter space of the
    grid, of \textbf{MappedGridFunctions} of all types defined on the grid.
    \textbf{dimension}(i,j) refers to the side of the grid corresponding to the
    coordinate value $r_j = i$ in the parameter space of the grid.  If the grid
    has ghost points, then $\textbf{dimension}() \ne \textbf{gridIndexRange}()$.
    For the extra dimensions $\textbf{numberOfDimensions}()\le j \le 2$, if any, $\textbf{dimension}(i,j)=0$.
    This data is always recomputed by the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{const IntegerArray\& indexRange() const}
  \label{MappedGrid::indexRange()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{indexRange}() holds the range of indices of the discretization points.
    \textbf{indexRange}(i,j) refers to the side of the grid corresponding to
    the coordinate value $r_j = i$ in the parameter space of the grid.
    In those coordinate directions $j$ where the grid is neither cell-centered nor
    periodic, and for $j\ge\textbf{numberOfDimensions}()$, the discretization points
    have the same index range as the vertices of the grid, so
    $\textbf{indexRange}(i,j) = \textbf{gridIndexRange}(i,j)$ for $i=0$ and
    for $i=1$.  In cell-centered or periodic coordinate directions $j$,
    the first discretization point has the same index as the first vertex, so
    $\textbf{indexRange}(0,j) = \textbf{gridIndexRange}(0,j)$, but there is
    one discretization point fewer than the number of vertices, so
    $\textbf{indexRange}(1,j) = \textbf{gridIndexRange}(1,j) - 1$.
    For the extra dimensions $\textbf{numberOfDimensions}()\le j \le 2$, if any, $\textbf{indexRange}(i,j)=0$.
    This data is always recomputed by the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{const IntegerArray\& extendedIndexRange() const}
  \label{MappedGrid::extendedIndexRange()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{extendedIndexRange}() holds the range of indices of the discretization points and interpolation points.
    \textbf{extendedIndexRange}(i,j) refers to the side of the grid corresponding to
    the coordinate value $r_j = i$ in the parameter space of the grid.
    On those sides of the grid $(i,j)$ where the grid has a non-zero boundary condition,
    or where the grid is periodic in coordinate direction $j$, and for
    $j\ge\textbf{numberOfDimensions}()$, the interpolation points
    have the same index range as the discretization points, so
    $\textbf{extendedIndexRange}(i,j) = \textbf{indexRange}(i,j)$.
    On those sides of the grid $(i,j)$ where the grid has a zero boundary condition, the index range of the
    interpolation points extends outside the index range of the discretization points by the lesser of
    $(\textbf{discretizationWidth}(j)-1)/2$ and $\textbf{numberOfGhostPoints}(i,j)$.
    For the extra dimensions $\textbf{numberOfDimensions}()\le j \le 2$, if any, $\textbf{extendedIndexRange}(i,j)=0$.
    This data is always recomputed by the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{const IntegerArray\& gridIndexRange() const}
  \label{MappedGrid::gridIndexRange()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{gridIndexRange}() holds the range of indices of the grid vertices.
    \textbf{gridIndexRange}(i,j) refers to the side of the grid corresponding to
    the coordinate value $r_j = i$ in the parameter space of the grid.
    For the extra dimensions $\textbf{numberOfDimensions}()\le j \le 2$, if any, $\textbf{gridIndexRange}(i,j)=0$.
    This data may be set using the function
    {\bf{}\hyperref{setGridIndexRange(ks,kd,gridIndexRange\_)}{setGridIndexRange(ks,kd,gridIndexRange\_) \rm(\S}{)}{MappedGrid::setGridIndexRange(ks,kd,gridIndexRange_)}}.

  \subsubsection{void setGridIndexRange(const Integer\&~ks, const Integer\&~kd, const Integer\&~gridIndexRange\_)}
  \label{MappedGrid::setGridIndexRange(ks,kd,gridIndexRange_)}
    This function is used to change the value of
    {\bf{}\hyperref{gridIndexRange()}{gridIndexRange() \rm(\S}{)}{MappedGrid::gridIndexRange()}}.
    If the new value is different from the old value, then all geometric data is destroyed.

  \subsubsection{const IntegerArray\& numberOfGhostPoints() const}
  \label{MappedGrid::numberOfGhostPoints()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{numberOfGhostPoints}() holds the number of ghost point vertices on
    each side of the grid.  \textbf{numberOfGhostPoints}(i,j) refers to the
    side of the grid corresponding to the coordinate value $r_j = i$ in the
    parameter space of the grid.  The number of ghost points is the difference
    between the corresponding bounds on the grid vertex index range and on the
    dimensions, so
    \[ \textbf{numberOfGhostPoints}(i,j) = (-1)^i
       \big(\textbf{gridIndexRange}(i,j) - \textbf{dimension}(i,j)\big).
    \]
    This data may be set using the function
    {\bf{}\hyperref{setNumberOfGhostPoints(ks,kd,numberOfGhostPoints\_)}{setNumberOfGhostPoints(ks,kd,numberOfGhostPoints\_) \rm(\S}{)}{MappedGrid::setNumberOfGhostPoints(ks,kd,numberOfGhostPoints_)}}.

  \subsubsection{void setNumberOfGhostPoints(const Integer\&~ks, const Integer\&~kd, const Integer\&~numberOfGhostPoints\_)}
  \label{MappedGrid::setNumberOfGhostPoints(ks,kd,numberOfGhostPoints_)}
    This function is used to change the value of
    {\bf{}\hyperref{numberOfGhostPoints()}{numberOfGhostPoints() \rm(\S}{)}{MappedGrid::numberOfGhostPoints()}}.
    If the new value is different from the old value, then all geometric data is destroyed.

  \subsubsection{const Logical\& useGhostPoints() const}
  \label{MappedGrid::useGhostPoints() const}
    This function returns a reference to a flag that is \textbf{LogicalTrue} (non-zero) if and only if
    ghost points on the grid are used on boundaries where the boundary condition is zero.
    This data may be set using the function
    {\bf{}\hyperref{setUseGhostPoints(useGhostPoints\_)}{setUseGhostPoints(useGhostPoints\_) \rm(\S}{)}{MappedGrid::setUseGhostPoints(useGhostPoints_)}}.

  \subsubsection{void setUseGhostPoints(const Logical\&~useGhostPoints\_)}
  \label{MappedGrid::setUseGhostPoints(useGhostPoints_)}
    This function is used to change the value of
    {\bf{}\hyperref{useGhostPoints()}{useGhostPoints() \rm(\S}{)}{MappedGrid::useGhostPoints() const}}.
    If the new value is different from the old value, then all geometric data is destroyed.

  \subsubsection{const IntegerArray\& discretizationWidth() const}
  \label{MappedGrid::discretizationWidth()}
    Dimensions: $(0\colon2)$ \\*[\parskip]
    \textbf{discretizationWidth}() holds the width of the interior discretization stencil.
    This means that every interior discretization point is guaranteed to have available to it
    a stencil of this width consisting of valid points for use in the discretization of a PDE.
    Points that are so close to the boundary that such a stencil would extend outside the grid
    are not considered to be interior discretization points, but may be boundary discretization points.
    \textbf{discretizationWidth}(i) refers to the width of the stencil in the direction
    corresponding to the coordinate $r_i$ in the parameter space of the grid.
    For the extra dimensions $\textbf{numberOfDimensions}()\le i \le 2$, if any, $\textbf{discretizationWidth}(i)=0$.
    This data may be set using the function
    {\bf{}\hyperref{setDiscretizationWidth(kd,discretizationWidth\_)}{setDiscretizationWidth(kd,discretizationWidth\_) \rm(\S}{)}{MappedGrid::setDiscretizationWidth(kd,discretizationWidth_)}}.

  \subsubsection{void setDiscretizationWidth(const Integer\&~kd, const Integer\&~discretizationWidth\_)}
  \label{MappedGrid::setDiscretizationWidth(kd,discretizationWidth_)}
    This function is used to change the value of
    {\bf{}\hyperref{discretizationWidth()}{discretizationWidth() \rm(\S}{)}{MappedGrid::discretizationWidth()}}.

  \subsubsection{const IntegerArray\& boundaryDiscretizationWidth() const}
  \label{MappedGrid::boundaryDiscretizationWidth()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{boundaryDiscretizationWidth}() holds the width of the boundary condition discretization stencil
    in the direction normal to the boundary, on each side of the grid.
    This means that every boundary discretization point is guaranteed to have available to it a one-sided
    stencil of this width consisting of valid points for use in the discretization of boundary conditions.
    This stencil includes points on the boundary and extends from there into the interior of the grid.
    \textbf{boundaryDiscretizationWidth}(i,j) refers to the side of the grid corresponding to
    the coordinate value $r_j = i$ in the parameter space of the grid.
    The boundary condition stencil width does not consider any ghost points.
    It considers only points on the boundary and inside the grid.
    In addition, any number of ghost points may be used as needed for the discretization of boundary conditions.
    For the extra dimensions $\textbf{numberOfDimensions}()\le j \le 2$, if any, $\textbf{boundaryDiscretizationWidth}(i,j)=0$.
    This data may be set using the function
    {\bf{}\hyperref{setBoundaryDiscretizationWidth(ks,kd,boundaryDiscretizationWidth\_)}{setBoundaryDiscretizationWidth(ks,kd,boundaryDiscretizationWidth\_) \rm(\S}{)}{MappedGrid::setBoundaryDiscretizationWidth(ks,kd,boundaryDiscretizationWidth_)}}.

  \subsubsection{void setBoundaryDiscretizationWidth(const Integer\&~ks, const Integer\&~kd, const Integer\&~boundaryDiscretizationWidth\_)}
  \label{MappedGrid::setBoundaryDiscretizationWidth(ks,kd,boundaryDiscretizationWidth_)}
    This function is used to change the value of
    {\bf{}\hyperref{boundaryDiscretizationWidth()}{boundaryDiscretizationWidth() \rm(\S}{)}{MappedGrid::boundaryDiscretizationWidth()}}.

  \subsubsection{const IntegerArray\& boundaryCondition()}
  \label{MappedGrid::boundaryCondition()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{boundaryCondition}() holds the boundary condition flags,
    which indicate how each side of the grid is used;
    \textbf{boundaryCondition}(i,j) refers to the side of the grid corresponding to
    the coordinate value $r_j = i$ in the parameter space of the grid.
    \[\textbf{boundaryCondition}(i,j) \quad \left\{ \begin{array}{lll}
      < 0 & \Rightarrow & \mbox{The domain is periodic in the coordinate $r_j$.}                   \\
      = 0 & \Rightarrow & \mbox{The side corresponding to $r_j=i$ may only interpolate.}           \\
      > 0 & \Rightarrow & \mbox{The side corresponding to $r_j=i$ is part of the domain boundary.} \\
    \end{array} \right. \]
    For the extra dimensions $\textbf{numberOfDimensions}()\le j \le 2$, if any, $\textbf{boundaryCondition}(i,j)={-1}$.
    This data may be set using the function
    {\bf{}\hyperref{setBoundaryCondition(ks,kd,boundaryCondition\_)}{setBoundaryCondition(ks,kd,boundaryCondition\_) \rm(\S}{)}{MappedGrid::setBoundaryCondition(ks,kd,boundaryCondition_)}}.

  \subsubsection{void setBoundaryCondition(const Integer\&~ks, const Integer\&~kd, const Integer\&~boundaryCondition\_)}
  \label{MappedGrid::setBoundaryCondition(ks,kd,boundaryCondition_)}
    This function is used to change the value of
    {\bf{}\hyperref{boundaryCondition()}{boundaryCondition() \rm(\S}{)}{MappedGrid::boundaryCondition()}}.

  \subsubsection{const IntegerArray\& sharedBoundaryFlag() const}
  \label{MappedGrid::sharedBoundaryFlag()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{sharedBoundaryFlags}() holds the shared boundary flags, which may be used to
    indicate which sides of the grid correspond to the same feature of the domain boundary.
    Different features of the domain boundary may be distinguished from each other by their
    being separated by an edge or corner of the domain.  Sides of grids which correspond to
    the same feature of the domain boundary ideally should match exactly where they overlap
    or should at least intersect only tangentially.  In practice this is often impossible
    to ensure (especially in the case of grids whose mappings are defined discretely, for
    example, mappings based on splines), so this flag is useful in order to identify those
    cases where such was the intention.
    \textbf{sharedBoundaryFlag}(i,j) refers to the side of the grid corresponding to
    the coordinate value $r_j = i$ in the parameter space of the grid.
    A unique non-zero flag value should be assigned to \textbf{sharedBoundaryFlag}(i,j)
    for all of those sides of grids that correspond to the same feature of the domain boundary.
    For the extra dimensions $\textbf{numberOfDimensions}()\le j \le 2$, if any, $\textbf{sharedBoundaryFlag}(i,j)=0$.
    This data may be set using the function
    {\bf{}\hyperref{setSharedBoundaryFlag(ks,kd,sharedBoundaryFlag\_)}{setSharedBoundaryFlag(ks,kd,sharedBoundaryFlag\_) \rm(\S}{)}{MappedGrid::setSharedBoundaryFlag(ks,kd,sharedBoundaryFlag_)}}.

  \subsubsection{void setSharedBoundaryFlag(const Integer\&~ks, const Integer\&~kd, const Integer\&~sharedBoundaryFlag\_)}
  \label{MappedGrid::setSharedBoundaryFlag(ks,kd,sharedBoundaryFlag_)}
    This function is used to change the value of
    {\bf{}\hyperref{sharedBoundaryFlag()}{sharedBoundaryFlag() \rm(\S}{)}{MappedGrid::sharedBoundaryFlag()}}.

  \subsubsection{const RealArray\& sharedBoundaryTolerance() const}
  \label{MappedGrid::sharedBoundaryTolerance()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{sharedBoundaryTolerance}() holds the shared boundary error tolerance, which
    indicates by how much the mapping that generates the grid may deviate from the
    ideal domain boundary on each side of the grid, normalized to the width of grid
    cells in the direction normal to the boundary.  In the case where the ideal domain boundary
    is unknown, \textbf{sharedBoundaryTolerance} is a useful estimate of the mismatch
    between sides of the grid that correspond to the same feature of the domain boundary, as
    identified by
    {\bf{}\hyperref{sharedBoundaryFlag()}{sharedBoundaryFlag() \rm(\S}{)}{MappedGrid::sharedBoundaryFlag()}}.
    \textbf{sharedBoundaryTolerance}(i,j) refers to the side of the grid corresponding to
    the coordinate value $r_j = i$ in the parameter space of the grid.
    This data may be set using the function
    {\bf{}\hyperref{setSharedBoundaryTolerance(ks,kd,sharedBoundaryTolerance\_)}{setSharedBoundaryTolerance(ks,kd,sharedBoundaryTolerance\_) \rm(\S}{)}{MappedGrid::setSharedBoundaryTolerance(ks,kd,sharedBoundaryTolerance_)}}.

  \subsubsection{void setSharedBoundaryTolerance(const Integer\&~ks, const Integer\&~kd, const Real\&~sharedBoundaryTolerance\_)}
  \label{MappedGrid::setSharedBoundaryTolerance(ks,kd,sharedBoundaryTolerance_)}
    This function is used to change the value of
    {\bf{}\hyperref{sharedBoundaryTolerance()}{sharedBoundaryTolerance() \rm(\S}{)}{MappedGrid::sharedBoundaryTolerance()}}.

  \subsubsection{const RealArray\& gridSpacing() const}
  \label{MappedGrid::gridSpacing()}
    Dimensions: $(0\colon2)$ \\*[\parskip]
    The grid spacing in the direction of the coordinate $r_i$ in the parameter space of the grid is
    \[ \textbf{gridSpacing}(i) = {1 \over \textbf{gridIndexRange}(1,i) - \textbf{gridIndexRange}(0,i)}. \]
    For the extra dimensions $\textbf{numberOfDimensions}()\le i \le 2$, if any, $\textbf{gridSpacing}(i)=1$.
    This data is always recomputed by the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{const LogicalArray\& isCellCentered() const}
  \label{MappedGrid::isCellCentered()}
    Dimensions: $(0\colon2)$ \\*[\parskip]
    The flag \textbf{isCellCentered}(i) is \textbf{LogicalTrue} (non-zero) if and only if
    $i<\textbf{numberOfDimensions}()$ and the grid is cell-centered in the direction corresponding
    to the coordinate $r_i$ in the parameter space of the grid.
    Cell-centered in direction $i$ means that discretization points lie at positions
    \[ r_i = \left\{ \begin{array}{rl}
      \big(j + {1\over2} - \textbf{indexRange}(0,i)\big)\,\textbf{gridSpacing}(i) & \mbox{if \bf{}isCellCentered}(i) \\
      \big(j             - \textbf{indexRange}(0,i)\big)\,\textbf{gridSpacing}(i) & \mbox{otherwise}                   \\
    \end{array} \right. \]
    for $\textbf{indexRange}(0,i) \le j \le \textbf{indexRange}(1,i)$.
    This data may be set using the function
    {\bf{}\hyperref{setIsCellCentered(kd,isCellCentered\_)}{setIsCellCentered(kd,isCellCentered\_) \rm(\S}{)}{MappedGrid::setIsCellCentered(kd,isCellCentered_)}}.

  \subsubsection{void setIsCellCentered(const Integer\&~kd, const Logical\&~isCellCentered\_)}
  \label{MappedGrid::setIsCellCentered(kd,isCellCentered_)}
    This function is used to change the value of
    {\bf{}\hyperref{isCellCentered()}{isCellCentered() \rm(\S}{)}{MappedGrid::isCellCentered()}}.
    If the new value is different from the old value, then all geometric data is destroyed.
    See also
    {\bf{}\hyperref{changeToAllVertexCentered()}{changeToAllVertexCentered() \rm(\S}{)}{MappedGrid::changeToAllVertexCentered()}} and
    {\bf{}\hyperref{changeToAllCellCentered()}{changeToAllCellCentered() \rm(\S}{)}{MappedGrid::changeToAllCellCentered()}}.

  \subsubsection{const Logical\& isAllCellCentered() const}
  \label{MappedGrid::isAllCellCentered() const}
    This function returns a reference to a flag that is \textbf{LogicalTrue} (non-zero) if and only if
    the grid is cell-centered in all directions.
    This means that the discretization points are grid cell centers.
    This flag is always recomputed by the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.
    See also {\bf{}\hyperref{isCellCentered()}{isCellCentered() \rm(\S}{)}{MappedGrid::isCellCentered()}}.

  \subsubsection{const Logical\& isAllVertexCentered() const}
  \label{MappedGrid::isAllVertexCentered() const}
    This function returns a reference to a flag that is \textbf{LogicalTrue} (non-zero) if and only if
    the grid is vertex-centered in all directions.
    This means that the discretization points are grid vertices.
    This flag is always recomputed by the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.
    See also {\bf{}\hyperref{isCellCentered()}{isCellCentered() \rm(\S}{)}{MappedGrid::isCellCentered()}}.

  \subsubsection{const IntegerArray\& isPeriodic() const}
  \label{MappedGrid::isPeriodic()}
    Dimensions: $(0\colon2)$ \\*[\parskip]
    \textbf{isPeriodic}(i) describes the periodicity of the grid,
    the mapping that generates the grid, and all \textbf{MappedGridFunctions}
    defined on the grid.  \textbf{isPeriodic}(i) is zero (non-periodic) if and
    only if $i<\textbf{numberOfDimensions}()$ and either the derivative of the
    mapping that generates the grid is not periodic in the direction corresponding
    to the coordinate $r_i$ in the parameter space of the grid, or the periodicity
    of the domain does not correspond to the periodicity of the derivative of the
    mapping in this direction.  Two cases exist when the periodicity of the mapping
    corresponds to the periodicity of the domain:  either the mapping itself is
    periodic or it is not.  (In the latter case the mapping differs from a periodic
    function by a linear function.)  These two cases are distinguished by different
    non-zero values of the flag \textbf{isPeriodic}(i).
    All \textbf{MappedGridFunctions} defined on the grid should have the same
    periodicity as the mapping; in each direction where the mapping is periodic,
    all \textbf{MappedGridFunctions} should be periodic, and in each direction
    where the derivative of the mapping is periodic, the derivatives of all
    \textbf{MappedGridFunctions} should be periodic.  The possible values of
    \textbf{isPeriodic}(i) are
    \[ \textbf{isPeriodic}(i) = \left\{ \begin{array}{ll}
      \textbf{Mapping::notPeriodic} = 0    & \mbox{The derivative of the mapping is not periodic.}     \\
      \textbf{Mapping::derivativePeriodic} & \mbox{The derivative is periodic but the mapping is not.} \\
      \textbf{Mapping::functionPeriodic}   & \mbox{The mapping is periodic.}                           \\
    \end{array} \right. \]
    This data may be set using the function
    {\bf{}\hyperref{setIsPeriodic(kd,isPeriodic\_)}{setIsPeriodic(kd,isPeriodic\_) \rm(\S}{)}{MappedGrid::setIsPeriodic(kd,isPeriodic_)}}.

  \subsubsection{void setIsPeriodic(const Integer\&~kd, const Mapping::periodicType\&~isPeriodic\_)}
  \label{MappedGrid::setIsPeriodic(kd,isPeriodic_)}
    This function is used to change the value of
    {\bf{}\hyperref{isPeriodic()}{isPeriodic() \rm(\S}{)}{MappedGrid::isPeriodic()}}.
    If the new value is different from the old value, then all geometric data is destroyed.
    It is important to be sure that the setting of \textbf{isPeriodic} should be
    consistent with the topology of the mapping that defines the geometry of the grid.

  \subsubsection{const RealArray\& minimumEdgeLength() const}
  \label{MappedGrid::minimumEdgeLength()}
    Dimensions: $(0\colon2)$ \\*[\parskip]
    \textbf{minimumEdgeLength}() holds the minimum grid cell-edge length over all
    cell edges in the interior and the boundary of the grid, for each coordinate
    direction in the parameter space of the grid.
    \textbf{minimumEdgeLength}(i) refers to edges of the cells corresponding to
    the coordinate direction $r_i$.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEminMaxEdgeLength}{THEminMaxEdgeLength \rm(\S}{)}{MappedGrid::THEminMaxEdgeLength}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{const RealArray\& maximumEdgeLength() const}
  \label{MappedGrid::maximumEdgeLength()}
    Dimensions: $(0\colon2)$ \\*[\parskip]
    \textbf{maximumEdgeLength}() holds the maximum grid cell-edge length over all
    cell edges in the interior and the boundary of the grid, for each coordinate
    direction in the parameter space of the grid.
    \textbf{maximumEdgeLength}(i) refers to edges of the cells corresponding to
    the coordinate direction $r_i$.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEminMaxEdgeLength}{THEminMaxEdgeLength \rm(\S}{)}{MappedGrid::THEminMaxEdgeLength}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{const RealArray\& boundingBox() const}
  \label{MappedGrid::boundingBox()}
    Dimensions: $(0\colon1,0\colon2)$ \\*[\parskip]
    \textbf{boundingBox}() holds coordinate bounds for the grid vertices, including all boundary vertices but excluding any ghost vertices.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEboundingBox}{THEboundingBox \rm(\S}{)}{MappedGrid::THEboundingBox}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{const Integer$\ast$ I1() const; const Integer$\ast$ I2() const; const Integer$\ast$ I3() const}
  \label{MappedGrid::I1(),I2(),I3()}
    \textbf{I1}(), \textbf{I2}() and \textbf{I3}() return pointers that may be used as arrays for indirect scalar addressing
    of \textbf{MappedGridFunction}s on periodic grids.  This is useful for indices that lie in a discretization or interpolation
    stencil that extends outside the range of indices given by {\bf{}\hyperref{indexRange()}{indexRange() \rm(\S}{)}{MappedGrid::indexRange()}}.
    For example, you might want to index {\bf{}\hyperref{mask()}{mask() \rm(\S}{)}{MappedGrid::mask()}} as
    $\textbf{mask}()(\textbf{I1}()[i],\textbf{I2}()[j],\textbf{I3}()[k])$ instead of $\textbf{mask}()(i,j,k)$ in case $(i,j,k)$ might
    lie outside the range of discretization points of the grid.  The indirect addressing arrays are defined for indices which lie outside
    by at most sixteen.  If you anticipate using stencils wider than this limit would accomodate, then we can increase it for you.

  \subsubsection{IntegerMappedGridFunction\& mask()}
  \label{MappedGrid::mask()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12})$, where $d_{ij} = \textbf{dimension}(i,j)$. \\*[\parskip]
    \textbf{mask}() holds a flag for each point ({\sl{}e.g.}, vertex or cell-center), which indicates how that point should be used.
    Various bits of the mask may be tested by ANDing the mask with any of the constants
    {\bf{}\hyperref{ISdiscretizationPoint}{ISdiscretizationPoint \rm(\S}{)}{MappedGrid::ISdiscretizationPoint}},
    {\bf{}\hyperref{ISinterpolationPoint}{ISinterpolationPoint \rm(\S}{)}{MappedGrid::ISinterpolationPoint}},
    {\bf{}\hyperref{ISghostPoint}{ISghostPoint \rm(\S}{)}{MappedGrid::ISghostPoint}},
    {\bf{}\hyperref{ISinteriorBoundaryPoint}{ISinteriorBoundaryPoint \rm(\S}{)}{MappedGrid::ISinteriorBoundaryPoint}},
    {\bf{}\hyperref{USESbackupRules}{USESbackupRules \rm(\S}{)}{MappedGrid::USESbackupRules}},
    {\bf{}\hyperref{IShiddenByRefinement}{IShiddenByRefinement \rm(\S}{)}{MappedGrid::IShiddenByRefinement}} or
    {\bf{}\hyperref{ISusedPoint}{ISusedPoint \rm(\S}{)}{MappedGrid::ISusedPoint}}, and checking if the result is non-zero.
    \[ \textbf{mask}()(i,j,k) \left\{ \begin{array}{lll}
      \&\ \textbf{ISdiscretizationPoint}   \ne 0 & \Rightarrow & \mbox{discretization point}                                 \\
      \&\ \textbf{ISinterpolationPoint}    \ne 0 & \Rightarrow & \mbox{interpolation point}                                  \\
      \&\ \textbf{ISghostPoint}            \ne 0 & \Rightarrow & \mbox{ghost point near a disc.\ or interp.~boundary point.} \\
      \&\ \textbf{ISinteriorBoundaryPoint} \ne 0 & \Rightarrow & \mbox{boundary point in the interior of another grid}       \\
      \&\ \textbf{USESbackupRules}         \ne 0 & \Rightarrow & \mbox{discretization or interpolation uses backup rules}    \\
      \&\ \textbf{IShiddenByRefinement}    \ne 0 & \Rightarrow & \mbox{hidden by points on a refinement grid}                \\
      \&\ \textbf{ISusedPoint}              =  0 & \Rightarrow & \mbox{neither discretization nor interpolation point}       \\
    \end{array} \right. \]
    This data may be updated as in the following example.
    See also {\bf{}\hyperref{THEmask}{THEmask \rm(\S}{)}{MappedGrid::THEmask}} and
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{RealMappedGridFunction\& vertex()}
  \label{MappedGrid::vertex()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{vertex}() holds the coordinates of the vertices of the grid, including any ghost vertices (which lie outside the grid).
    \[
      \textbf{vertex}()(i_0,i_1,i_2,\ast) = \mbox{\boldmath $g$}(\textbf{r}),
      \quad\mbox{where}\quad
      r_j = \big(i_j - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j),
    \]
    $\textbf{dimension}(0,j) \le i_j \le \textbf{dimension}(1,j)$, and {\boldmath $g$} is the mapping that generates the grid.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEvertex}{THEvertex \rm(\S}{)}{MappedGrid::THEvertex}} and
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& center()}
  \label{MappedGrid::center()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{center}() holds the coordinates of the discretization points of the grid,
    ({\sl{}e.g.}, the vertices or the grid cell-centers), including any ghost points (which lie outside the grid).
    \[
      \textbf{center}()(i_0,i_1,i_2,\ast) = \mbox{\boldmath $g$}(\textbf{r}),
      \quad\mbox{where}\quad
      r_j = \left\{ \begin{array}{rl}
        \big(i_j + {1\over2} - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{if \bf{}isCellCentered}(j) \\
        \big(i_j             - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{otherwise},                \\
      \end{array} \right.
    \]
    $\textbf{dimension}(0,j) \le i_j \le \textbf{dimension}(1,j)$, and {\boldmath $g$} is the mapping that generates the grid.
    If \textbf{center}() is updated using a discrete approximation, then it is not computed using the mapping, but is instead
    computed by averaging {\bf{}\hyperref{corner()}{corner() \rm(\S}{)}{MappedGrid::corner()}} in each direction:
    \[
      \textbf{center}()(i_0,i_1,i_2,\ast) = \Big(\prod_j\mu_{+j}\Big)\textbf{corner}()(i_0,i_1,i_2,\ast).
    \]
    {\em Warning:  In the case of a vertex-centered grid, \textbf{center}() is not computed by averaging \textbf{corner}, but is
    equal to, and may be aliased to, {\bf{}\hyperref{vertex()}{vertex() \rm(\S}{)}{MappedGrid::vertex()}}.}
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEcenter}{THEcenter \rm(\S}{)}{MappedGrid::THEcenter}} and
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& corner()}
  \label{MappedGrid::corner()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{corner}() holds the coordinates of the corners of cells centered at the discretization points of the grid,
    ({\sl{}e.g.}, the vertices or the grid cell-centers), including any ghost points (which lie outside the grid).
    \[
      \textbf{corner}()(i_0,i_1,i_2,\ast) = \mbox{\boldmath $g$}(\textbf{r}),
      \quad\mbox{where}\quad
      r_j = \left\{ \begin{array}{rl}
        \big(i_j             - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{if \bf{}isCellCentered}(j) \\
        \big(i_j - {1\over2} - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{otherwise},                \\
      \end{array} \right.
    \]
    $\textbf{dimension}(0,j) \le i_j \le \textbf{dimension}(1,j)$, and {\boldmath $g$} is the mapping that generates the grid.
    {\em Note:  In the case of a cell-centered grid, \textbf{corner}() is equal to, and may be aliased to,
    {\bf{}\hyperref{vertex()}{vertex() \rm(\S}{)}{MappedGrid::vertex()}}.}
    This geometric data may be updated as in the following example.
%    \beginExample
%      \textbf{MappedGrid} g;                                                         & // Construct a \textbf{MappedGrid}.    \\
%      g.\textbf{update}(\textbf{MappedGrid::THEcorner});                          & // Update \textbf{corner}(), or \dots  \\
%      g.\textbf{update}(\textbf{MappedGrid::THEcorner},                           & // Force re-update of \textbf{corner}, \\
%      \phantom{g.\textbf{update}(}\textbf{MappedGrid::COMPUTEgeometry} $\mid$     & // this time using a                      \\
%      \phantom{g.\textbf{update}(}\textbf{MappedGrid::USEdiscreteApproximation}); & // discrete approximation.                \\
%    \endExample
    See also {\bf{}\hyperref{THEcorner}{THEcorner \rm(\S}{)}{MappedGrid::THEcorner}} and
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& vertexDerivative()}
  \label{MappedGrid::vertexDerivative()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1,0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{vertexDerivative}() holds the derivative of the mapping at the vertices of the grid,
    including any ghost vertices (which lie outside the grid).
    \[
      \textbf{vertexDerivative}()(i_0,i_1,i_2,\ast,j) = {\partial \mbox{\boldmath $g$} \over \partial r_j},
      \quad\mbox{where}\quad
      r_j = \big(i_j - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j),
    \]
    $\textbf{dimension}(0,j) \le i_j \le \textbf{dimension}(1,j)$, and {\boldmath $g$} is the mapping that generates the grid.
    If \textbf{vertexDerivative}() is updated using a discrete approximation, then it is not computed using the mapping, but is instead
    computed by centered finite differences of \textbf{vertex}:
    \[
      \textbf{vertexDerivative}()(i_0,i_1,i_2,\ast,j) = {1 \over 2\Delta r_j} \Delta_{0j} \textbf{vertex}()(i_0,i_1,i_2,\ast),
    \]
    where $\Delta r_j = \textbf{gridSpacing}(j)$.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEvertexDerivative}{THEvertexDerivative \rm(\S}{)}{MappedGrid::THEvertexDerivative}} and
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& centerDerivative()}
  \label{MappedGrid::centerDerivative()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1,0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{centerDerivative}() holds the derivative of the mapping at the discretization points of the grid,
    including any ghost points (which lie outside the grid).
    \[
      \textbf{centerDerivative}()(i_0,i_1,i_2,\ast,j) = {\partial \mbox{\boldmath $g$} \over \partial r_j}, \quad\mbox{where}
    \]
    \[
      r_j = \left\{ \begin{array}{rl}
        \big(i_j + {1\over2} - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{if \bf{}isCellCentered}(j) \\
        \big(i_j             - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{otherwise},                \\
      \end{array} \right.
    \]
    $\textbf{dimension}(0,j) \le i_j \le \textbf{dimension}(1,j)$, and {\boldmath $g$} is the mapping that generates the grid.
    If \textbf{centerDerivative}() is updated using a discrete approximation, then it is not computed using the mapping, but is instead
    {\bf{}\hyperref{corner()}{corner() \rm(\S}{)}{MappedGrid::corner()}}:
    \[
      \textbf{centerDerivative}()(i_0,i_1,i_2,\ast,j) =
      \Big(\prod_{k \ne j}\mu_{+k}\Big) {1 \over \Delta r_j} \Delta_{+j} \textbf{corner}()(i_0,i_1,i_2,\ast).
    \]
    where $\Delta r_j = \textbf{gridSpacing}(j)$.
    {\em Warning:  In the case of a vertex-centered grid, \textbf{centerDerivative}() is not computed by differencing and averaging \textbf{corner}(),
    but is equal to, and may be aliased to, {\bf{}\hyperref{vertexDerivative()}{vertexDerivative() \rm(\S}{)}{MappedGrid::vertexDerivative()}}.}
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEcenterDerivative}{THEcenterDerivative \rm(\S}{)}{MappedGrid::THEcenterDerivative}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& inverseVertexDerivative()}
  \label{MappedGrid::inverseVertexDerivative()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1,0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{inverseVertexDerivative}() holds the inverse of the derivative of the mapping at the vertices of the grid,
    including any ghost vertices (which lie outside the grid).
    \[
      [ \textbf{inverseVertexDerivative}()(i_0,i_1,i_2,\ast,\ast) ] = 
      [ \textbf{vertexDerivative}()(i_0,i_1,i_2,\ast,\ast) ]^{-1} \quad=\left[{\partial \rv\over\partial\xv}\right].
    \]
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{vertexDerivative()}{vertexDerivative() \rm(\S}{)}{MappedGrid::vertexDerivative()}},
    {\bf{}\hyperref{THEinverseVertexDerivative}{THEinverseVertexDerivative \rm(\S}{)}{MappedGrid::THEinverseVertexDerivative}} and
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& inverseCenterDerivative()}
  \label{MappedGrid::inverseCenterDerivative()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1,0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{inverseCenterDerivative}() holds the inverse of the derivative of the mapping at the discretization points of the grid,
    ({\sl{}e.g.}, the vertices or the grid cell-centers), including any ghost points (which lie outside the grid).
    \[
      [ \textbf{inverseCenterDerivative}()(i_0,i_1,i_2,\ast,\ast) ] = 
      [ \textbf{centerDerivative}()(i_0,i_1,i_2,\ast,\ast) ]^{-1} \quad=\left[{\partial \rv\over\partial\xv}\right].
    \]
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{centerDerivative()}{centerDerivative() \rm(\S}{)}{MappedGrid::centerDerivative()}},
    {\bf{}\hyperref{THEinverseCenterDerivative}{THEinverseCenterDerivative \rm(\S}{)}{MappedGrid::THEinverseCenterDerivative}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& vertexJacobian()}
  \label{MappedGrid::vertexJacobian()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12})$, where $d_{ij} = \textbf{dimension}(i,j)$. \\*[\parskip]
    \textbf{vertexJacobian}() holds the determinant of the derivative of the mapping at the vertices of the grid,
    including any ghost vertices (which lie outside the grid).
    \[
      \textbf{vertexJacobian}()(i_0,i_1,i_2) = \det\left[{\partial\mbox{\boldmath$g$} \over \partial\mbox{\boldmath$r$}}\right],
      \quad\mbox{where}\quad
      r_j = \big(i_j - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j),
    \]
    $\textbf{dimension}(0,j) \le i_j \le \textbf{dimension}(1,j)$, and {\boldmath $g$} is the mapping that generates the grid.
    If \textbf{vertexJacobian}() is updated using a discrete approximation, then it is not computed using the mapping, but is instead
    computed using the same approximation to the derivative as that used for
    {\bf{}\hyperref{vertexJacobian()}{vertexJacobian() \rm(\S}{)}{MappedGrid::vertexJacobian()}}.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{vertexDerivative()}{vertexDerivative() \rm(\S}{)}{MappedGrid::vertexDerivative()}},
    {\bf{}\hyperref{THEvertexJacobian}{THEvertexJacobian \rm(\S}{)}{MappedGrid::THEvertexJacobian}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{RealMappedGridFunction\& centerJacobian()}
  \label{MappedGrid::centerJacobian()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12})$, where $d_{ij} = \textbf{dimension}(i,j)$. \\*[\parskip]
    \textbf{centerJacobian}() holds the determinant of the derivative of the mapping at the discretization points of the grid,
    including any ghost points (which lie outside the grid).
    \[
      \textbf{centerJacobian}()(i_0,i_1,i_2) = \det\left[{\partial\mbox{\boldmath$g$} \over \partial\mbox{\boldmath$r$}}\right], \quad\mbox{where}
    \]
    \[
      r_j = \left\{ \begin{array}{rl}
        \big(i_j + {1\over2} - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{if \bf{}isCellCentered}(j) \\
        \big(i_j             - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{otherwise},                \\
      \end{array} \right.
    \]
    $\textbf{dimension}(0,j) \le i_j \le \textbf{dimension}(1,j)$, and {\boldmath $g$} is the mapping that generates the grid.
    If \textbf{centerJacobian}() is updated using a discrete approximation, then it is not computed using the mapping, but is instead
    computed using the same approximation to the derivative as that used for
    {\bf{}\hyperref{centerDerivative()}{centerDerivative() \rm(\S}{)}{MappedGrid::centerDerivative()}}.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{centerDerivative()}{centerDerivative() \rm(\S}{)}{MappedGrid::centerDerivative()}},
    {\bf{}\hyperref{THEcenterJacobian}{THEcenterJacobian \rm(\S}{)}{MappedGrid::THEcenterJacobian}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{RealMappedGridFunction\& cellVolume()}
  \label{MappedGrid::cellVolume()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12})$,
    where $d_{ij} = \textbf{dimension}(i,j)$. \\*[\parskip]
    \textbf{cellVolume}() holds the volumes of cells centered at the discretization points of the grid, including any ghost cells (which lie outside the grid).
    \[
      \textbf{cellVolume}()(i_0,i_1,i_2) = \Big(\prod_j\Delta r_j\Big) \det\left[{\partial\mbox{\boldmath$g$} \over \partial\mbox{\boldmath$r$}}\right],
      \quad\mbox{where}
    \]
    \[
      r_j = \left\{ \begin{array}{rl}
        \big(i_j + {1\over2} - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{if \bf{}isCellCentered}(j) \\
        \big(i_j             - \textbf{indexRange}(0,j)\big)\,\textbf{gridSpacing}(j) & \mbox{otherwise},                \\
      \end{array} \right.
    \]
    $\Delta r_j = \textbf{gridSpacing}(j)$,
    $\textbf{dimension}(0,j) \le i_j \le \textbf{dimension}(1,j)$, and {\boldmath $g$} is the mapping that generates the grid.
    \textbf{cellVolume}() has the same sign as the determinant of the derivative of the mapping.  ({\sl I.e.}, it may be negative.)
    If \textbf{cellVolume}() is updated using a discrete approximation, then it is not computed using the mapping, but is instead
    computed in one dimension as the distance between surrounding corners, approximated in two dimensions by the area of the
    polygon bounded by the surrounding corners, and approximated in three dimensions by the volume of the solid bounded by the
    surrounding corners, with the approximation that the four corners of each face are assumed to be coplanar.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEcellVolume}{THEcellVolume \rm(\S}{)}{MappedGrid::THEcellVolume}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{RealMappedGridFunction\& faceNormal()}
  \label{MappedGrid::faceNormal()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1,0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{faceNormal}() holds vectors normal to faces of cells centered at the discretization points (including any ghost cell faces),
    normalized to the cell-face area.
    The normal to cell face $(i_0,i_1,i_2)$ corresponding to constant $r_j$ is given by
    \[
      \textbf{faceNormal}()(i_0,i_1,i_2,\ast,j) = \Delta r_k \Delta r_l
      {\partial \textbf{g} \over \partial r_k} \times {\partial \textbf{g} \over \partial r_l},
      \quad\mbox{where $k=(j+1)\bmod3$, $l=(j+2)\bmod3$},
    \]
    where $\Delta r_j=1$ for $j>n_0$, ${\partial g_i \over \partial r_j} = \delta_{ij}$
    for $i>n_0$ or $j>n_0$, $n_0=\textbf{numberOfDimensions}()-1$, $\Delta r_j = \textbf{gridSpacing}(j)$,
    \[
      r_k = \left\{ \begin{array}{rl}
        \big(i_k             - \textbf{indexRange}(0,k)\big)\,\textbf{gridSpacing}(k) & \mbox{if $k=j$ and \textbf{isCellCentered(k)}, or else} \\
        \big(i_k + {1\over2} - \textbf{indexRange}(0,k)\big)\,\textbf{gridSpacing}(k) & \mbox{if $k=j$, or}                                        \\
        \big(i_k - {1\over2} - \textbf{indexRange}(0,k)\big)\,\textbf{gridSpacing}(k) & \mbox{if \textbf{isCellCentered(k)}, or else}           \\
        \big(i_k             - \textbf{indexRange}(0,k)\big)\,\textbf{gridSpacing}(k) & \mbox{otherwise},                                          \\
      \end{array} \right.
    \]
    $\textbf{dimension}(0,k) \le i_k \le \textbf{dimension}(1,k)$, and {\boldmath $g$} is the mapping that generates the grid.
    In particular, $\textbf{faceNormal}()(i_0,i_1,i_2,0,0)=1$ if $\textbf{numberOfDimensions}()=1$.
    If \textbf{faceNormal}() is updated using a discrete approximation, then the derivatives are not computed using the mapping,
    but are instead computed by centered finite differences of {\bf{}\hyperref{corner()}{corner() \rm(\S}{)}{MappedGrid::corner()}},
    (averaged in three dimensions to the centers of cell faces).  As a result, in two dimensions,
    \begin{eqnarray*}
      \textbf{faceNormal}()(i,j,k,\ast,0) & = & \phantom{-} \Delta_{+j} \textbf{corner}(i,j,k,\ast) \\
      \textbf{faceNormal}()(i,j,k,\ast,1) & = &          -  \Delta_{+i} \textbf{corner}(i,j,k,\ast) \\
    \end{eqnarray*}
    and in three dimensions,
    \begin{eqnarray*}
      \textbf{faceNormal}()(i_0,i_1,i_2,\ast,j)
      & = & \mu_{+i_l} \Delta_{+i_k} \textbf{corner}(i_0,i_i,i_2,\ast) \times \mu_{+i_k} \Delta_{+i_l} \textbf{corner}(i_0,i_i,i_2,\ast) \\
      & = & {1\over2} \Delta_{\nearrow+i_k+i_l} \textbf{corner}(i_0,i_1,i_2,\ast) \times \Delta_{\nwarrow+i_l+i_k} \textbf{corner}(i_0,i_1,i_2,\ast) \\
    \end{eqnarray*}
    where $k=(j+1)\bmod3$, $l=(j+2)\bmod3$,
    $\Delta_{\nearrow+i+j} u_{ij} \equiv u_{i+1,j+1}-u_{ij}$ and
    $\Delta_{\nwarrow+i+j} u_{ij} \equiv u_{i,j+1}-u_{i+1,j}$.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEfaceNormal}{THEfaceNormal \rm(\S}{)}{MappedGrid::THEfaceNormal}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& centerNormal()}
  \label{MappedGrid::centerNormal()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1,0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    The normal to the surface corresponding to constant $r_j$ and passing through the
    discretization point $(i_0,i_1,i_2)$,
    normalized to the area of that portion of this surface which corresponds one cell, is given by
    \[
      \textbf{centerNormal}()(i_0,i_1,i_2,\ast,j) = \Delta r_k \Delta r_l
      {\partial \textbf{g} \over \partial r_k} \times {\partial \textbf{g} \over \partial r_l},
      \quad\mbox{where $k=(j+1)\bmod3$, $l=(j+2)\bmod3$},
    \]
    where $\Delta r_j=1$ for $j>n_0$, ${\partial g_i \over \partial r_j} = \delta_{ij}$
    for $i>n_0$ or $j>n_0$, $n_0=\textbf{numberOfDimensions}()-1$, $\Delta r_j = \textbf{gridSpacing}(j)$,
    \[
      r_k = \left\{ \begin{array}{rl}
        \big(i_k + {1\over2} - \textbf{indexRange}(0,k)\big)\,\textbf{gridSpacing}(k) & \mbox{if \bf{}isCellCentered}(k) \\
        \big(i_k             - \textbf{indexRange}(0,k)\big)\,\textbf{gridSpacing}(k) & \mbox{otherwise},                \\
      \end{array} \right.
    \]
    $\textbf{dimension}(0,k) \le i_k \le \textbf{dimension}(1,k)$, and {\boldmath $g$} is the mapping that generates the grid.
    In particular, $\textbf{centerNormal}()(i_0,i_1,i_2,0,0)=1$ if $\textbf{numberOfDimensions}()=1$.
    In fact, \textbf{centerNormal}() is related to
    {\bf{}\hyperref{inverseCenterDerivative()}{inverseCenterDerivative() \rm(\S}{)}{MappedGrid::inverseCenterDerivative()}}
    and {\bf{}\hyperref{centerJacobian()}{centerJacobian() \rm(\S}{)}{MappedGrid::centerJacobian()}}:
    \[
      \left[ \textbf{centerNormal}()(i_0,i_1,i_2,\ast,\ast) \right] =
      \Big(\prod_j \Delta r_j\Big) \textbf{centerJacobian}()(i_0,i_1,i_2)
      \left[ \textbf{inverseCenterDerivative}()(i_0,i_1,i_2,\ast,\ast) \right]^{\mbox{\tiny T}}.
    \]
    If \textbf{centerNormal}() is updated using a discrete approximation, then it is obtained by averaging
    {\bf{}\hyperref{faceNormal()}{faceNormal() \rm(\S}{)}{MappedGrid::faceNormal()}}
    from the face-centers to the discretization points.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEcenterNormal}{THEcenterNormal \rm(\S}{)}{MappedGrid::THEcenterNormal}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& faceArea()}
  \label{MappedGrid::faceArea()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{faceArea}() holds the areas of faces of cells centered at the discretization points (including any ghost cell faces).
    The area of the cell face $(i_0,i_1,i_2)$ corresponding to constant $r_j$ is given by
    \[
      \textbf{faceArea}()(i_0,i_1,i_2,j) = \big|\textbf{faceNormal}()(i_0,i_1,i_2,\ast,j)\big|.
    \]
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{faceNormal()}{faceNormal() \rm(\S}{)}{MappedGrid::faceNormal()}},
    {\bf{}\hyperref{THEfaceArea}{THEfaceArea \rm(\S}{)}{MappedGrid::THEfaceArea}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& centerArea()}
  \label{MappedGrid::centerArea()}
    Dimensions: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1)$,
    where $d_{ij} = \textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{centerArea}() holds the areas of those portions of surfaces corresponding to a constant parameter value, passing through the
    discretization points, which are contained within the cells centered at these points (including any ghost cells).
    The area of the portion of the surface passing through the cell centered at the discretization point $(i_0,i_1,i_2)$ and
    corresponding to constant $r_j$ is given by
    \[
      \textbf{centerArea}()(i_0,i_1,i_2,j) = \big|\textbf{centerNormal}()(i_0,i_1,i_2,\ast,j)\big|.
    \]
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{centerNormal()}{centerNormal() \rm(\S}{)}{MappedGrid::centerNormal()}},
    {\bf{}\hyperref{THEcenterArea}{THEcenterArea \rm(\S}{)}{MappedGrid::THEcenterArea}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.


  \subsubsection{RealMappedGridFunction\& vertexBoundaryNormal(const Integer\&~k, const Integer\&~l)}
  \label{MappedGrid::vertexBoundaryNormal(k,l)}
    Dimensions of vertexBoundaryNormal($k$,$l$): $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1)$,
    where \[d_{ij} = \left\{ \begin{array}{ll}
      \textbf{dimension}(k,j) & \mbox{if $j=l$}  \\
      \textbf{dimension}(i,j) & \mbox{otherwise} \\
    \end{array} \right. \]
    and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{vertexBoundaryNormal} holds unit outward normal vectors to the boundary at the boundary vertices.
    The normal corresponding to the side of the grid where $r_j=i$ is given by
    \[
      \textbf{vertexBoundaryNormal}(i,j)(i_0,i_1,i_2,\ast) = \pm (-1)^{i+1}
      {{\partial \textbf{g} \over \partial r_k} \times {\partial \textbf{g} \over \partial r_l} \over
      \Big|{\partial \textbf{g} \over \partial r_k} \times {\partial \textbf{g} \over \partial r_l}\Big|},
      \quad\mbox{where $k=(j+1)\bmod3$, $l=(j+2)\bmod3$},
    \]
    ${\partial g_i \over \partial r_j} = \delta_{ij}$ for $i>n_0$ or $j>n_0$, $n_0=\textbf{numberOfDimensions}()-1$,
    \[
      r_m = \big(i_m - \textbf{indexRange}(0,m)\big)\,\textbf{gridSpacing}(m),
    \]
    $\textbf{dimension}(0,m) \le i_m \le \textbf{dimension}(1,m)$, and {\boldmath $g$} is the mapping that generates the grid.
    In particular, $\textbf{vertexBoundaryNormal}(i,0)(i_0,i_1,i_2,0)=\pm(-1)^{i+1}$ if $\textbf{numberOfDimensions}()=1$.
    The upper sign is taken if the coordinate system is right-handed and the lower sign if it is left-handed;
    the sign taken is that of the jacobian of the mapping, $\det\Big[{\partial\mbox{\boldmath$g$} \over \partial\mbox{\boldmath$r$}}\Big]$
    at the center of the grid $r_0=r_1=r_2={1\over2}$.
    If \textbf{vertexBoundaryNormal} is updated using a discrete approximation, then the derivatives are not computed
    using the mapping, but are instead computed by centered finite differences of \textbf{vertex}.  As a result, in two dimensions,
    \begin{eqnarray*}
      \textbf{vertexBoundaryNormal}(i,0)(i_0,i_1,i_2,\ast) & = & \pm (-1)^{i+1} {\Delta_{0i_1} \textbf{vertex}()(i_0,i_1,i_2,\ast) \over
                                                                              \big| \Delta_{0i_1} \textbf{vertex}()(i_0,i_1,i_2,\ast) \big|}  \\
      \textbf{vertexBoundaryNormal}(i,1)(i_0,i_1,i_2,\ast) & = & \mp (-1)^{i+1} {\Delta_{0i_0} \textbf{vertex}()(i_0,i_1,i_2,\ast) \over
                                                                              \big| \Delta_{0i_0} \textbf{vertex}()(i_0,i_1,i_2,\ast) \big|}, \\
    \end{eqnarray*}
    and in three dimensions,
    \[
      \textbf{vertexBoundaryNormal}(i,j)(i_0,i_1,i_2,\ast) = \pm (-1)^{i+1}
           {\Delta_{0i_k} \textbf{vertex}(i_0,i_i,i_2,\ast) \times \Delta_{0i_l} \textbf{vertex}(i_0,i_i,i_2,\ast) \over
      \big| \Delta_{0i_k} \textbf{vertex}(i_0,i_i,i_2,\ast) \times \Delta_{0i_l} \textbf{vertex}(i_0,i_i,i_2,\ast) \big|}
    \]
    where $k=(j+1)\bmod3$ and $l=(j+2)\bmod3$.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEvertexBoundaryNormal}{THEvertexBoundaryNormal \rm(\S}{)}{MappedGrid::THEvertexBoundaryNormal}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{RealMappedGridFunction\& centerBoundaryNormal(const Integer\&~k, const Integer\&~l)}
  \label{MappedGrid::centerBoundaryNormal(k,l)}
    Dimensions of centerBoundaryNormal($k$,$l$): $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1)$,
    where \[d_{ij} = \left\{ \begin{array}{ll}
      \textbf{dimension}(k,j) & \mbox{if $j=l$}  \\
      \textbf{dimension}(i,j) & \mbox{otherwise} \\
    \end{array} \right. \]
    and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{centerBoundaryNormal} holds unit outward normal vectors to the boundary at the discretization points of the boundary.
    Note that for a cell-centered grid, these points are not the cell-centers of boundary cells, but are the centers of the faces
    of boundary cells.  The normal corresponding to the side of the grid where $r_j=i$ is given by
    \[
      \textbf{centerBoundaryNormal}(i,j)(i_0,i_1,i_2,\ast) = \pm (-1)^{i+1}
      {{\partial \textbf{g} \over \partial r_k} \times {\partial \textbf{g} \over \partial r_l} \over
      \Big|{\partial \textbf{g} \over \partial r_k} \times {\partial \textbf{g} \over \partial r_l}\Big|},
      \quad\mbox{where $k=(j+1)\bmod3$, $l=(j+2)\bmod3$},
    \]
    ${\partial g_i \over \partial r_j} = \delta_{ij}$ for $i>n_0$ or $j>n_0$, $n_0=\textbf{numberOfDimensions}()-1$,
    \[
      r_m = \left\{ \begin{array}{rl}
        i                                                                                   & \mbox{if $m=j$, or else}         \\
        \big(i_m + {1\over2} - \textbf{indexRange}(0,m)\big)\,\textbf{gridSpacing}(m) & \mbox{if \bf{}isCellCentered}(m) \\
        \big(i_m             - \textbf{indexRange}(0,m)\big)\,\textbf{gridSpacing}(m) & \mbox{otherwise},                \\
      \end{array} \right.
    \]
    $\textbf{dimension}(0,m) \le i_m \le \textbf{dimension}(1,m)$, and {\boldmath $g$} is the mapping that generates the grid.
    In particular, $\textbf{centerBoundaryNormal}(i,0)(i_0,i_1,i_2,0)=\pm(-1)^{i+1}$ if $\textbf{numberOfDimensions}()=1$.
    The upper sign is taken if the coordinate system is right-handed and the lower sign if it is left-handed;
    the sign taken is that of the jacobian of the mapping, $\det\Big[{\partial\mbox{\boldmath$g$} \over \partial\mbox{\boldmath$r$}}\Big]$
    at the center of the grid $r_0=r_1=r_2={1\over2}$.
    If \textbf{centerBoundaryNormal} is updated using a discrete approximation, then the derivatives are not computed using the mapping, but are
    instead computed by centered finite differences of \textbf{corner}, for the case of a cell-centered grid.  As a result, in two dimensions,
    \begin{eqnarray*}
      \textbf{centerBoundaryNormal}(i,0)(i_0,i_1,i_2,\ast) & = & \pm (-1)^{i+1} {\Delta_{+i_1} \textbf{corner}()(i_0,i_1,i_2,\ast) \over
                                                                              \big| \Delta_{+i_1} \textbf{corner}()(i_0,i_1,i_2,\ast) \big|}  \\
      \textbf{centerBoundaryNormal}(i,1)(i_0,i_1,i_2,\ast) & = & \mp (-1)^{i+1} {\Delta_{+i_0} \textbf{corner}()(i_0,i_1,i_2,\ast) \over
                                                                              \big| \Delta_{+i_0} \textbf{corner}()(i_0,i_1,i_2,\ast) \big|}. \\
    \end{eqnarray*}
    In three dimensions,
    \begin{eqnarray*}
      && \textbf{centerBoundaryNormal}(i,j)(i_0,i_1,i_2,\ast) \\
      && \qquad = \pm (-1)^{i+1}
            {\mu_{+i_l} \Delta_{+i_k}  \textbf{corner}(i_0,i_i,i_2,\ast) \times \mu_{+i_k} \Delta_{+i_l}  \textbf{corner}(i_0,i_i,i_2,\ast) \over
       \big| \mu_{+i_l} \Delta_{+i_k}  \textbf{corner}(i_0,i_i,i_2,\ast) \times \mu_{+i_k} \Delta_{+i_l}  \textbf{corner}(i_0,i_i,i_2,\ast) \big|}  \\
      && \qquad = \pm (-1)^{i+1}
            {\Delta_{\nearrow+i_k+i_l} \textbf{corner}(i_0,i_1,i_2,\ast) \times \Delta_{\nwarrow+i_l+i_k} \textbf{corner}(i_0,i_1,i_2,\ast) \over
       \big| \Delta_{\nearrow+i_k+i_l} \textbf{corner}(i_0,i_1,i_2,\ast) \times \Delta_{\nwarrow+i_l+i_k} \textbf{corner}(i_0,i_1,i_2,\ast) \big|}, \\
    \end{eqnarray*}
    where $k=(j+1)\bmod3$, $l=(j+2)\bmod3$,
    $\Delta_{\nearrow+i+j} u_{ij} \equiv u_{i+1,j+1}-u_{ij}$ and
    $\Delta_{\nwarrow+i+j} u_{ij} \equiv u_{i,j+1}-u_{i+1,j}$.
    If the grid is not cell-centered in the normal direction $j$, then the difference approximations are applied not to \textbf{corner} itself,
    but are applied instead to what \textbf{corner} would be, were the grid cell-centered in the the normal direction.
    {\em Warning:  In the case of a vertex-centered grid, \textbf{centerBoundaryNormal} is not computed by differencing \textbf{corner},
    but is equal to, and may be aliased to, {\bf{}\hyperref{vertexBoundaryNormal}{vertexBoundaryNormal \rm(\S}{)}{MappedGrid::vertexBoundaryNormal(k,l)}}.}
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEcenterBoundaryNormal}{THEcenterBoundaryNormal \rm(\S}{)}{MappedGrid::THEcenterBoundaryNormal}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{RealMappedGridFunction\& centerBoundaryTangent(const Integer\&~k, const Integer\&~l)}
  \label{MappedGrid::centerBoundaryTangent(k,l)}
    Dimensions of centerBoundaryTangent($k$,$l$): $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1,0\colon n_2)$,
    where \[d_{ij} = \left\{ \begin{array}{ll}
      \textbf{dimension}(k,j) & \mbox{if $j=l$}   \\
      \textbf{dimension}(i,j) & \mbox{otherwise,} \\
    \end{array} \right. \]
    $n_1 = \textbf{numberOfDimensions}() - 1$
    and $n_2 = \textbf{numberOfDimensions}() - 2$. \\*[\parskip]
    \textbf{centerBoundaryTangent} holds unit tangent vectors to the boundary surface at the discretization points of the boundary.
    Note that for a cell-centered grid, these points are not the cell-centers of boundary cells, but are the centers of the faces
    of boundary cells.  The tangents corresponding to the side of the grid where $r_j=i$ are given by
    \[
      \textbf{centerBoundaryTangent}(l,i)(i_0,i_1,i_2,\ast,j) =
      {{\partial \textbf{g} \over \partial r_k} \over
      \Big|{\partial \textbf{g} \over \partial r_k} \Big|},
      \quad\mbox{where $k=(i+j+1)\bmod{\bf{}numberOfDimensions}()$},
    \]
    \[
      r_m = \left\{ \begin{array}{rl}
        l                                                                                   & \mbox{if $m=i$, or else}         \\
        \big(i_m + {1\over2} - \textbf{indexRange}(0,m)\big)\,\textbf{gridSpacing}(m) & \mbox{if \bf{}isCellCentered}(m) \\
        \big(i_m             - \textbf{indexRange}(0,m)\big)\,\textbf{gridSpacing}(m) & \mbox{otherwise},                \\
      \end{array} \right.
    \]
    $\textbf{dimension}(0,m) \le i_m \le \textbf{dimension}(1,m)$, and {\boldmath $g$} is the mapping that generates the grid.
    If \textbf{centerBoundaryTangent} is updated using a discrete approximation, then the derivatives are not computed using the mapping, but are
    instead computed by centered finite differences of \textbf{corner}, for the case of a cell-centered grid.  As a result, in two dimensions,
    \[
      \textbf{centerBoundaryTangent}(*,i)(i_0,i_1,i_2,\ast,j) = {\Delta_{+i_k} \textbf{corner}(i_0,i_1,i_2,\ast) \over
                                                              \big| \Delta_{+i_k} \textbf{corner}(i_0,i_1,i_2,\ast) \big|},
    \]
    and in three dimensions,
    \[
      \textbf{centerBoundaryTangent}(*,i)(i_0,i_1,i_2,\ast,j) = {\mu_{+i_l} \Delta_{+k} \textbf{corner}(i_0,i_i,i_2,\ast) \over
                                                              \big| \mu_{+i_l} \Delta_{+k} \textbf{corner}(i_0,i_i,i_2,\ast) \big|},
    \]
    where $k=(i+j+1)\bmod3$ and $l=(k+1)\bmod3$.
    If the grid is not cell-centered in the normal direction $j$, then the difference approximations are applied not to \textbf{corner} itself,
    but are applied instead to what \textbf{corner} would be, were the grid cell-centered in the the normal direction.
    This geometric data may be updated as in the following example.
    See also {\bf{}\hyperref{THEcenterBoundaryTangent}{THEcenterBoundaryTangent \rm(\S}{)}{MappedGrid::THEcenterBoundaryTangent}}
    and {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{MappingRC\& mapping()}
  \label{MappedGrid::mapping()}
    \textbf{mapping}() is the reference-counted mapping that generates the grid.
    The mapping may be replaced as in the following example.
    See also {\bf{}\hyperref{reference(const Mapping\& x)}{reference(const Mapping\& x) \rm(\S}{)}{MappedGrid::reference(Mapping_x)}}
    and {\bf{}\hyperref{reference(const MappingRC\&~x)}{reference(const MappingRC\&~x) \rm(\S}{)}{MappedGrid::reference(MappingRC_x)}}.

  \subsubsection{const Box\& box() const}
  \label{MappedGrid::box()}
    Class \textbf{Box} comes from Boxlib, and is used for adaptive mesh refinement.
    This function returns a reference to a \textbf{Box} that describes this \textbf{MappedGrid}.

  \subsubsection{virtual aString getClassName() const}
  \label{MappedGrid::getClassName() const}
    Get the class name of the most-derived class for this object.
  \subsubsection{MappedGridData$*$ operator${-}{>}$()}
  \label{MappedGrid::operator->()}
    Access the reference-counted data.

  \subsubsection{MappedGridData\& operator$*$()}
  \label{MappedGrid::operator*()}
    Access the pointer to the reference-counted data.
\subsection{Public member functions called only from derived classes}
\label{MappedGrid::PublicDerivedClassMemberFunctions}

It is recommended that these functions be called only from derived classes.

  \subsubsection{void reference(MappedGridData\&~x)}
  \label{MappedGrid::reference(MappedGridData_x)}
    Make a reference to an object of type \textbf{MappedGridData}.
    This \textbf{MappedGrid} uses \textbf{x} for its data.
    It is recommended that this function be called only from derived classes.
  \subsubsection{void updateReferences(const Integer what~=~EVERYTHING)}
  \label{MappedGrid::updateReferences(what)}
    Update references to the reference-counted data.
    It is recommended that this function be called only from derived classes.
  \subsubsection{void setNumberOfDimensions(const Integer\&~numberOfDimensions\_)}
  \label{MappedGrid::setNumberOfDimensions(numberOfDimensions_)}
    This function is used to change the value of
    {\bf{}\hyperref{numberOfDimensions()}{numberOfDimensions() \rm(\S}{)}{MappedGrid::numberOfDimensions() const}}.
    If the new value is different from the old value, then all geometric data is destroyed.
    It is important to be sure that the setting of \textbf{numberOfDimensions()} should be
    consistent with the topology of the mapping that defines the geometry of the grid.

\subsection{Public data}
\label{MappedGrid::PublicData}

  \subsubsection{AMR\_ParentChildSiblingInfo$\ast$ parentChildSiblingInfo}
  \label{MappedGrid::parentChildSiblingInfo}
    This is used for adaptive mesh refinement.  Dan Quinlan++ has documentation for it.

\subsection{Public data used only by derived classes}
\label{MappedGrid::PublicDerivedClassData}

It is recommended that these variables be used only by derived classes.

  \subsubsection{MappedGridData$*$ rcData}
  \label{MappedGrid::rcData}
    \textbf{rcData} is a pointer to the reference-counted data.
    It is recommended that this variable be used only by derived classes.
    See also the member functions
    {\bf{}\hyperref{operator${-}{>}$()}{operator${-}{>}$() \rm(\S}{)}{MappedGrid::operator->()}}
    and {\bf{}\hyperref{operator$*$()}{operator$*$() \rm(\S}{)}{MappedGrid::operator*()}},
    which are provided for access to \textbf{rcData}.

  \subsubsection{Logical isCounted}
  \label{MappedGrid::isCounted}
    \textbf{isCounted} is
    a flag that indicates whether the data pointed to by {\bf{}\hyperref{rcData}{rcData \rm(\S}{)}{MappedGrid::rcData}} is known to be reference-counted.
    It is recommended that this variable be used only by derived classes.

\subsection{Public constants}
\label{MappedGrid::PublicConstants}

  \subsubsection{THEmask}
  \label{MappedGrid::THEmask}
    \textbf{THEmask} indicates the discretization point {\bf{}\hyperref{mask()}{mask() \rm(\S}{)}{MappedGrid::mask()}}.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEvertex}
  \label{MappedGrid::THEvertex}
    \textbf{THEvertex} indicates {\bf{}\hyperref{vertex()}{vertex() \rm(\S}{)}{MappedGrid::vertex()}},
    the locations of the vertices of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcenter}
  \label{MappedGrid::THEcenter}
    \textbf{THEcenter} indicates {\bf{}\hyperref{center()}{center() \rm(\S}{)}{MappedGrid::center()}},
    the locations of the discretization points of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcorner}
  \label{MappedGrid::THEcorner}
    \textbf{THEcorner} indicates {\bf{}\hyperref{corner()}{corner() \rm(\S}{)}{MappedGrid::corner()}},
    the locations of the discretization points of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEvertexDerivative}
  \label{MappedGrid::THEvertexDerivative}
    \textbf{THEvertexDerivative} indicates {\bf{}\hyperref{vertexDerivative()}{vertexDerivative() \rm(\S}{)}{MappedGrid::vertexDerivative()}},
    the derivative of the mapping at the vertices of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcenterDerivative}
  \label{MappedGrid::THEcenterDerivative}
    \textbf{THEcenterDerivative} indicates {\bf{}\hyperref{centerDerivative()}{centerDerivative() \rm(\S}{)}{MappedGrid::centerDerivative()}},
    the derivative of the mapping at the discretization points of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEinverseVertexDerivative}
  \label{MappedGrid::THEinverseVertexDerivative}
    \textbf{THEinverseVertexDerivative} indicates
    {\bf{}\hyperref{inverseVertexDerivative()}{inverseVertexDerivative() \rm(\S}{)}{MappedGrid::inverseVertexDerivative()}},
    the inverse of the mapping derivative, evaluated at the vertices of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEinverseCenterDerivative}
  \label{MappedGrid::THEinverseCenterDerivative}
    \textbf{THEinverseCenterDerivative} indicates
    {\bf{}\hyperref{inverseCenterDerivative()}{inverseCenterDerivative() \rm(\S}{)}{MappedGrid::inverseCenterDerivative()}},
    the inverse of the mapping derivative, evaluated at the discretization points of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEvertexJacobian}
  \label{MappedGrid::THEvertexJacobian}
    \textbf{THEvertexJacobian} indicates {\bf{}\hyperref{vertexJacobian()}{vertexJacobian() \rm(\S}{)}{MappedGrid::vertexJacobian()}},
    the determinant of the derivative of the mapping at the vertices of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcenterJacobian}
  \label{MappedGrid::THEcenterJacobian}
    \textbf{THEcenterJacobian} indicates {\bf{}\hyperref{centerJacobian()}{centerJacobian() \rm(\S}{)}{MappedGrid::centerJacobian()}},
    the determinant of the derivative of the mapping at the discretization points of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcellVolume}
  \label{MappedGrid::THEcellVolume}
    \textbf{THEcellVolume} indicates {\bf{}\hyperref{cellVolume()}{cellVolume() \rm(\S}{)}{MappedGrid::cellVolume()}},
    the area (in two dimensions) or volume (in three dimensions) of the grid cells.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEfaceNormal}
  \label{MappedGrid::THEfaceNormal}
    \textbf{THEfaceNormal} indicates {\bf{}\hyperref{faceNormal()}{faceNormal() \rm(\S}{)}{MappedGrid::faceNormal()}},
    the normals to the grid cell edges (in two dimensions) or faces (in three dimensions),
    normalized to the length or area area of the corresponding edge or face.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcenterNormal}
  \label{MappedGrid::THEcenterNormal}
    \textbf{THEcenterNormal} indicates {\bf{}\hyperref{centerNormal()}{centerNormal() \rm(\S}{)}{MappedGrid::centerNormal()}},
    the normals to constant parameter curves (in two dimensions) or surfaces (in three dimensions)
    passing through the grid cell centers, normalized
    to the length or area of that part of the curve or surface which lies inside the corresponding grid cell.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEfaceArea}
  \label{MappedGrid::THEfaceArea}
    \textbf{THEfaceArea} indicates {\bf{}\hyperref{faceArea()}{faceArea() \rm(\S}{)}{MappedGrid::faceArea()}},
    the length (in two dimensions) or area (in three dimensions) of the grid cell edges or faces.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcenterArea}
  \label{MappedGrid::THEcenterArea}
    \textbf{THEcenterArea} indicates {\bf{}\hyperref{centerArea()}{centerArea() \rm(\S}{)}{MappedGrid::centerArea()}},
    the length (in two dimensions) or area (in three dimensions) of the grid cell edges or faces.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEvertexBoundaryNormal}
  \label{MappedGrid::THEvertexBoundaryNormal}
    \textbf{THEvertexBoundaryNormal} indicates {\bf{}\hyperref{vertexBoundaryNormal}{vertexBoundaryNormal \rm(\S}{)}{MappedGrid::vertexBoundaryNormal(k,l)}},
    the unit outward normals to the grid boundary at the boundary vertices.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcenterBoundaryNormal}
  \label{MappedGrid::THEcenterBoundaryNormal}
    \textbf{THEcenterBoundaryNormal} indicates {\bf{}\hyperref{centerBoundaryNormal}{centerBoundaryNormal \rm(\S}{)}{MappedGrid::centerBoundaryNormal(k,l)}},
    the unit outward normals to the grid boundary at centers of the grid boundary cell
    edges (in two dimensions) or faces (in three dimensions).
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEcenterBoundaryTangent}
  \label{MappedGrid::THEcenterBoundaryTangent}
    \textbf{THEcenterBoundaryTangent} indicates {\bf{}\hyperref{centerBoundaryTangent}{centerBoundaryTangent \rm(\S}{)}{MappedGrid::centerBoundaryTangent(k,l)}},
    the unit tangent vectors to the grid boundary surface at centers of the grid boundary cell
    edges (in two dimensions) or faces (in three dimensions).
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEminMaxEdgeLength}
  \label{MappedGrid::THEminMaxEdgeLength}
    \textbf{THEminMaxEdgeLength} indicates {\bf{}\hyperref{minimumEdgeLength()}{minimumEdgeLength() \rm(\S}{)}{MappedGrid::minimumEdgeLength()}}
    and {\bf{}\hyperref{maximumEdgeLength()}{maximumEdgeLength() \rm(\S}{)}{MappedGrid::maximumEdgeLength()}},
    the minimum and maximum grid cell edge lengths.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEboundingBox}
  \label{MappedGrid::THEboundingBox}
    \textbf{THEboundingBox} indicates {\bf{}\hyperref{boundingBox()}{boundingBox() \rm(\S}{)}{MappedGrid::boundingBox()}},
    the coordinate bounds of a rectangular box that contains the vertices of the grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{THEusualSuspects}
  \label{MappedGrid::THEusualSuspects}
    \textbf{THEusualSuspects}
    =      {\bf{}\hyperref{GenericGrid::THEusualSuspects}{GenericGrid::THEusualSuspects \rm(\S}{)}{GenericGrid::THEusualSuspects}}
    $\mid$ {\bf{}\hyperref{THEmask}{THEmask \rm(\S}{)}{MappedGrid::THEmask}}
    $\mid$ {\bf{}\hyperref{THEvertex}{THEvertex \rm(\S}{)}{MappedGrid::THEvertex}}
    $\mid$ {\bf{}\hyperref{THEcenter}{THEcenter \rm(\S}{)}{MappedGrid::THEcenter}}
    $\mid$ {\bf{}\hyperref{THEvertexDerivative}{THEvertexDerivative \rm(\S}{)}{MappedGrid::THEvertexDerivative}} \\*[\parskip]
    \textbf{THEusualSuspects} indicates some of the geometric data of a \textbf{MappedGrid}.
    The particular data indicated by \textbf{THEusualSuspects} may change from time to time.
    For this reason the use of \textbf{THEusualSuspects} is not recommended.
    \textbf{THEusualSuspects} overloads
    {\bf{}\hyperref{GenericGrid::THEusualSuspects}{GenericGrid::THEusualSuspects \rm(\S}{)}{GenericGrid::THEusualSuspects}}.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{EVERYTHING}
  \label{MappedGrid::EVERYTHING}
    \textbf{EVERYTHING}
    =      {\bf{}\hyperref{GenericGrid::EVERYTHING}{GenericGrid::EVERYTHING \rm(\S}{)}{GenericGrid::EVERYTHING}}
    $\mid$ {\bf{}\hyperref{THEmask}{THEmask \rm(\S}{)}{MappedGrid::THEmask}}
    $\mid$ {\bf{}\hyperref{THEvertex}{THEvertex \rm(\S}{)}{MappedGrid::THEvertex}}
    $\mid$ {\bf{}\hyperref{THEcenter}{THEcenter \rm(\S}{)}{MappedGrid::THEcenter}}
    $\mid$ {\bf{}\hyperref{THEcorner}{THEcorner \rm(\S}{)}{MappedGrid::THEcorner}}
    $\mid$ {\bf{}\hyperref{THEvertexDerivative}{THEvertexDerivative \rm(\S}{)}{MappedGrid::THEvertexDerivative}}
    $\mid$ {\bf{}\hyperref{THEcenterDerivative}{THEcenterDerivative \rm(\S}{)}{MappedGrid::THEcenterDerivative}}
    $\mid$ {\bf{}\hyperref{THEinverseVertexDerivative}{THEinverseVertexDerivative \rm(\S}{)}{MappedGrid::THEinverseVertexDerivative}}
    $\mid$ {\bf{}\hyperref{THEinverseCenterDerivative}{THEinverseCenterDerivative \rm(\S}{)}{MappedGrid::THEinverseCenterDerivative}}
    $\mid$ {\bf{}\hyperref{THEvertexJacobian}{THEvertexJacobian \rm(\S}{)}{MappedGrid::THEvertexJacobian}}
    $\mid$ {\bf{}\hyperref{THEcenterJacobian}{THEcenterJacobian \rm(\S}{)}{MappedGrid::THEcenterJacobian}}
    $\mid$ {\bf{}\hyperref{THEcellVolume}{THEcellVolume \rm(\S}{)}{MappedGrid::THEcellVolume}}
    $\mid$ {\bf{}\hyperref{THEfaceNormal}{THEfaceNormal \rm(\S}{)}{MappedGrid::THEfaceNormal}}
    $\mid$ {\bf{}\hyperref{THEcenterNormal}{THEcenterNormal \rm(\S}{)}{MappedGrid::THEcenterNormal}}
    $\mid$ {\bf{}\hyperref{THEfaceArea}{THEfaceArea \rm(\S}{)}{MappedGrid::THEfaceArea}}
    $\mid$ {\bf{}\hyperref{THEcenterArea}{THEcenterArea \rm(\S}{)}{MappedGrid::THEcenterArea}}
    $\mid$ {\bf{}\hyperref{THEvertexBoundaryNormal}{THEvertexBoundaryNormal \rm(\S}{)}{MappedGrid::THEvertexBoundaryNormal}}
    $\mid$ {\bf{}\hyperref{THEcenterBoundaryNormal}{THEcenterBoundaryNormal \rm(\S}{)}{MappedGrid::THEcenterBoundaryNormal}}
    $\mid$ {\bf{}\hyperref{THEcenterBoundaryTangent}{THEcenterBoundaryTangent \rm(\S}{)}{MappedGrid::THEcenterBoundaryTangent}}
    $\mid$ {\bf{}\hyperref{THEminMaxEdgeLength}{THEminMaxEdgeLength \rm(\S}{)}{MappedGrid::THEminMaxEdgeLength}}
    $\mid$ {\bf{}\hyperref{THEboundingBox}{THEboundingBox \rm(\S}{)}{MappedGrid::THEboundingBox}} \\*[\parskip]
    \textbf{EVERYTHING} indicates all of the geometric data associated with a \textbf{MappedGrid}.
    \textbf{EVERYTHING} overloads
    {\bf{}\hyperref{GenericGrid::EVERYTHING}{GenericGrid::EVERYTHING \rm(\S}{)}{GenericGrid::EVERYTHING}}.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}.

  \subsubsection{USEdifferenceApproximation}
  \label{MappedGrid::USEdifferenceApproximation}
    \textbf{USEdifferenceApproximation} indicates that computation of all geometric data except for
    {\bf{}\hyperref{vertex()}{vertex() \rm(\S}{)}{MappedGrid::vertex()}}
    should be done using discrete approximations such as finite-difference approximations.
    By default, if a {\bf{}\hyperref{mapping}{mapping \rm(\S}{)}{MappedGrid::mapping()}} is available
    and is not of the base class ``\textbf{Mapping}'', then discrete approximations are not used.
    Instead, the mapping and its derivative are used to compute all of the geometric data.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{COMPUTEgeometry}
  \label{MappedGrid::COMPUTEgeometry}
    \textbf{COMPUTEgeometry} indicates that geometric data should be computed for each variable indicated,
    even if that data had already been computed and marked valid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{COMPUTEgeometryAsNeeded}
  \label{MappedGrid::COMPUTEgeometryAsNeeded}
    \textbf{COMPUTEgeometryAsNeeded} indicates that geometric data should be computed only for those variables indicated,
    which either had not already been computed, were marked invalid, or for which
    new space needed to be allocated.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{COMPUTEtheUsual}
  \label{MappedGrid::COMPUTEtheUsual}
    \textbf{COMPUTEtheUsual}
    =       {\bf{}\hyperref{GenericGrid::COMPUTEtheUsual}{GenericGrid::COMPUTEtheUsual \rm(\S}{)}{GenericGrid::COMPUTEtheUsual}}
    $\mid$  {\bf{}\hyperref{COMPUTEgeometryAsNeeded}{COMPUTEgeometryAsNeeded \rm(\S}{)}{MappedGrid::COMPUTEgeometryAsNeeded}} \\*[\parskip]
    \textbf{COMPUTEtheUsual} indicates that computation of geometric data should proceed in the ``usual way.''
    Currently this means that geometric data is computed only for those variables indicated,
    which had not already been computed.  However, this may change from time to time.
    \textbf{COMPUTEtheUsual} overloads
    {\bf{}\hyperref{GenericGrid::COMPUTEtheUsual}{GenericGrid::COMPUTEtheUsual \rm(\S}{)}{GenericGrid::COMPUTEtheUsual}}.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}.

  \subsubsection{ISdiscretizationPoint}
  \label{MappedGrid::ISdiscretizationPoint}
    \textbf{ISdiscretizationPoint} indicates that a point is a discretization point.

  \subsubsection{ISinterpolationPoint}
  \label{MappedGrid::ISinterpolationPoint}
    \textbf{ISinterpolationPoint} indicates that a point is an interpolation point.

  \subsubsection{ISghostPoint}
  \label{MappedGrid::ISghostPoint}
    \textbf{ISghostPoint} indicates a point outside the boundary, whose nearest boundary point is either a discretization point or an interpolation point.

  \subsubsection{ISinteriorBoundaryPoint}
  \label{MappedGrid::ISinteriorBoundaryPoint}
    \textbf{ISinteriorBoundaryPoint} indicates that a point is a boundary point that lies in the interior of another grid,
    and should therefore not be used for the discretization of a boundary condition.

  \subsubsection{USESbackupRules}
  \label{MappedGrid::USESbackupRules}
    \textbf{USESbackupRules} indicates that a point uses backup rules for discretization or interpolation.

  \subsubsection{IShiddenByRefinement}
  \label{MappedGrid::IShiddenByRefinement}
    \textbf{IShiddenByRefinement} indicates that a point is hidden by an overlying refinement grid.

  \subsubsection{ISreservedBit0}
  \label{MappedGrid::ISreservedBit0}
     This constant should be used only by grid-generation programs.

  \subsubsection{ISreservedBit1}
  \label{MappedGrid::ISreservedBit1}
     This constant should be used only by grid-generation programs.

  \subsubsection{ISreservedBit2}
  \label{MappedGrid::ISreservedBit2}
     This constant should be used only by grid-generation programs.

  \subsubsection{GRIDnumberBits}
  \label{MappedGrid::GRIDnumberBits}
     This constant should be used only by grid-generation programs.

  \subsubsection{ISusedPoint}
  \label{MappedGrid::ISusedPoint}
    \textbf{ISusedPoint}
    =      {\bf{}\hyperref{ISdiscretizationPoint}{ISdiscretizationPoint \rm(\S}{)}{MappedGrid::ISdiscretizationPoint}}
    $\mid$ {\bf{}\hyperref{ISinterpolationPoint}{ISinterpolationPoint \rm(\S}{)}{MappedGrid::ISinterpolationPoint}}
    $\mid$ {\bf{}\hyperref{ISghostPoint}{ISghostPoint \rm(\S}{)}{MappedGrid::ISghostPoint}}


\section{Class GenericGridCollection} \index{GenericGridCollection}
\label{GenericGridCollection}

Class \textbf{GenericGridCollection} is the base class for all Overture classes that contain collections of grids.
It contains a list of \textbf{GenericGrid}s.  Each of the grids in this list may be considered to belong to a ``base grid,''
which may have ``refinement'' grids at various levels of refinement.  There may be more than one base grid, in which case the
collection of grids may be partitioned into disjoint subsets of grids that belong to the various unrefined base grids.
Class \textbf{GenericGridCollection} contains a list of \textbf{GenericGridCollection}s that may hold
the subsets of grids that form this partition.  It also contains a list of \textbf{GenericGridCollection}s that may hold
the subsets of grids that have in common their level of refinement with respect to their base grids.  This list forms a partition
of the collection of grids into disjoint subsets according to refinement level.  Each base grid or refinement may have more than
one multigrid level.  We call the finest multigrid level of any grid a ``componenent grid,'' and the coarser multigrid levels of
each component grid we call ``multigrid coarsenings.'' There may be more than one component grid, in which case the
collection of grids may be partitioned into disjoint subsets of grids that belong to the various component grids.
Class \textbf{GenericGridCollection} contains a list of \textbf{GenericGridCollection}s that may hold
the subsets of grids that form this partition.  It also contains a list of \textbf{GenericGridCollection}s that may hold
the subsets of grids that have in common their level of multigrid coarsening with respect to their finest-level component grids.
This list forms a partition of the collection of grids into disjoint subsets according to multigrid level.
To summarize, the collection of grids may be partitioned according to base grid or refinement level, and these two partitions
are dual to each other; similarly, the collection may be partitioned according to component grid or multigrid level, and these
two partitions also are dual to each other.  Since the lists forming the subsets in any of these four partitions are also
\textbf{GenericGridCollection}s, they may be further partitioned in exactly the same way.  For example, it is possible in
this way to form a list of all the refinements of a particular base grid at a given multigrid level.

\subsection{Public member functions}
\label{GenericGridCollection::PublicMemberFunctions}

  \subsubsection{GenericGridCollection(const Integer numberOfGrids\_~=~0)}
  \label{GenericGridCollection::GenericGridCollection(numberOfGrids_)}
    Default constructor.
    If \textbf{numberOfGrids\_}=0 ({\sl{}e.g.}, by default) then create a null \textbf{GenericGridCollection}.
    Otherwise, create a \textbf{GenericGridCollection} with the given number of grids.

  \subsubsection{GenericGridCollection(const GenericGridCollection\&~x, const CopyType ct~=~DEEP)}
  \label{GenericGridCollection::GenericGridCollection(x,ct)}
    Copy constructor.
    This does a deep copy by default.
    See also {\bf{}\hyperref{operator=(x)}{operator=(x) \rm(\S}{)}{GenericGridCollection::operator=(x)}}
    and {\bf{}\hyperref{reference(x)}{reference(x) \rm(\S}{)}{GenericGridCollection::reference(x)}}.

  \subsubsection{virtual $\sim$GenericGridCollection()}
  \label{GenericGridCollection::tilde_GenericGridCollection()}
    Destructor.

  \subsubsection{GenericGridCollection\& operator=(const GenericGridCollection\&~x)}
  \label{GenericGridCollection::operator=(x)}
    Assignment operator.
    This is also called a deep copy.
  \subsubsection{void reference(const GenericGridCollection\&~x)}
  \label{GenericGridCollection::reference(x)}
    Make a reference.  This is also called a shallow copy.  This \textbf{GenericGridCollection} shares the data of \textbf{x}.
  \subsubsection{virtual void breakReference()}
  \label{GenericGridCollection::breakReference()}
    Break a reference.  If this \textbf{GenericGridCollection} shares data with any other \textbf{GenericGridCollection},
    then this function replaces it with a new copy that does not share data.

  \subsubsection{virtual void consistencyCheck() const}
  \label{GenericGridCollection::consistencyCheck() const}
    Check the consistency of this \textbf{GenericGridCollection}.

  \subsubsection{virtual Integer get(const GenericDataBase\&~dir, const aString\&~name)}
  \label{GenericGridCollection::get(dir,name)}
    Copy a \textbf{GenericGridCollection} from a file.

  \subsubsection{virtual Integer put(GenericDataBase\&~dir, const aString\&~name) const}
  \label{GenericGridCollection::put(dir,name) const}
    Copy a \textbf{GenericGridCollection} into a file.

  \subsubsection{Integer update(const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{GenericGridCollection::update(what,how)}
    Update geometric data.
    The first argument (\textbf{what}) indicates which geometric data are to be updated.  Any combination of the constants
    {\bf{}\hyperref{THEbaseGrid}{THEbaseGrid \rm(\S}{)}{GenericGridCollection::THEbaseGrid}},
    {\bf{}\hyperref{THErefinementLevel}{THErefinementLevel \rm(\S}{)}{GenericGridCollection::THErefinementLevel}},
    {\bf{}\hyperref{THEcomponentGrid}{THEcomponentGrid \rm(\S}{)}{GenericGridCollection::THEcomponentGrid}},
    {\bf{}\hyperref{THEmultigridLevel}{THEmultigridLevel \rm(\S}{)}{GenericGridCollection::THEmultigridLevel}},
    {\bf{}\hyperref{NOTHING}{NOTHING \rm(\S}{)}{GenericGridCollection::NOTHING}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{GenericGridCollection::THEusualSuspects}},
    {\bf{}\hyperref{THElists}{THElists \rm(\S}{)}{GenericGridCollection::THElists}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{GenericGridCollection::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGrid::update(what,how)}{GenericGrid::update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}},
    may be bitwise ORed together to form the first argument of \textbf{update}(),
    to indicate which geometric data should be updated.
    This function returns a value obtained by bitwise ORing some of these constants,
    to indicate for which of the optional geometric data new array space was allocated.
    In addition, the constant
    {\bf{}\hyperref{COMPUTEfailed}{COMPUTEfailed \rm(\S}{)}{GenericGridCollection::COMPUTEfailed}},
    may be bitwise ORed into the value returned by \textbf{update}() in order to indicate
    that the computation of some geometric data failed.  The second argument (\textbf{how})
    indicates whether and how any computation of geometric data should be done.
    Any combination of the constants
    {\bf{}\hyperref{COMPUTEnothing}{COMPUTEnothing \rm(\S}{)}{GenericGridCollection::COMPUTEnothing}},
    {\bf{}\hyperref{COMPUTEtheUsual}{COMPUTEtheUsual \rm(\S}{)}{GenericGridCollection::COMPUTEtheUsual}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGrid::update(what,how)}{GenericGrid::update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}},
    may be bitwise ORed together to form the optional second argument of \textbf{update}().
    The corresponding function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGrid::update(what,how)}}
    is called with the same arguments for each grid in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

  \subsubsection{virtual Integer update(GenericGridCollection\&~x, const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{GenericGridCollection::update(x,what,how)}
    Update geometric data, sharing space with the optional geometric data of another grid (\textbf{x}).
    If space for any indicated optional geometric data has not yet been allocated, or has
    the wrong dimensions, but \textbf{x} does contain the corresponding data, then the data
    for this \textbf{GenericGridCollection} will share space with the corresponding data of \textbf{x}.
    Any geometric data that already exists and has the correct dimensions
    is not forced to share space with the corresponding data of \textbf{x}.
    The corresponding function
    {\bf{}\hyperref{update(x,what,how)}{update(x,what,how) \rm(\S}{)}{GenericGrid::update(x,what,how)}}
    is called with the same arguments for each grid in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.
    For the optional arguments \textbf{what} and \textbf{how}, see the description of the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}.

  \subsubsection{void destroy(const Integer what~=~NOTHING)}
  \label{GenericGridCollection::destroy(what)}
    Destroy the indicated optional geometric grid data.
    The argument (\textbf{what}) indicates which optional
    geometric data are to be destroyed.  Any combination of the constants
    {\bf{}\hyperref{THEbaseGrid}{THEbaseGrid \rm(\S}{)}{GenericGridCollection::THEbaseGrid}},
    {\bf{}\hyperref{THErefinementLevel}{THErefinementLevel \rm(\S}{)}{GenericGridCollection::THErefinementLevel}},
    {\bf{}\hyperref{THEcomponentGrid}{THEcomponentGrid \rm(\S}{)}{GenericGridCollection::THEcomponentGrid}},
    {\bf{}\hyperref{THEmultigridLevel}{THEmultigridLevel \rm(\S}{)}{GenericGridCollection::THEmultigridLevel}},
    {\bf{}\hyperref{NOTHING}{NOTHING \rm(\S}{)}{GenericGridCollection::NOTHING}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{GenericGridCollection::THEusualSuspects}},
    {\bf{}\hyperref{THElists}{THElists \rm(\S}{)}{GenericGridCollection::THElists}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{GenericGridCollection::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGrid::destroy(what)}{GenericGrid::destroy(what) \rm(\S}{)}{GenericGrid::destroy(what)}},
    may be bitwise ORed together to form the optional argument \textbf{what}.
    The corresponding function
    {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGrid::destroy(what)}}
    is called with the same argument for each grid in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

  \subsubsection{void geometryHasChanged(const Integer what~=~$\sim$NOTHING)}
  \label{GenericGridCollection::geometryHasChanged(what)}
    Mark the geometric data out-of-date.
    Any combination of the constants
    {\bf{}\hyperref{THEbaseGrid}{THEbaseGrid \rm(\S}{)}{GenericGridCollection::THEbaseGrid}},
    {\bf{}\hyperref{THErefinementLevel}{THErefinementLevel \rm(\S}{)}{GenericGridCollection::THErefinementLevel}},
    {\bf{}\hyperref{THEcomponentGrid}{THEcomponentGrid \rm(\S}{)}{GenericGridCollection::THEcomponentGrid}},
    {\bf{}\hyperref{THEmultigridLevel}{THEmultigridLevel \rm(\S}{)}{GenericGridCollection::THEmultigridLevel}},
    {\bf{}\hyperref{NOTHING}{NOTHING \rm(\S}{)}{GenericGridCollection::NOTHING}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{GenericGridCollection::THEusualSuspects}},
    {\bf{}\hyperref{THElists}{THElists \rm(\S}{)}{GenericGridCollection::THElists}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{GenericGridCollection::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGrid::geometryHasChanged(what)}{GenericGrid::geometryHasChanged(what) \rm(\S}{)}{GenericGrid::geometryHasChanged(what)}},
    may be bitwise ORed together to form the first argument of \textbf{geometryHasChanged}().
    By default, all geometric data of this \textbf{GenericGridCollection} and all derived classes is
    marked out-of-date.  The corresponding function
    {\bf{}\hyperref{geometryHasChanged(what)}{geometryHasChanged(what) \rm(\S}{)}{GenericGrid::geometryHasChanged(what)}}
    is called with the same argument for each grid in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.
    It is recommended that this function be called only from derived classes and
    grid-generation programs.

  \subsubsection{virtual Integer addRefinement(const Integer\&~level, const Integer k~=~0)}
  \label{GenericGridCollection::addRefinement(level,k)}
    Add a refinement grid to this collection.  This refinement grid is marked as belonging to refinement level \textbf{level}.
    It is marked as belonging to the same base grid as that of \textbf{grid}[\textbf{k}], which may be any sibling, parent,
    or other more remote ancestor.  It is required that $\textbf{level}>0$.  There must already exist grids marked as belonging
    to refinement level $\textbf{level}-1$.  This function returns the index of the refinement grid.

  \subsubsection{virtual void deleteRefinement(const Integer\&~k)}
  \label{GenericGridCollection::deleteRefinement(k)}
    Delete all multigrid levels of refinement grid \textbf{k}.

  \subsubsection{virtual void deleteRefinementLevels(const Integer level~=~0)}
  \label{GenericGridCollection::deleteRefinementLevels(level)}
    Delete all grids in this collection marked as belonging to refinement levels greater than \textbf{level}.
    It is required that $\textbf{level}\ge0$.

  \subsubsection{virtual void referenceRefinementLevels(GenericGridCollection\&~x, 
     Integer level~=~INTEGER\_MAX)}
  \label{GenericGridCollection::referenceRefinementLevels(x,level)}
    Make this collection contain exactly those grids from the collection \textbf{x} which are marked in \textbf{x}
    as belonging to refinement level \textbf{level} or to any coarser refinent level.  It is required that
    $\textbf{level}\ge0$.

  \subsubsection{virtual Integer addMultigridCoarsening(const Integer\&~level, const Integer k~=~0)}
  \label{GenericGridCollection::addMultigridCoarsening(level,k)}
    Add a multigrid coarsening of a grid to this collection.  This coarsening is marked as belonging to multigrid level \textbf{level}.
    It is marked as belonging to the same component grid as that of \textbf{grid}[\textbf{k}], which may be any finer multigrid level
    of the same component grid.  It is required that $\textbf{level}>0$.
    There must already exist a multigrid coarsening of the component grid at multigrid level $\textbf{level}-1$.
    This function returns the index of the multigrid coarsening.

  \subsubsection{virtual void deleteMultigridCoarsening(const Integer\&~k)}
  \label{GenericGridCollection::deleteMultigridCoarsening(k)}
    Delete grid \textbf{k},a multigrid coarsening, and all of its coarser multigrid levels.

  \subsubsection{virtual void deleteMultigridLevels(const Integer level~=~0)}
  \label{GenericGridCollection::deleteMultigridLevels(level)}
    Delete all grids in this collection marked as belonging to multigrid levels greater than \textbf{level}.
    It is required that $\textbf{level}\ge0$.

  \subsubsection{virtual void initialize(const Integer\&~numberOfGrids\_)}
  \label{GenericGridCollection::initialize(numberOfGrids_)}
    Initialize the GenericGridCollection with the given number of grids.
    These grids have their gridNumbers, baseGridNumbers and componentGridNumbers
    set to $[0,\dots,\mbox{numberOfGrids\_}-1]$, and their refinementLevelNumbers and
    multigridLevelNumbers set to zero.

  \subsubsection{Logical operator==(const GenericGridCollection\&~x) const}
  \label{GenericGridCollection::operator==(x) const}
    This comparison function returns \textbf{LogicalTrue} (non-zero) if and only if \textbf{x} refers the same grid as \textbf{$\ast$this}.

  \subsubsection{Logical operator!=(const GenericGridCollection\&~x) const}
  \label{GenericGridCollection::operator!=(x) const}
    This comparison function returns \textbf{LogicalTrue} or (non-zero) if and only if \textbf{x} does not refer to the same grid as \textbf{$\ast$this}.

  \subsubsection{Integer getIndex(const GenericGrid\&~x) const}
  \label{GenericGridCollection::getIndex(x) const}
    This function returns the index of grid \textbf{x} in \textbf{$\ast$this}, or returns $-1$ if \textbf{x} is not in \textbf{$\ast$this}.

\subsection{Public Member functions for access to data}
\label{GenericGridCollection::PublicAccessToData}

  \subsubsection{const Integer\& computedGeometry() const}
  \label{GenericGridCollection::computedGeometry() const}
    This function returns a reference to a bit mask that indicates which geometrical data has been computed.
    This mask must be reset to zero to invalidate the data when the geometry changes.
    It is recommended that this data be used only by derived classes
    and grid-generation programs.
    See also {\bf{}\hyperref{geometryHasChanged(what)}{geometryHasChanged(what) \rm(\S}{)}{GenericGridCollection::geometryHasChanged(what)}}.

  \subsubsection{const Integer\& numberOfGrids() const}
  \label{GenericGridCollection::numberOfGrids() const}
    This function returns a reference to the number of grids in the list {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

  \subsubsection{const Integer\& numberOfBaseGrids() const}
  \label{GenericGridCollection::numberOfBaseGrids() const}
    This function returns a reference to the number of \textbf{GenericGridCollection}s in
    the list {\bf{}\hyperref{baseGrid}{baseGrid \rm(\S}{)}{GenericGridCollection::baseGrid}}.

  \subsubsection{const Integer\& numberOfRefinementLevels() const}
  \label{GenericGridCollection::numberOfRefinementLevels() const}
    This function returns a reference to the number of \textbf{GenericGridCollection}s in the list
    {\bf{}\hyperref{refinementLevel}{refinementLevel \rm(\S}{)}{GenericGridCollection::refinementLevel}}.

  \subsubsection{const Integer\& numberOfComponentGrids() const}
  \label{GenericGridCollection::numberOfComponentGrids() const}
    This function returns a reference to the number of \textbf{GenericGridCollection}s in the list
    {\bf{}\hyperref{multigridLevel}{multigridLevel \rm(\S}{)}{GenericGridCollection::multigridLevel}}.

  \subsubsection{const Integer\& numberOfMultigridLevels() const}
  \label{GenericGridCollection::numberOfMultigridLevels() const}
    This function returns a reference to the number of \textbf{GenericGridCollection}s in the list
    {\bf{}\hyperref{multigridLevel}{multigridLevel \rm(\S}{)}{GenericGridCollection::multigridLevel}}.

  \subsubsection{GenericGrid\& operator[](const int\&~i)}
  \label{GenericGridCollection::operator[](i)}
    Get a reference to the $i$th grid.
    If \textbf{g} is a \textbf{GenericGridCollection}, then $\textbf{g}[i]$
    is a reference to the \textbf{GenericGrid} $\textbf{g}.\textbf{grid}[i]$.

  \subsubsection{virtual aString getClassName() const}
  \label{GenericGridCollection::getClassName() const}
    Get the class name of the most-derived class for this object.

  \subsubsection{GenericGridCollectionData$*$ operator${-}{>}$()}
  \label{GenericGridCollection::operator->()}
    Access the reference-counted data.

  \subsubsection{GenericGridCollectionData\& operator$*$()}
  \label{GenericGridCollection::operator*()}
    Access the pointer to the reference-counted data.

\subsection{Public member functions called only from derived classes}
\label{GenericGridCollection::PublicDerivedClassMemberFunctions}

It is recommended that these functions be called only from derived classes.

  \subsubsection{void reference(GenericGridCollectionData\&~x)}
  \label{MappedGrid::reference(GenericGridCollectionData_x)}
    Make a reference to an object of type \textbf{GenericGridCollectionData}.
    This \textbf{GenericGridCollection} uses \textbf{x} for its data.
    It is recommended that this function be called only from derived classes.

  \subsubsection{void updateReferences(const Integer what~=~EVERYTHING)}
  \label{GenericGridCollection::updateReferences(what)}
    Update references to the reference-counted data.
    It is recommended that this function be called only from derived classes.

  \subsubsection{virtual void setNumberOfGrids(const Integer\&~numberOfGrids\_)}
  \label{GenericGridCollection::setNumberOfGrids(numberOfGrids_)}
    Add or delete grids to/from this collection until there are \textbf{numberOfGrids\_} grids.
    Any grids added are marked as belonging to base grid zero, multigrid level zero and refinement level zero.
    The use of this function is not recommended if the collection is intended to contain more than one
    base grid, refinement level, component grid or multigrid level.
    For example, if the collection is intended to contain more than one refinement level, it is recommended that the functions
    {\bf{}\hyperref{addRefinement(level,k)}{addRefinement(level,k) \rm(\S}{)}{GenericGridCollection::addRefinement(level,k)}} and
    {\bf{}\hyperref{deleteRefinementLevels(level)}{deleteRefinementLevels(level) \rm(\S}{)}{GenericGridCollection::deleteRefinementLevels(level)}}
    be used instead.

\subsection{Public data}
\label{GenericGridCollection::PublicData}

  \subsubsection{ListOfGenericGrid grid}
  \label{GenericGridCollection::grid}
    Length: {\bf{}\hyperref{numberOfGrids()}{numberOfGrids() \rm(\S}{)}{GenericGridCollection::numberOfGrids() const}} \\*[\parskip]
    A list containing of all of the grids in the collection. The grids in this list are \textbf{GenericGrid}s.

  \subsubsection{const IntegerArray gridNumber}
  \label{GenericGridCollection::gridNumber}
    Dimensions: $(0\colon n_1)$, where $n_1 = \textbf{numberOfGrids}() - 1$. \\*[\parskip]
    The index of the each \textbf{GenericGrid} in the list {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

  \subsubsection{ListOfGenericGridCollection baseGrid}
  \label{GenericGridCollection::baseGrid}
    \textbf{baseGrid} is
    a list of \textbf{GenericGridCollection}s containing one base grid and all of its refinements, including all multigrid coarsenings of these grids.
    This data may be updated as in the following example.

  \subsubsection{const IntegerArray baseGridNumber}
  \label{GenericGridCollection::baseGridNumber}
    Dimensions: $(0\colon n_1)$, where $n_1 = \textbf{numberOfGrids}() - 1$. \\*[\parskip]
    \textbf{baseGridNumber} holds the index of the base grid ancestor of each \textbf{GenericGrid} in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

  \subsubsection{ListOfGenericGridCollection refinementLevel}
  \label{GenericGridCollection::refinementLevel}
    \textbf{refinementLevel} is a list of \textbf{GenericGridCollection}s containing \textbf{GenericGrid}s that belong to the same refinement level.
    This data may be updated as in the following example.

  \subsubsection{const IntegerArray refinementLevelNumber}
  \label{GenericGridCollection::refinementLevelNumber}
    Dimensions: $(0\colon n_1)$, where $n_1 = \textbf{numberOfGrids}() - 1$. \\*[\parskip]
    \textbf{refinementLevelNumber} holds the index of the refinement level of each \textbf{GenericGrid} in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

  \subsubsection{ListOfGenericGridCollection componentGrid}
  \label{GenericGridCollection::componentGrid}
    \textbf{componentGrid} is a list of \textbf{GenericGridCollection}s containing one componenent grid and all of its multigrid coarsenings.
    This data may be updated as in the following example.

  \subsubsection{const IntegerArray componentGridNumber}
  \label{GenericGridCollection::componentGridNumber}
    Dimensions: $(0\colon n_1)$, where $n_1 = \textbf{numberOfGrids}() - 1$. \\*[\parskip]
    \textbf{componentGridNumber} holds the index of the component grid of each \textbf{GenericGrid} in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

  \subsubsection{ListOfGenericGridCollection multigridLevel}
  \label{GenericGridCollection::multigridLevel}
    \textbf{multigridLevel} is a list of \textbf{GenericGridCollection}s containing \textbf{GenericGrid}s that belong to the same multigrid level.
    This data may be updated as in the following example.

  \subsubsection{const IntegerArray multigridLevelNumber}
  \label{GenericGridCollection::multigridLevelNumber}
    Dimensions: $(0\colon n_1)$, where $n_1 = \textbf{numberOfGrids}() - 1$. \\*[\parskip]
    \textbf{multigridLevelNumber} holds the index of the multigrid level of each \textbf{GenericGrid} in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

\subsection{Public data used only by derived classes}
\label{GenericGridCollection::PublicDerivedClassData}

It is recommended that these variables be used only by derived classes.

  \subsubsection{GenericGridCollectionData$*$ rcData}
  \label{GenericGridCollection::rcData}
    \textbf{rcData} is a pointer to the reference-counted data.
    It is recommended that this variable be used only by derived classes.
    See also the member functions
    {\bf{}\hyperref{operator${-}{>}$()}{operator${-}{>}$() \rm(\S}{)}{GenericGridCollection::operator->()}}
    and {\bf{}\hyperref{operator$*$()}{operator$*$() \rm(\S}{)}{GenericGridCollection::operator*()}},
    which are provided for access to \textbf{rcData}.

  \subsubsection{Logical isCounted}
  \label{GenericGridCollection::isCounted}
    \textbf{isCounted} is
    a flag that indicates whether the data pointed to by {\bf{}\hyperref{rcData}{rcData \rm(\S}{)}{GenericGridCollection::rcData}}
    is known to be reference-counted.
    It is recommended that this variable be used only by derived classes.

\subsection{Public constants}
\label{GenericGridCollection::PublicConstants}

  \subsubsection{THEbaseGrid}
  \label{GenericGridCollection::THEbaseGrid}
    \textbf{THEbaseGrid} indicates {\bf{}\hyperref{baseGrid}{baseGrid \rm(\S}{)}{GenericGridCollection::baseGrid}},
    the list of \textbf{GenericGridCollection}s containing those \textbf{GenericGrid}s which are descended from the same base grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{THErefinementLevel}
  \label{GenericGridCollection::THErefinementLevel}
    \textbf{THErefinementLevel} indicates {\bf{}\hyperref{refinementLevel}{refinementLevel \rm(\S}{)}{GenericGridCollection::refinementLevel}},
    the list of \textbf{GenericGridCollection}s containing those \textbf{GenericGrid}s which belong to the same refinement level.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{THEcomponentGrid}
  \label{GenericGridCollection::THEcomponentGrid}
    \textbf{THEcomponentGrid} indicates {\bf{}\hyperref{componentGrid}{multigridLevel \rm(\S}{)}{GenericGridCollection::componentGrid}},
    the list of \textbf{GenericGridCollection}s containing those \textbf{GenericGrid}s which belong to the same component grid.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{THEmultigridLevel}
  \label{GenericGridCollection::THEmultigridLevel}
    \textbf{THEmultigridLevel} indicates {\bf{}\hyperref{multigridLevel}{multigridLevel \rm(\S}{)}{GenericGridCollection::multigridLevel}},
    the list of \textbf{GenericGridCollection}s containing those \textbf{GenericGrid}s which belong to the same multigrid level.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{NOTHING}
  \label{GenericGridCollection::NOTHING}
    \textbf{NOTHING} = {\bf{}\hyperref{GenericGrid::NOTHING}{GenericGrid::NOTHING \rm(\S}{)}{GenericGrid::NOTHING}}
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{THEusualSuspects}
  \label{GenericGridCollection::THEusualSuspects}
    \textbf{THEusualSuspects} =
    {\bf{}\hyperref{GenericGrid::THEusualSuspects}{GenericGrid::THEusualSuspects \rm(\S}{)}{GenericGrid::THEusualSuspects}} \\*[\parskip]
    \textbf{THEusualSuspects} indicates some of the geometric data of a \textbf{GenericGridCollection}.
    The particular data indicated by \textbf{THEusualSuspects} may change from time to time.
    For this reason the use of \textbf{THEusualSuspects} is not recommended.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{THElists}
  \label{GenericGridCollection::THElists}
    \textbf{THElists}
    =      {\bf{}\hyperref{THEbaseGrid}{THEbaseGrid \rm(\S}{)}{GenericGridCollection::THEbaseGrid}}
    $\mid$ {\bf{}\hyperref{THErefinementLevel}{THErefinementLevel \rm(\S}{)}{GenericGridCollection::THErefinementLevel}}
    $\mid$ {\bf{}\hyperref{THEcomponentGrid}{THEcomponentGrid \rm(\S}{)}{GenericGridCollection::THEcomponentGrid}}
    $\mid$ {\bf{}\hyperref{THEmultigridLevel}{THEmultigridLevel \rm(\S}{)}{GenericGridCollection::THEmultigridLevel}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{EVERYTHING}
  \label{GenericGridCollection::EVERYTHING}
    \textbf{EVERYTHING}
    =      {\bf{}\hyperref{GenericGrid::EVERYTHING}{GenericGrid::EVERYTHING \rm(\S}{)}{GenericGrid::EVERYTHING}}
    $\mid$ {\bf{}\hyperref{THEbaseGrid}{THEbaseGrid \rm(\S}{)}{GenericGridCollection::THEbaseGrid}}
    $\mid$ {\bf{}\hyperref{THEmultigridLevel}{THEmultigridLevel \rm(\S}{)}{GenericGridCollection::THEmultigridLevel}}
    $\mid$ {\bf{}\hyperref{THErefinementLevel}{THErefinementLevel \rm(\S}{)}{GenericGridCollection::THErefinementLevel}} \\*[\parskip]
    \textbf{EVERYTHING} indicates all of the geometric data associated with a \textbf{GenericGridCollection}.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{COMPUTEnothing}
  \label{GenericGridCollection::COMPUTEnothing}
    \textbf{COMPUTEnothing} = 
    {\bf{}\hyperref{GenericGrid::COMPUTEnothing}{GenericGrid::COMPUTEnothing \rm(\S}{)}{GenericGrid::COMPUTEnothing}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{COMPUTEtheUsual}
  \label{GenericGridCollection::COMPUTEtheUsual}
    \textbf{COMPUTEtheUsual} =
    {\bf{}\hyperref{GenericGrid::COMPUTEtheUsual}{GenericGrid::COMPUTEtheUsual \rm(\S}{)}{GenericGrid::COMPUTEtheUsual}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

  \subsubsection{COMPUTEfailed}
  \label{GenericGridCollection::COMPUTEfailed}
    \textbf{COMPUTEfailed} =
    {\bf{}\hyperref{GenericGrid::COMPUTEfailed}{GenericGrid::COMPUTEfailed \rm(\S}{)}{GenericGrid::COMPUTEfailed}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}.

\section{Class GridCollection} \index{GridCollection}
\label{GridCollection}

Class \textbf{GridCollection} is the base class for all Overture classes that contain collections of \textbf{MappedGrid}s.
It is derived from class \textbf{GenericGridCollection}.

\subsection{Public member functions}
\label{GridCollection::PublicMemberFunctions}

  \subsubsection{GridCollection(const Integer numberOfDimensions\_~=~0, const Integer numberOfGrids\_~=~0)}
  \label{GridCollection(numberOfDimensions_,numberOfGrids_)}
    Default constructor.
    If numberOfDimensions\_==0 ({\sl{}e.g.}, by default) then create a null \textbf{GridCollection}.
    Otherwise, create a \textbf{GridCollection} with the given number of dimensions and number of grids.

  \subsubsection{GridCollection(const GridCollection\&~x, const CopyType ct~=~DEEP)}
  \label{GridCollection::GridCollection(x,ct)}
    Copy constructor.  This does a deep copy by default.
    See also {\bf{}\hyperref{operator=(x)}{operator=(x) \rm(\S}{)}{GridCollection::operator=(x)}}
    and {\bf{}\hyperref{reference(x)}{reference(x) \rm(\S}{)}{GridCollection::reference(x)}}.

  \subsubsection{virtual $\sim$GridCollection()}
  \label{GridCollection::tilde_GridCollection()}
    Destructor.

  \subsubsection{GridCollection\& operator=(const GridCollection\&~x)}
  \label{GridCollection::operator=(x)}
    Assignment operator.  This is also called a deep copy.

  \subsubsection{void reference(const GridCollection\&~x)}
  \label{GridCollection::reference(x)}
    Make a reference.  This is also called a shallow copy.  This \textbf{GridCollection} shares the data of \textbf{x}.

  \subsubsection{virtual void breakReference()}
  \label{GridCollection::breakReference()}
    Break a reference.  If this \textbf{MappedGrid} shares data with any other \textbf{GridCollection},
    then this function replaces it with a new copy that does not share data.

  \subsubsection{void changeToAllVertexCentered()}
  \label{GridCollection::changeToAllVertexCentered()}
    Change the grid to be all vertex-centered.

  \subsubsection{void changeToAllCellCentered()}
  \label{GridCollection::changeToAllCellCentered()}
    Change the grid to be all cell-centered.

  \subsubsection{virtual void consistencyCheck() const}
  \label{GridCollection::consistencyCheck() const}
    Check the consistency of this \textbf{GridCollection}.

  \subsubsection{virtual Integer get(const GenericDataBase\&~dir, const aString\&~name)}
  \label{GridCollection::get(dir,name)}
    Copy a \textbf{GridCollection} from a file.

  \subsubsection{virtual Integer put(GenericDataBase\&~dir, const aString\&~name) const}
  \label{GridCollection::put(dir,name) const}
    Copy a \textbf{GridCollection} into a file.

  \subsubsection{Integer update(const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{GridCollection::update(what,how)}
    Update geometric data.
    The first argument (\textbf{what}) indicates which geometric data are to be updated.  Any combination of the constants
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{GridCollection::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{GridCollection::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGridCollection::update(what,how)}{GenericGridCollection::update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}} or
    {\bf{}\hyperref{MappedGrid::update(what,how)}{MappedGrid::update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}},
    may be bitwise ORed together to form the first argument of \textbf{update}(),
    to indicate which geometric data should be updated.
    This function returns a value obtained by bitwise ORing some of these constants,
    to indicate for which of the optional geometric data new array space was allocated.
    In addition, the constant
    {\bf{}\hyperref{COMPUTEfailed}{COMPUTEfailed \rm(\S}{)}{GenericGridCollection::COMPUTEfailed}},
    may be bitwise ORed into the value returned by \textbf{update}() in order to indicate
    that the computation of some geometric data failed.  The second argument (\textbf{how})
    indicates whether and how any computation of geometric data should be done.
    The constant {\bf{}\hyperref{COMPUTEtheUsual}{COMPUTEtheUsual \rm(\S}{)}{GridCollection::COMPUTEtheUsual}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGridCollection::update(what,how)}{GenericGridCollection::update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}} or
    {\bf{}\hyperref{MappedGrid::update(what,how)}{MappedGrid::update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}},
    may be bitwise ORed together to form the optional second argument of \textbf{update}().
    The corresponding function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}}
    is called with the same arguments for the base class \textbf{GenericGridCollection}, and
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    is called with the same arguments for each \textbf{MappedGrid} in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GridCollection::grid}}.

  \subsubsection{Integer update(GridCollection\&~x, const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{GridCollection::update(x,what,how)}
    Update geometric data, sharing space with the optional geometric data of another grid (\textbf{x}).
    If space for any indicated optional geometric data has not yet been allocated, or has
    the wrong dimensions, but \textbf{x} does contain the corresponding data, then the data
    for this \textbf{GridCollection} will share space with the corresponding data of \textbf{x}.
    Any geometric data that already exists and has the correct dimensions
    is not forced to share space with the corresponding data of \textbf{x}.
    The corresponding function
    {\bf{}\hyperref{update(x,what,how)}{update(x,what,how) \rm(\S}{)}{GenericGridCollection::update(x,what,how)}}
    is called with the same arguments for the base class \textbf{GenericGridCollection}, and
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{MappedGrid::update(what,how)}}
    is called with the same arguments for each \textbf{MappedGrid} in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GridCollection::grid}}.
    For the optional arguments \textbf{what} and \textbf{how}, see the description of the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GridCollection::update(what,how)}}.

  \subsubsection{virtual void destroy(const Integer what~=~NOTHING)}
  \label{GridCollection::destroy(what)}
    Destroy the indicated optional geometric grid data.
    The argument (\textbf{what}) indicates which optional
    geometric data are to be destroyed.  Any combination of the constants
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{GridCollection::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{GridCollection::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GenericGridCollection::destroy(what)}{GenericGridCollection::destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}} or
    {\bf{}\hyperref{MappedGrid::destroy(what)}{MappedGrid::destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}},
    may be bitwise ORed together to form the optional argument \textbf{what}.
    The corresponding function
    {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}
    is called with the same argument for the base class \textbf{GenericGridCollection}, and
    {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{MappedGrid::destroy(what)}}
    is called with the same argument for each grid in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GridCollection::grid}}.

  \subsubsection{virtual Integer addRefinement(const IntegerArray\&~range, const IntegerArray\&~factor)
     const Integer\&~level, const Integer k~=~0)}
  \label{GridCollection::addRefinement(range,IntegerArray_factor,level,k)}
    Add a refinement grid to this collection.  This refinement grid is marked as belonging to refinement level \textbf{level}.
    It is marked as having the same base grid as that of \textbf{grid}[\textbf{k}], which may be any sibling, parent, or
    other more remote ancestor.  It is required that $\textbf{level}>0$.  There must already exist grids marked as belonging
    to refinement level $\textbf{level}-1$.
    The {\bf{}\hyperref{indexRange()}{indexRange() \rm(\S}{)}{MappedGrid::indexRange()}} of the refinement is computed from \textbf{range},
    which must be a subset of the index range of a refinement of the same base grid (the refinement grid's most remote ancestor),
    at the next-coarser level of refinement (the refinement level of any parent grid), that would cover the entire base grid.
    The refinement factor \textbf{factor} is relative to any parent grid; any cell of any parent grid that is covered by cells
    of the new refinement grid is subdivided in each direction $k$ into $\textbf{factor}(k)$ cells of the new refinement grid.
    This function returns the index of the refinement grid.

  \subsubsection{Integer addRefinement(const IntegerArray\&~range, const Integer\&~factor)
     const Integer\&~level, const Integer k~=~0)}
  \label{GridCollection::addRefinement(range,Integer_factor,level,k)}
    Add a refinement grid to this collection.  This function simply calls
    {\bf{}\hyperref{addRefinement()}{addRefinement() \rm(\S}{)}{GridCollection::addRefinement(range,IntegerArray_factor,level,k)}}
    with \textbf{factor} replaced by an \textbf{IntegerArray} of length three set to the scalar \textbf{factor}.
    This function returns the index of the refinement grid.

  \subsubsection{virtual void deleteRefinement(const Integer\&~k)}
  \label{GridCollection::deleteRefinement(k)}
    Delete all multigrid levels of refinement grid \textbf{k}.

  \subsubsection{virtual void deleteRefinementLevels(const Integer\&~level)}
  \label{GridCollection::deleteRefinementLevels(level)}
    Delete all grids in this collection marked as belonging to refinement levels greater than \textbf{level}.
    It is required that $\textbf{level}\ge0$.

  \subsubsection{void referenceRefinementLevels(GridCollection\&~x,  Integer level~=~INTEGER\_MAX)}
  \label{GridCollection::referenceRefinementLevels(x,level)}
    Make this collection contain exactly those grids from the collection \textbf{x} which are marked in \textbf{x}
    as belonging to refinement level \textbf{level} or to any coarser refinent level.  It is required that
    $\textbf{level}\ge0$.

  \subsubsection{virtual Integer addMultigridCoarsening(const IntegerArray\&~factor, const Integer\&~level, const Integer k~=~0)}
  \label{GridCollection::addMultigridCoarsening(array_factor,level,k)}
    Add a multigrid coarsening of a grid to this collection.
    The multigrid coarsening factor in each index direction, relative to the next-finer multigrid level, is given by \textbf{factor}.
    This coarsening is marked as belonging to multigrid level \textbf{level}.
    It is marked as belonging to the same component grid as that of \textbf{grid}[\textbf{k}], which may be any finer multigrid level
    of the same component grid.  It is required that $\textbf{level}>0$.
    There must already exist a multigrid coarsening of the component grid at multigrid level $\textbf{level}-1$.
    This function returns the index of the multigrid coarsening.

  \subsubsection{Integer addMultigridCoarsening(const Integer\&~factor, const Integer\&~level, const Integer k~=~0)}
  \label{GridCollection::addMultigridCoarsening(factor,level,k)}
    Add a multigrid coarsening of a grid to this collection.
    The multigrid coarsening factor relative to the next-finer multigrid level is given by \textbf{factor}.
    This coarsening is marked as belonging to multigrid level \textbf{level}.
    It is marked as belonging to the same component grid as that of \textbf{grid}[\textbf{k}], which may be any finer multigrid level
    of the same component grid.  It is required that $\textbf{level}>0$.
    There must already exist a multigrid coarsening of the component grid at multigrid level $\textbf{level}-1$.
    This function returns the index of the multigrid coarsening.

  \subsubsection{virtual void deleteMultigridCoarsening(const Integer\&~k)}
  \label{GridCollection::deleteMultigridCoarsening(k)}
    Delete grid \textbf{k},a multigrid coarsening, and all of its coarser multigrid levels.

  \subsubsection{virtual void deleteMultigridLevels(const Integer level~=~0)}
  \label{GridCollection::deleteMultigridLevels(level)}
    Delete all grids in this collection marked as belonging to multigrid levels greater than \textbf{level}.
    It is required that $\textbf{level}\ge0$.

  \subsubsection{virtual void initialize(const Integer\&~numberOfDimensions\_,  Integer\&~numberOfGrids\_)}
  \label{GridCollection::initialize(numberOfDimensions,numberOfGrids_)}
    Initialize the GridCollection with the given number of grids.
    These grids have their gridNumbers, baseGridNumbers and componentGridNumbers
    set to $[0,\dots,\mbox{numberOfGrids\_}-1]$, and their refinementLevelNumbers and
    multigridLevelNumbers set to zero.

\subsection{Public Member functions for access to data}
\label{GridCollection::PublicAccessToData}

  \subsubsection{const Integer\& numberOfDimensions() const}
  \label{GenericGridCollection::numberOfDimensions() const}
    This function returns a reference to the number of dimensions of the grids in the list
    {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GenericGridCollection::grid}}.

  \subsubsection{virtual aString getClassName() const}
  \label{GridCollection::getClassName() const}
    Get the class name of the most-derived class for this object.

  \subsubsection{MappedGrid\& operator[](const int\&~i) const}
  \label{GridCollection::operator[](i)}
    Get a reference to the $i$th grid.
    If \textbf{g} is a \textbf{GridCollection}, then $\textbf{g}[i]$
    is a reference to the \textbf{MappedGrid} $\textbf{g}.\textbf{grid}[i]$.

  \subsubsection{GridCollectionData$*$ operator${-}{>}$()}
  \label{GridCollection::operator->()}
    Access the reference-counted data.

  \subsubsection{GridCollectionData\& operator$*$()}
  \label{GridCollection::operator*()}
    Access the pointer to the reference-counted data.

\subsection{Public member functions called only from derived classes}
\label{GridCollection::PublicDerivedClassMemberFunctions}

It is recommended that these functions be called only from derived classes.

  \subsubsection{void reference(GridCollectionData\&~x)}
  \label{GridCollection::reference(GridCollectionData_x)}
    Make a reference to an object of type \textbf{GridCollectionData}.
    This \textbf{GridCollection} uses \textbf{x} for its data.
    It is recommended that this function be called only from derived classes.

  \subsubsection{void updateReferences(const Integer what~=~EVERYTHING)}
  \label{GridCollection::updateReferences(what)}
    Update references to the reference-counted data.
    It is recommended that this function be called only from derived classes.

  \subsubsection{virtual void setNumberOfGrids(const Integer\&~numberOfGrids\_)}
  \label{GridCollection::setNumberOfGrids(numberOfGrids_)}
    Set the number of grids, and add or delete grids to/from this collection until there are \textbf{numberOfGrids\_} grids.
    See also {\bf{}\hyperref{setNumberOfDimensionsAndGrids(numberOfDimensions\_, numberOfGrids\_)}{setNumberOfDimensionsAndGrids(numberOfDimensions\_, numberOfGrids\_) \rm(\S}{)}{GridCollection::setNumberOfDimensionsAndGrids(numberOfDimensions_, numberOfGrids_)}}.

  \subsubsection{virtual void setNumberOfDimensions(const Integer\&~numberOfDimensions\_)}
  \label{GridCollection::setNumberOfDimensions(numberOfDimensions)}
    Set the number of dimensions.  This is valid only if the collection does not contain \textbf{MappedGrid}s with a different number of dimensions.
    See also {\bf{}\hyperref{setNumberOfDimensionsAndGrids(numberOfDimensions\_, numberOfGrids\_)}{setNumberOfDimensionsAndGrids(numberOfDimensions\_, numberOfGrids\_) \rm(\S}{)}{GridCollection::setNumberOfDimensionsAndGrids(numberOfDimensions_, numberOfGrids_)}}.

  \subsubsection{virtual void setNumberOfDimensionsAndGrids(const Integer\&~numberOfDimensios\_, const Integer\&~numberOfGrids\_)}
  \label{GridCollection::setNumberOfDimensionsAndGrids(numberOfDimensions_, numberOfGrids_)}
    Set the number of dimensions of the grids, and add or delete grids to/from this collection until there are \textbf{numberOfGrids\_} grids.
    Any grids added are marked as belonging to base grid zero, multigrid level zero and refinement level zero.
    The use of this function is not recommended if the collection is intended to contain more than one
    base grid, multigrid level or refinement level.  For example,
    if the collection is intended to contain more than one refinement level, it is recommended that the functions
    {\bf{}\hyperref{addRefinement(range,factor,level,k)}{addRefinement(range,factor,level,k) \rm(\S}{)}{GridCollection::addRefinement(range,IntegerArray_factor,level,k)}} and
    {\bf{}\hyperref{deleteRefinementLevels(level)}{deleteRefinementLevels(level) \rm(\S}{)}{GridCollection::deleteRefinementLevels(level)}}
    be used instead.

\subsection{Public data}
\label{GridCollection::PublicData}

  \subsubsection{const RealArray boundingBox}
  \label{GridCollection::boundingBox}
    Dimensions: $(0\colon2)$ \\*[\parskip]
    \textbf{boundingBox} holds coordinate bounds for the grids in the list {\bf{}\hyperref{grid}{grid \rm(\S}{)}{GridCollection::grid}}.
    It is computed as the min/max of {\bf{}\hyperref{MappedGrid::boundingBox()}{MappedGrid::boundingBox() \rm(\S}{)}{MappedGrid::boundingBox()}}
    from each grid in the collection.

  \subsubsection{const IntegerArray refinementFactor}
  \label{GridCollection::refinementFactor}
    Dimensions: $(0\colon2,0\colon\textbf{numberOfGrids}()-1)$ \\*[\parskip]
    \textbf{refinementFactor} holds the ratio, for each grid, in each index direction, of the size of cells of the corresponding unrefined
    base grid (at the same multigrid level) to the size of cells of that grid.

  \subsubsection{const IntegerArray multigridCoarseningFactor}
  \label{GridCollection::multigridCoarseningFactor}
    Dimensions: $(0\colon2,0\colon\textbf{numberOfGrids}()-1)$ \\*[\parskip]
    \textbf{multigridCoarseningFactor} holds the ratio, for each grid, in each index direction, of the size of cells of that grid
    to the size of cells of the finest multigrid level of the same component grid.

  \subsubsection{ListOfMappedGrid grid}
  \label{GridCollection::grid}
    Length: {\bf{}\hyperref{numberOfGrids()}{numberOfGrids() \rm(\S}{)}{GenericGridCollection::numberOfGrids() const}} \\*[\parskip]
    A list containing of all of the grids in the collection. The grids in this list are \textbf{MappedGrid}s.
    \textbf{grid} overloads
    {\bf{}\hyperref{GenericGridCollection::grid}{GenericGridCollection::grid \rm(\S}{)}{GenericGridCollection::grid}},
    which contains the same \textbf{MappedGrid}s (referred to in the latter case as \textbf{GenericGrid}s).

  \subsubsection{ListOfGridCollection baseGrid}
  \label{GridCollection::baseGrid}
    \textbf{baseGrid} is
    a list of \textbf{GridCollection}s containing one base grid and all of its refinements, including all multigrid coarsenings of these grids.
    \textbf{baseGrid} overloads
    {\bf{}\hyperref{GenericGridCollection::baseGrid}{GenericGridCollection::baseGrid \rm(\S}{)}{GenericGridCollection::baseGrid}},
    which contains the same \textbf{GridCollection}s (referred to in the latter case as \textbf{GenericGridCollection}s).
    This data may be updated as in the following example.

  \subsubsection{ListOfGridCollection refinementLevel}
  \label{GridCollection::refinementLevel}
    \textbf{refinementLevel} is a list of \textbf{GridCollection}s containing those \textbf{MappedGrid}s which belong to the same refinement level.
    \textbf{refinementLevel} overloads
    {\bf{}\hyperref{GenericGridCollection::refinementLevel}{GenericGridCollection::refinementLevel \rm(\S}{)}{GenericGridCollection::refinementLevel}},
    whose \textbf{GenericGridCollection}s contain the same grids as the \textbf{GridCollection}s of \textbf{refinementLevel}.
    This data may be updated as in the following example.

  \subsubsection{ListOfGridCollection componentGrid}
  \label{GridCollection::componentGrid}
    \textbf{componentGrid} is a list of \textbf{GridCollection}s containing one componenent grid and all of its multigrid coarsenings.
    \textbf{componentGrid} overloads
    {\bf{}\hyperref{GenericGridCollection::componentGrid}{GenericGridCollection::componentGrid \rm(\S}{)}{GenericGridCollection::componentGrid}},
    which contains the same \textbf{GridCollection}s (referred to in the latter case as \textbf{GenericGridCollection}s).
    This data may be updated as in the following example.

  \subsubsection{ListOfGridCollection multigridLevel} 
  \label{GridCollection::multigridLevel} 
    \textbf{multigridLevel} is a list of \textbf{GridCollection}s containing those \textbf{MappedGrid}s which belong to the same multigrid level.
    \textbf{multigridLevel} overloads
    {\bf{}\hyperref{GenericGridCollection::multigridLevel}{GenericGridCollection::multigridLevel \rm(\S}{)}{GenericGridCollection::multigridLevel}},
    whose \textbf{GenericGridCollection}s contain the same grids as the \textbf{GridCollection}s of \textbf{multigridLevel}
    (referred to in the latter case as \textbf{GenericGrid}s).
    This data may be updated as in the following example.

  \subsubsection{AMR\_RefinementLevelInfo$\ast$ refinementLevelInfo}
  \label{MappedGrid::refinementLevelInfo}
    This is used for adaptive mesh refinement.  Dan Quinlan++ has documentation for it.

\subsection{Public data used only by derived classes}
\label{GridCollection::PublicDerivedClassData}

It is recommended that these variables be used only by derived classes.

  \subsubsection{GridCollectionData$*$ rcData}
  \label{GridCollection::rcData}
    \textbf{rcData} is a pointer to the reference-counted data.
    It is recommended that this variable be used only by derived classes.
    See also the member functions
    {\bf{}\hyperref{operator${-}{>}$()}{operator${-}{>}$() \rm(\S}{)}{GridCollection::operator->()}}
    and {\bf{}\hyperref{operator$*$()}{operator$*$() \rm(\S}{)}{GridCollection::operator*()}},
    which are provided for access to \textbf{rcData}.

  \subsubsection{Logical isCounted}
  \label{GridCollection::isCounted}
    \textbf{isCounted} is
    a flag that indicates whether the data pointed to by {\bf{}\hyperref{rcData}{rcData \rm(\S}{)}{GridCollection::rcData}} is known to be reference-counted.
    It is recommended that this variable be used only by derived classes.

\subsection{Public constants}
\label{GridCollection::PublicConstants}

  Class \textbf{GridCollection} has all of the same constants defined as classes \textbf{MappedGrid} and \textbf{GenericGridCollection}.
  These are listed here for the sake of completeness.

  \subsubsection{THEmask}
  \label{GridCollection::THEmask}
    \textbf{THEmask} = {\bf{}\hyperref{MappedGrid::THEmask}{MappedGrid::THEmask \rm(\S}{)}{MappedGrid::THEmask}}

  \subsubsection{THEvertex}
  \label{GridCollection::THEvertex}
    \textbf{THEvertex} = {\bf{}\hyperref{MappedGrid::THEvertex}{MappedGrid::THEvertex \rm(\S}{)}{MappedGrid::THEvertex}}

  \subsubsection{THEcenter}
  \label{GridCollection::THEcenter}
    \textbf{THEcenter} = {\bf{}\hyperref{MappedGrid::THEcenter}{MappedGrid::THEcenter \rm(\S}{)}{MappedGrid::THEcenter}}

  \subsubsection{THEcorner}
  \label{GridCollection::THEcorner}
    \textbf{THEcorner} = {\bf{}\hyperref{MappedGrid::THEcorner}{MappedGrid::THEcorner \rm(\S}{)}{MappedGrid::THEcorner}}

  \subsubsection{THEvertexDerivative}
  \label{GridCollection::THEvertexDerivative}
    \textbf{THEvertexDerivative} =
    {\bf{}\hyperref{MappedGrid::THEvertexDerivative}{MappedGrid::THEvertexDerivative \rm(\S}{)}{MappedGrid::THEvertexDerivative}}

  \subsubsection{THEcenterDerivative}
  \label{GridCollection::THEcenterDerivative}
    \textbf{THEcenterDerivative} =
    {\bf{}\hyperref{MappedGrid::THEcenterDerivative}{MappedGrid::THEcenterDerivative \rm(\S}{)}{MappedGrid::THEcenterDerivative}}

  \subsubsection{THEinverseVertexDerivative}
  \label{GridCollection::THEinverseVertexDerivative}
    \textbf{THEinverseVertexDerivative} =
    {\bf{}\hyperref{MappedGrid::THEinverseVertexDerivative}{MappedGrid::THEinverseVertexDerivative \rm(\S}{)}{MappedGrid::THEinverseVertexDerivative}}

  \subsubsection{THEinverseCenterDerivative}
  \label{GridCollection::THEinverseCenterDerivative}
    \textbf{THEinverseCenterDerivative} =
    {\bf{}\hyperref{MappedGrid::THEinverseCenterDerivative}{MappedGrid::THEinverseCenterDerivative \rm(\S}{)}{MappedGrid::THEinverseCenterDerivative}}

  \subsubsection{THEvertexJacobian}
  \label{GridCollection::THEvertexJacobian}
    \textbf{THEvertexJacobian} =
    {\bf{}\hyperref{MappedGrid::THEvertexJacobian}{MappedGrid::THEvertexJacobian \rm(\S}{)}{MappedGrid::THEvertexJacobian}}

  \subsubsection{THEcenterJacobian}
  \label{GridCollection::THEcenterJacobian}
    \textbf{THEcenterJacobian} =
    {\bf{}\hyperref{MappedGrid::THEcenterJacobian}{MappedGrid::THEcenterJacobian \rm(\S}{)}{MappedGrid::THEcenterJacobian}}

  \subsubsection{THEcellVolume}
  \label{GridCollection::THEcellVolume}
    \textbf{THEcellVolume} =
    {\bf{}\hyperref{MappedGrid::THEcellVolume}{MappedGrid::THEcellVolume \rm(\S}{)}{MappedGrid::THEcellVolume}}

  \subsubsection{THEfaceNormal}
  \label{GridCollection::THEfaceNormal}
    \textbf{THEfaceNormal} =
    {\bf{}\hyperref{MappedGrid::THEfaceNormal}{MappedGrid::THEfaceNormal \rm(\S}{)}{MappedGrid::THEfaceNormal}}

  \subsubsection{THEcenterNormal}
  \label{GridCollection::THEcenterNormal}
    \textbf{THEcenterNormal} =
    {\bf{}\hyperref{MappedGrid::THEcenterNormal}{MappedGrid::THEcenterNormal \rm(\S}{)}{MappedGrid::THEcenterNormal}}

  \subsubsection{THEfaceArea}
  \label{GridCollection::THEfaceArea}
    \textbf{THEfaceArea} =
    {\bf{}\hyperref{MappedGrid::THEfaceArea}{MappedGrid::THEfaceArea \rm(\S}{)}{MappedGrid::THEfaceArea}}

  \subsubsection{THEcenterArea}
  \label{GridCollection::THEcenterArea}
    \textbf{THEcenterArea} =
    {\bf{}\hyperref{MappedGrid::THEcenterArea}{MappedGrid::THEcenterArea \rm(\S}{)}{MappedGrid::THEcenterArea}}

  \subsubsection{THEvertexBoundaryNormal}
  \label{GridCollection::THEvertexBoundaryNormal}
    \textbf{THEvertexBoundaryNormal} =
    {\bf{}\hyperref{MappedGrid::THEvertexBoundaryNormal}{MappedGrid::THEvertexBoundaryNormal \rm(\S}{)}{MappedGrid::THEvertexBoundaryNormal}}

  \subsubsection{THEcenterBoundaryNormal}
  \label{GridCollection::THEcenterBoundaryNormal}
    \textbf{THEcenterBoundaryNormal} =
    {\bf{}\hyperref{MappedGrid::THEcenterBoundaryNormal}{MappedGrid::THEcenterBoundaryNormal \rm(\S}{)}{MappedGrid::THEcenterBoundaryNormal}}

  \subsubsection{THEcenterBoundaryTangent}
  \label{GridCollection::THEcenterBoundaryTangent}
    \textbf{THEcenterBoundaryTangent} =
    {\bf{}\hyperref{MappedGrid::THEcenterBoundaryTangent}{MappedGrid::THEcenterBoundaryTangent \rm(\S}{)}{MappedGrid::THEcenterBoundaryTangent}}

  \subsubsection{THEminMaxEdgeLength}
  \label{GridCollection::THEminMaxEdgeLength}
    \textbf{THEminMaxEdgeLength} =
    {\bf{}\hyperref{MappedGrid::THEminMaxEdgeLength}{MappedGrid::THEminMaxEdgeLength \rm(\S}{)}{MappedGrid::THEminMaxEdgeLength}}

  \subsubsection{THEboundingBox}
  \label{GridCollection::THEboundingBox}
    \textbf{THEboundingBox} =
    {\bf{}\hyperref{MappedGrid::THEboundingBox}{MappedGrid::THEboundingBox \rm(\S}{)}{MappedGrid::THEboundingBox}}

  \subsubsection{THEusualSuspects}
  \label{GridCollection::THEusualSuspects}
    \textbf{THEusualSuspects}
    =      {\bf{}\hyperref{GenericGridCollection::THEusualSuspects}{GenericGridCollection::THEusualSuspects \rm(\S}{)}{GenericGridCollection::THEusualSuspects}}
    $\mid$ {\bf{}\hyperref{MappedGrid::THEusualSuspects}{MappedGrid::THEusualSuspects \rm(\S}{)}{MappedGrid::THEusualSuspects}} \\*[\parskip]
    \textbf{THEusualSuspects} indicates some of the geometric data of a \textbf{GridCollection}.
    The particular data indicated by \textbf{THEusualSuspects} may change from time to time.
    For this reason the use of \textbf{THEusualSuspects} is not recommended.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GridCollection::destroy(what)}}.

  \subsubsection{EVERYTHING}
  \label{GridCollection::EVERYTHING}
    \textbf{EVERYTHING}
    =      {\bf{}\hyperref{GenericGridCollection::EVERYTHING}{GenericGridCollection::EVERYTHING \rm(\S}{)}{GenericGridCollection::EVERYTHING}}
    $\mid$ {\bf{}\hyperref{MappedGrid::EVERYTHING}{MappedGrid::EVERYTHING \rm(\S}{)}{MappedGrid::EVERYTHING}} \\*[\parskip]
    \textbf{EVERYTHING} indicates all of the geometric data associated with a \textbf{GridCollection}.  (overloaded)
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GridCollection::destroy(what)}}.

  \subsubsection{USEdifferenceApproximation}
  \label{GridCollection::USEdifferenceApproximation}
    \textbf{USEdifferenceApproximation} =
    {\bf{}\hyperref{MappedGrid::USEdifferenceApproximation}{MappedGrid::USEdifferenceApproximation \rm(\S}{)}{MappedGrid::USEdifferenceApproximation}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GridCollection::destroy(what)}}.

  \subsubsection{COMPUTEgeometry}
  \label{GridCollection::COMPUTEgeometry}
    \textbf{COMPUTEgeometry} =
    {\bf{}\hyperref{MappedGrid::COMPUTEgeometry}{MappedGrid::COMPUTEgeometry \rm(\S}{)}{MappedGrid::COMPUTEgeometry}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GridCollection::destroy(what)}}.

  \subsubsection{COMPUTEgeometryAsNeeded}
  \label{GridCollection::COMPUTEgeometryAsNeeded}
    \textbf{COMPUTEgeometryAsNeeded} =
    {\bf{}\hyperref{MappedGrid::COMPUTEgeometryAsNeeded}{MappedGrid::COMPUTEgeometryAsNeeded \rm(\S}{)}{MappedGrid::COMPUTEgeometryAsNeeded}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GridCollection::destroy(what)}}.

  \subsubsection{COMPUTEtheUsual}
  \label{GridCollection::COMPUTEtheUsual}
    \textbf{COMPUTEtheUsual} =
           {\bf{}\hyperref{GenericGridCollection::COMPUTEtheUsual}{GenericGridCollection::COMPUTEtheUsual \rm(\S}{)}{GenericGridCollection::COMPUTEtheUsual}}
    $\mid$ {\bf{}\hyperref{MappedGrid::COMPUTEtheUsual}{MappedGrid::COMPUTEtheUsual \rm(\S}{)}{MappedGrid::COMPUTEtheUsual}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GridCollection::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GridCollection::destroy(what)}}.

  \subsubsection{ISdiscretizationPoint}
  \label{GridCollection::ISdiscretizationPoint}
    \textbf{ISdiscretizationPoint} =
    {\bf{}\hyperref{MappedGrid::ISdiscretizationPoint}{MappedGrid::ISdiscretizationPoint \rm(\S}{)}{MappedGrid::ISdiscretizationPoint}}

  \subsubsection{ISinterpolationPoint}
  \label{GridCollection::ISinterpolationPoint}
    \textbf{ISinterpolationPoint} =
    {\bf{}\hyperref{MappedGrid::ISinterpolationPoint}{MappedGrid::ISinterpolationPoint \rm(\S}{)}{MappedGrid::ISinterpolationPoint}}

  \subsubsection{ISghostPoint}
  \label{GridCollection::ISghostPoint}
    \textbf{ISghostPoint} =
    {\bf{}\hyperref{MappedGrid::ISghostPoint}{MappedGrid::ISghostPoint \rm(\S}{)}{MappedGrid::ISghostPoint}}

  \subsubsection{ISinteriorBoundaryPoint}
  \label{GridCollection::ISinteriorBoundaryPoint}
    \textbf{ISinteriorBoundaryPoint} =
    {\bf{}\hyperref{MappedGrid::ISinteriorBoundaryPoint}{MappedGrid::ISinteriorBoundaryPoint \rm(\S}{)}{MappedGrid::ISinteriorBoundaryPoint}}

  \subsubsection{USESbackupRules}
  \label{GridCollection::USESbackupRules}
    \textbf{USESbackupRules} =
    {\bf{}\hyperref{MappedGrid::USESbackupRules}{MappedGrid::USESbackupRules \rm(\S}{)}{MappedGrid::USESbackupRules}}

  \subsubsection{IShiddenByRefinement}
  \label{GridCollection::IShiddenByRefinement}
    \textbf{IShiddenByRefinement} =
    {\bf{}\hyperref{MappedGrid::IShiddenByRefinement}{MappedGrid::IShiddenByRefinement \rm(\S}{)}{MappedGrid::IShiddenByRefinement}}

  \subsubsection{ISreservedBit0}
  \label{GridCollection::ISreservedBit0}
    \textbf{ISreservedBit0} =
    {\bf{}\hyperref{MappedGrid::ISreservedBit0}{MappedGrid::ISreservedBit0 \rm(\S}{)}{MappedGrid::ISreservedBit0}}

  \subsubsection{ISreservedBit1}
  \label{GridCollection::ISreservedBit1}
    \textbf{ISreservedBit1} =
    {\bf{}\hyperref{MappedGrid::ISreservedBit1}{MappedGrid::ISreservedBit1 \rm(\S}{)}{MappedGrid::ISreservedBit1}}

  \subsubsection{ISreservedBit2}
  \label{GridCollection::ISreservedBit2}
    \textbf{ISreservedBit2} =
    {\bf{}\hyperref{MappedGrid::ISreservedBit2}{MappedGrid::ISreservedBit2 \rm(\S}{)}{MappedGrid::ISreservedBit2}}

  \subsubsection{GRIDnumberBits}
  \label{GridCollection::GRIDnumberBits}
    \textbf{GRIDnumberBits} =
    {\bf{}\hyperref{MappedGrid::GRIDnumberBits}{MappedGrid::GRIDnumberBits \rm(\S}{)}{MappedGrid::GRIDnumberBits}}

  \subsubsection{ISusedPoint}
  \label{GridCollection::ISusedPoint}
    \textbf{ISusedPoint} =
    {\bf{}\hyperref{MappedGrid::ISusedPoint}{MappedGrid::ISusedPoint \rm(\S}{)}{MappedGrid::ISusedPoint}}

\section{Class CompositeGrid}\index{CompositeGrid}
\label{CompositeGrid}

Class \textbf{CompositeGrid} is used for a composite overlapping grid, which
is a collection of \textbf{MappedGrid}s and a description of how function
values defined on these grids are related through interpolation
between grids in their regions of overlap.  Class \textbf{CompositeGrid}
is derived from class \textbf{GridCollection}.

\subsection{Public member functions}
\label{CompositeGrid::PublicMemberFunctions}

  \subsubsection{CompositeGrid(const Integer numberOfDimensions\_~=~0,  const Integer numberOfComponentGrids\_~=~0)}
  \label{CompositeGrid::CompositeGrid(numberOfDimensions_,numberOfComponentGrids_)}
    Default constructor.
    If numberOfDimensions\_==0 ({\sl{}e.g.}, by default) then create a null CompositeGrid.
    Otherwise create a CompositeGrid with the given number of dimensions and number of component grids.

  \subsubsection{CompositeGrid(const CompositeGrid\&~x, const CopyType ct~=~DEEP)}
  \label{CompositeGrid::CompositeGrid(x,ct)}
    Copy constructor.  This does a deep copy by default.
    See also {\bf{}\hyperref{operator=(x)}{operator=(x) \rm(\S}{)}{CompositeGrid::operator=(x)}}
    and {\bf{}\hyperref{reference(x)}{reference(x) \rm(\S}{)}{CompositeGrid::reference(CompositeGrid_x)}}.

  \subsubsection{virtual $\sim$CompositeGrid()}
  \label{CompositeGrid::tilde_CompositeGrid()}
    Destructor.

  \subsubsection{CompositeGrid\& operator=(const CompositeGrid\&~x)}
  \label{CompositeGrid::operator=(x)}
    Assignment operator.  This is also called a deep copy.

  \subsubsection{void reference(const CompositeGrid\&~x)}
  \label{CompositeGrid::reference(CompositeGrid_x)}
    Make a reference.  This is also called a shallow copy.  This \textbf{CompositeGrid} shares the data of \textbf{x}.

  \subsubsection{virtual void breakReference()}
  \label{CompositeGrid::breakReference()}
    Break a reference.  If this \textbf{CompositeGrid} shares data with any other \textbf{CompositeGrid},
    then this function replaces it with a new copy that does not share data.

  \subsubsection{void changeToAllVertexCentered()}
  \label{CompositeGrid::changeToAllVertexCentered()}
    Change the \textbf{MappedGrid}s in this \textbf{CompositeGrid} to be all vertex-centered.

  \subsubsection{void changeToAllCellCentered()}
  \label{CompositeGrid::changeToAllCellCentered()}
    Change the \textbf{MappedGrid}s in this \textbf{CompositeGrid} to be all cell-centered.

  \subsubsection{virtual void consistencyCheck() const}
  \label{CompositeGrid::consistencyCheck() const}
    Check the consistency of this \textbf{CompositeGrid}.

  \subsubsection{virtual Integer get(const GenericDataBase\&~dir, const aString\&~name)}
  \label{CompositeGrid::get(dir,name)}
    Copy a \textbf{CompositeGrid} from a file.

  \subsubsection{virtual Integer put(GenericDataBase\&~dir, const aString\&~name) const}
  \label{CompositeGrid::put(dir,name) const}
    Copy a \textbf{CompositeGrid} into a file.

  \subsubsection{Integer update(const Integer what~=~THEusualSuspects,  const Integer how~=~COMPUTEtheUsual)}
  \label{CompositeGrid::update(what,how)}
    Update geometric data.
    The first argument (\textbf{what}) indicates which geometric data are to be updated.  Any combination of the constants
    {\bf{}\hyperref{THEinterpolationCoordinates}{THEinterpolationCoordinates \rm(\S}{)}{CompositeGrid::THEinterpolationCoordinates}},
    {\bf{}\hyperref{THEinterpoleeGrid}{THEinterpoleeGrid \rm(\S}{)}{CompositeGrid::THEinterpoleeGrid}},
    {\bf{}\hyperref{THEinterpoleeLocation}{THEinterpoleeLocation \rm(\S}{)}{CompositeGrid::THEinterpoleeLocation}},
    {\bf{}\hyperref{THEinterpolationPoint}{THEinterpolationPoint \rm(\S}{)}{CompositeGrid::THEinterpolationPoint}},
    {\bf{}\hyperref{THEinterpolationCondition}{THEinterpolationCondition \rm(\S}{)}{CompositeGrid::THEinterpolationCondition}},
    {\bf{}\hyperref{THEinverseMap}{THEinverseMap \rm(\S}{)}{CompositeGrid::THEinverseMap}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{CompositeGrid::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{CompositeGrid::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GridCollection::update(what,how)}{GenericGridCollection::update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}},
    may be bitwise ORed together to form the first argument of \textbf{update}(),
    to indicate which geometric data should be updated.
    This function returns a value obtained by bitwise ORing some of these constants,
    to indicate for which of the optional geometric data new array space was allocated.
    In addition, the constant
    {\bf{}\hyperref{COMPUTEfailed}{COMPUTEfailed \rm(\S}{)}{GenericGridCollection::COMPUTEfailed}},
    may be bitwise ORed into the value returned by \textbf{update}() in order to indicate
    that the computation of some geometric data failed.  The second argument (\textbf{how})
    indicates whether and how any computation of geometric data should be done.
    The constant {\bf{}\hyperref{COMPUTEtheUsual}{COMPUTEtheUsual \rm(\S}{)}{CompositeGrid::COMPUTEtheUsual}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GridCollection::update(what,how)}{GenericGridCollection::update(what,how) \rm(\S}{)}{GenericGridCollection::update(what,how)}},
    may be bitwise ORed together to form the optional second argument of \textbf{update}().
    The corresponding function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{GridCollection::update(what,how)}}
    is called with the same arguments for the base class \textbf{GridCollection}.

  \subsubsection{Integer update(CompositeGrid\&~x, const Integer what~=~THEusualSuspects, const Integer how~=~COMPUTEtheUsual)}
  \label{CompositeGrid::update(x,what,how)}
    Update geometric data, sharing space with the optional geometric data of another grid (\textbf{x}).
    If space for any indicated optional geometric data has not yet been allocated, or has
    the wrong dimensions, but \textbf{x} does contain the corresponding data, then the data
    for this \textbf{CompositeGrid} will share space with the corresponding data of \textbf{x}.
    Any geometric data that already exists and has the correct dimensions
    is not forced to share space with the corresponding data of \textbf{x}.
    The corresponding function
    {\bf{}\hyperref{update(x,what,how)}{update(x,what,how) \rm(\S}{)}{GridCollection::update(x,what,how)}}
    is called with the same arguments for the base class \textbf{GenericGridCollection}.
    For the optional arguments \textbf{what} and \textbf{how}, see the description of the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}.

  \subsubsection{virtual void destroy(const Integer what~=~NOTHING)}
  \label{CompositeGrid::destroy(what)}
    Destroy the indicated optional geometric grid data.
    The argument (\textbf{what}) indicates which optional
    geometric data are to be destroyed.  Any combination of the constants
    {\bf{}\hyperref{THEinterpolationCoordinates}{THEinterpolationCoordinates \rm(\S}{)}{CompositeGrid::THEinterpolationCoordinates}},
    {\bf{}\hyperref{THEinterpoleeGrid}{THEinterpoleeGrid \rm(\S}{)}{CompositeGrid::THEinterpoleeGrid}},
    {\bf{}\hyperref{THEinterpoleeLocation}{THEinterpoleeLocation \rm(\S}{)}{CompositeGrid::THEinterpoleeLocation}},
    {\bf{}\hyperref{THEinterpolationPoint}{THEinterpolationPoint \rm(\S}{)}{CompositeGrid::THEinterpolationPoint}},
    {\bf{}\hyperref{THEinterpolationCondition}{THEinterpolationCondition \rm(\S}{)}{CompositeGrid::THEinterpolationCondition}},
    {\bf{}\hyperref{THEinverseMap}{THEinverseMap \rm(\S}{)}{CompositeGrid::THEinverseMap}},
    {\bf{}\hyperref{THEusualSuspects}{THEusualSuspects \rm(\S}{)}{CompositeGrid::THEusualSuspects}} and
    {\bf{}\hyperref{EVERYTHING}{EVERYTHING \rm(\S}{)}{CompositeGrid::EVERYTHING}},
    as well as any of the corresponding constants allowed for
    {\bf{}\hyperref{GridCollection::destroy(what)}{GenericGridCollection::destroy(what) \rm(\S}{)}{GenericGridCollection::destroy(what)}}
    may be bitwise ORed together to form the optional argument \textbf{what}.
    The corresponding function
    {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{GridCollection::destroy(what)}}
    is called with the same argument for the base class \textbf{GridCollection}.

  \subsubsection{virtual Integer addRefinement(const IntegerArray\&~range, const IntegerArray\&~factor,
     const Integer\&~level, const Integer k~=~0)}
  \label{CompositeGrid::addRefinement(range,IntegerArray_factor,level,k)}
    Add a refinement grid to this collection.  This refinement grid is marked as belonging to refinement level \textbf{level}.
    It is marked as having the same base grid as that of \textbf{grid}[\textbf{k}], which may be any sibling, parent, or
    other more remote ancestor.  It is required that $\textbf{level}>0$.  There must already exist grids marked as belonging
    to refinement level $\textbf{level}-1$.
    The {\bf{}\hyperref{indexRange()}{indexRange() \rm(\S}{)}{MappedGrid::indexRange()}} of the refinement is computed from \textbf{range},
    which must be a subset of the index range of a refinement of the same base grid (the refinement grid's most remote ancestor),
    at the next-coarser level of refinement (the refinement level of any parent grid), that would cover the entire base grid.
    The refinement factor \textbf{factor} is relative to any parent grid; any cell of any parent grid that is covered by cells
    of the new refinement grid is subdivided in each direction $k$ into $\textbf{factor}(k)$ cells of the new refinement grid.
    This function returns the index of the refinement grid.

  \subsubsection{Integer addRefinement(const IntegerArray\&~range, const Integer\&~factor,
     const Integer\&~level, const Integer k~=~0)}
  \label{CompositeGrid::addRefinement(range,Integer_factor,level,k)}
    Add a refinement grid to this collection.  This function simply calls
    {\bf{}\hyperref{addRefinement()}{addRefinement() \rm(\S}{)}{CompositeGrid::addRefinement(range,IntegerArray_factor,level,k)}}
    with \textbf{factor} replaced by an \textbf{IntegerArray} of length three set to the scalar \textbf{factor}.
    This function returns the index of the refinement grid.

  \subsubsection{virtual void deleteRefinement(const Integer\&~k)}
  \label{CompositeGrid::deleteRefinement(k)}
    Delete all multigrid levels of refinement grid \textbf{k}.

  \subsubsection{virtual void deleteRefinementLevels(const Integer\&~level)}
  \label{CompositeGrid::deleteRefinementLevels(level)}
    Delete all grids in this collection marked as belonging to refinement levels greater than \textbf{level}.
    It is required that $\textbf{level}\ge0$.

  \subsubsection{void referenceRefinementLevels(CompositeGrid\&~x,  Integer level~=~INTEGER\_MAX)}
  \label{CompositeGrid::referenceRefinementLevels(x,level)}
    Make this collection contain exactly those grids from the collection \textbf{x} which are marked in \textbf{x}
    as belonging to refinement level \textbf{level} or to any coarser refinent level.  It is required that
    $\textbf{level}\ge0$.

  \subsubsection{virtual Integer addMultigridCoarsening(const IntegerArray\&~factor, const Integer\&~level, const Integer k~=~0)}
  \label{CompositeGrid::addMultigridCoarsening(array_factor,level,k)}
    Add a multigrid coarsening of a grid to this collection.
    The multigrid coarsening factor in each index direction, relative to the next-finer multigrid level, is given by \textbf{factor}.
    This coarsening is marked as belonging to multigrid level \textbf{level}.
    It is marked as belonging to the same component grid as that of \textbf{grid}[\textbf{k}], which may be any finer multigrid level
    of the same component grid.  It is required that $\textbf{level}>0$.
    There must already exist a multigrid coarsening of the component grid at multigrid level $\textbf{level}-1$.
    This function returns the index of the multigrid coarsening.

  \subsubsection{Integer addMultigridCoarsening(const Integer\&~factor, const Integer\&~level, const Integer k~=~0)}
  \label{CompositeGrid::addMultigridCoarsening(factor,level,k)}
    Add a multigrid coarsening of a grid to this collection.
    The multigrid coarsening factor relative to the next-finer multigrid level is given by \textbf{factor}.
    This coarsening is marked as belonging to multigrid level \textbf{level}.
    It is marked as belonging to the same component grid as that of \textbf{grid}[\textbf{k}], which may be any finer multigrid level
    of the same component grid.  It is required that $\textbf{level}>0$.
    There must already exist a multigrid coarsening of the component grid at multigrid level $\textbf{level}-1$.
    This function returns the index of the multigrid coarsening.

  \subsubsection{void makeCompleteMultigridLevels()}
  \label{CompositeGrid::makeCompleteMultigridLevels()}
    Add multigrid coarsenings of component grids as needed in order to complete the multigrid levels, so that each component grid, including
    any and all refinement grids, has at least $\textbf{numberOfCompleteMultigridLevels}()$ multigrid levels.
    There should already exist at least two multigrid levels of each unrefined component grid.  Otherwise, any multigrid levels added will use
    default values for multigrid parameters, which may be inappropriate.  Any multigrid levels added to unrefined component grids that already
    have at least one but fewer than $\textbf{numberOfCompleteMultigridLevels}()$ multigrid levels take their multigrid parameters from the
    next-finer multigrid level of the same component grid.  Any multigrid levels added to refinement grids take their multigrid parameters from
    the same multigrid level of the corresponding unrefined component grid.

  \subsubsection{virtual void deleteMultigridCoarsening(const Integer\&~k)}
  \label{CompositeGrid::deleteMultigridCoarsening(k)}
    Delete grid \textbf{k},a multigrid coarsening, and all of its coarser multigrid levels.

  \subsubsection{virtual void deleteMultigridLevels(const Integer level~=~0)}
  \label{CompositeGrid::deleteMultigridLevels(level)}
    Delete all grids in this collection marked as belonging to multigrid levels greater than \textbf{level}.
    It is required that $\textbf{level}\ge0$.

  \subsubsection{void getInterpolationStencil(const Integer\&~k1, const IntegerArray\&~k2, const RealArray\&~r, IntegerArray\&~interpolationStencil,  const LogicalArray\&~useBackupRules)}
  \label{CompositeGrid::getInterpolationStencil(k1,k2,r,interpolationStencil,useBackupRules)}
    \begin{description}
      \item{\textbf{g}  (INPUT)} The unrefined grid corresponding to grid \textbf{k2}.
      \item{\textbf{k1} (INPUT)} The index of the grid containing the interpolation points.
      \item{\textbf{k2} (INPUT)} The index of the grid containing the interpolee points.
      \item{\textbf{r}  (INPUT)} Dimensions:  $(N,0\colon n_1)$\\*
                           The interpolation coordinates of the interpolation points.
                           The range of points $N$ for which the boundary is adjusted is determined
                           by the first dimension of \textbf{r}.  The first dimension of
                           \textbf{interpolationStencil} and \textbf{useBackupRules} should be
                           the same as the first the dimension of \textbf{r}.  The second dimension of
                           \textbf{r} and the third dimension of \textbf{interpolationStencil}
                           should have $n_1\ge\textbf{numberOfDimensions}()-1$.
      \item{\textbf{interpolationStencil} (OUTPUT)} Dimensions:  $(N,0\colon2,0\colon n_1)$\\*
                           The ranges of indices of interpolee points on grid \textbf{k2}.
      \item{\textbf{useBackupRules} (INPUT)} Dimensions:  $(N)$\\*
                           An array of flags to indicate which points use backup interpolation rules.
    \end{description}
    This function computes the index bounds on stencils of points used for interpolation.  If grid \textbf{k1} is a refinement grid, then
    the interpolation stencil may contain points from more then one component grid.  In particular, it may contain points from grid \textbf{k2}
    and/or any of its sibling component grids (refinements of the same base grid at the same refinement level).  For this case, it is necessary to call the
    variant of \textbf{getInterpolationStencil}() which takes the base grid as an argument.

%  \subsubsection{\mbox{Logical canInterpolate(const Integer\&~k1,} \mbox{const Integer\&~k2,} \mbox{const RealArray\&~r,} \mbox{const LogicalArray\&~useBackupRules,} \mbox{const LogicalArray\&~ok,} \protect\goodbreak\mbox{const Logical checkForOneSided~=~LogicalFalse)}}
%  \label{CompositeGrid::canInterpolate(k1,k2,r,iab,useBackupRules,checkForOneSided)}
%    \begin{description}
%      \item{\textbf{g}       (INPUT)} The unrefined grid corresponding to grid \textbf{k2}.
%      \item{\textbf{g\_mask} (INPUT)} A collection of gridpoint masks on grid \textbf{k2} and/or its siblings.
%      \item{\textbf{k1}      (INPUT)} The index of the grid containing the interpolation points.
%      \item{\textbf{k2}      (INPUT)} The index of the grid containing the interpolee points.
%      \item{\textbf{r}       (INPUT)} Dimensions:  $(N,0\colon n_1)$\\*
%                                The interpolation coordinates of the interpolation points.
%                                The range of points $N$ for which the boundary is adjusted is determined
%                                by the first dimension of \textbf{r}.  The first dimension of
%                                \textbf{ok} and \textbf{useBackupRules} should be
%                                the same as the first the dimension of \textbf{r}.  The second dimension of
%                                \textbf{r} should have $n_1\ge\textbf{numberOfDimensions}()-1$.
%      \item{\textbf{ok} (INPUT/OUTPUT)} Dimensions:  $(N)$\\*
%                                An array of flags to indicate on input which points should be processed, and to indicate on output
%                                which of those points processed can interpolate from grid \textbf{k2}.  Only those points $i$
%                                are processed for which $\textbf{ok}(i)\ne\textbf{LogicalFalse}$ (zero) initially.  Of these
%                                points $i$, $\textbf{ok}(i)=\textbf{LogicalTrue}$ (non-zero) on output only for those points
%                                which can interpolate from grid \textbf{k2}.
%      \item{\textbf{useBackupRules} (INPUT)} Dimensions:  $(N)$\\*
%                                An array of flags to indicate which points use backup interpolation rules.
%      \item{\textbf{checkForOneSided} (INPUT)} A flag that indicates whether to allow non-centered interpolation of points
%                                from interpolation stencils that include interior boundary points.
%    \end{description}
%    Determine which points on grid \textbf{k1} can be interpolated from grids \textbf{k2}.  If grid \textbf{k1} is a refinement grid, then
%    the interpolation stencil may contain points from more then one component grid.  In particular, it may contain points from grid \textbf{k2}
%    and/or any of its sibling component grids (refinements of the same base grid at the same refinement level).  For this case, it is necessary to call the
%    variant of \textbf{canInterpolate}() which takes the base grid as an argument.  Only those sibling component grids are considered whose gridpoint masks
%    are included in the collection \textbf{g\_mask}.

%  \subsubsection{\mbox{void isInteriorBoundaryPoint(const Integer\&~k1,} \mbox{const Integer\&~k2,} \mbox{const IntegerArray\&~i1,}
%    \mbox{const RealArray\&~r2,} \mbox{const LogicalArray\&~ok)}}
%  \label{CompositeGrid::isInteriorBoundaryPoint(k1,k2,i1,r2,ok)}
%    \begin{description}
%      \item{\textbf{k1} (INPUT)} The \textbf{MappedGrid} whose gridpoint indices are given by \textbf{i1}.
%      \item{\textbf{k2} (INPUT)} The \textbf{MappedGrid} whose inverse mapping was used to compute \textbf{rx2}.
%      \item{\textbf{i1} (INPUT)} Dimensions:  $(N,0\colon n_1)$\\*
%                                    The indices of points on grid k1.
%                                    The range of points $N$ for which the boundary is adjusted is determined
%                                    by the first dimension of \textbf{i1}.  The first dimension of
%                                    \textbf{r2} and \textbf{ok} should be the same as the first
%                                    the dimension of \textbf{i1}.  The second dimension of \textbf{i1}
%                                    and \textbf{r2} should have $n_1\ge\textbf{numberOfDimensions}()-1$.
%      \item{\textbf{r2} (INPUT)} Dimensions:  $(N,0\colon n_1)$\\*
%                                    The coordinates on grid \textbf{k2} of points on grid k1.
%      \item{\textbf{ok} (INPUT/OUTPUT)} Dimensions:  $(N)$\\*
%                                    An array of flags to indicate on input which points should be processed, and to indicate on output
%                                    which of those points processed lie in the interior of grid \textbf{k2}.  Only those points $i$
%                                    are processed for which $\textbf{ok}(i)\ne\textbf{LogicalFalse}$ (zero) initially.  Of these
%                                    points $i$, $\textbf{ok}(i)=\textbf{LogicalTrue}$ (non-zero) on output only for those points
%                                    which lie in the interior of grid \textbf{k2}.
%    \end{description}
%    This function checks if these boundary discretization points of grid $k1$ lie at least epsilon inside the parameter space of grid k2.

%  \subsubsection{\mbox{void adjustBoundary(const Integer\&~k1,} \mbox{const Integer\&~k2,} \mbox{const IntegerArray\&~i1,} \mbox{const RealArray\&~x)}}
%  \label{CompositeGrid::adjustBoundary(k1,k2,i1,x)}
%    \begin{description}
%      \item{\textbf{k1} (INPUT)} The index of the grid containing the points \textbf{i1}.
%      \item{\textbf{k2} (INPUT)} The index of the base grid corresponding to the grid whose inverse mapping will be used.
%      \item{\textbf{i1} (INPUT)} Dimensions:  $(N,0\colon n_1)$\\*
%                           The indices of points on grid \textbf{k1} where the inverse mapping of grid \textbf{k2} was computed.
%                           The first dimension of \textbf{x} should be the same as the first the dimension of \textbf{i1}.
%                           The second dimension of \textbf{i1} and \textbf{x} should have $n_1\ge\textbf{numberOfDimensions}()-1$.
%      \item{\textbf{x}  (INPUT/OUTPUT)} Dimensions:  $(N,0\colon n_1)$\\*
%                           The position of points on grid \textbf{k1} where the inverse mapping of grid \textbf{k2} was computed.
%    \end{description}
%    Adjust the position of points on grid \textbf{k1} to take into account the mismatch between those of its boundaries
%    which are shared with base grid \textbf{k2}.
%    The position of a point is adjusted so that if it is a boundary point, then it will lie exactly on the
%    boundary of base grid \textbf{k2}, and if not, then it is adjusted by a fraction of the correction at the
%    boundary, proportional to the dot product of the vector from the given point to the corresponding point on the opposite
%    boundary of grid \textbf{k1} with the vector between the corresponding points on the near and opposite boundaries.
%%    \beginExample
%%      \textbf{CompositeGrid} g(2,2); g.\textbf{update}(\textbf{THEcenter}); & // Construct a \textbf{CompositeGrid}   \\
%%      const Integer k1 = 0, k2 = 1, \&nd = g.\textbf{numberOfDimensions}();       & // with two two-dimensional grids.         \\
%%      \textbf{IntegerArray} i1(1,nd); \textbf{RealArray} x(1,nd), r2(1,nd);    & // Construct some arrays.                  \\
%%      i1 = 0;                                                                        & // Use the gridpoint (0,0).                \\
%%      for (Integer kd=0; kd$<$nd; kd++)                                              & // Get the coordinates of the gridpoints   \\
%%      \ \ \ \ x(0,kd) = g[k1].\textbf{center}()(i1(0,0), i1(0,1), i1(0,2), kd);   & // at the indices given by i1.             \\
%%      g.\textbf{adjustBoundary}(k1, k2, i1, x);                                   & // Adjust x for the boundaries of grid k2. \\
%%      g2.\textbf{mapping}().\textbf{inverseMap}(x, r2);                        & // Invert the mapping of g2 at this point. \\
%%    \endExample

\subsection{Public Member functions for access to data}
\label{CompositeGrid::PublicAccessToData}

  \subsubsection{Integer\& numberOfCompleteMultigridLevels()}
  \label{CompositeGrid::numberOfCompleteMultigridLevels() const}
    This function returns a reference to the number of complete multigrid levels,
    the number of multigrid levels at which a complete set of component grids exists.
    Interpolation is in general possible on complete multigrid levels.

  \subsubsection{Real\& epsilon()}
  \label{CompositeGrid::epsilon() const}
    This function returns a reference to the tolerance used in computing interpolation stencils.

  \subsubsection{Logical\& interpolationIsAllExplicit()}
  \label{CompositeGrid::interpolationIsAllExplicit() const}
    This function returns a reference to a flag that indicates whether all interpolation is guaranteed to be explicit.
    This flag is always recomputed by the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}.

  \subsubsection{Logical\& interpolationIsAllImplicit()}
  \label{CompositeGrid::interpolationIsAllImplicit() const}
    This function returns a reference to a flag that indicates whether all interpolation is allowed to be implicit.
    This flag is always recomputed by the function
    {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}.

  \subsubsection{virtual aString getClassName() const}
  \label{CompositeGrid::getClassName() const}
    Get the class name of the most-derived class for this object.

  \subsubsection{CompositeGridData$*$ operator${-}{>}$()}
  \label{CompositeGrid::operator->()}
    Access the reference-counted data.

  \subsubsection[CompositeGridData\& operator$*$()]
  {CompositeGridData\& operator$*$()\hfill\break
  const CompositeGridData\& operator$*$() const}
  \label{CompositeGrid::operator*()}
    Access the pointer to the reference-counted data.

\subsection{Public member functions called only from derived classes}
\label{CompositeGrid::PublicDerivedClassMemberFunctions}

It is recommended that these functions be called only from derived classes.

  \subsubsection{void reference(CompositeGridData\&~x)}
  \label{CompositeGrid::reference(CompositeGridData_x)}
    Make a reference to an object of type \textbf{CompositeGridData}.
    This \textbf{CompositeGrid} uses \textbf{x} for its data.
    It is recommended that this function be called only from derived classes.

  \subsubsection{void updateReferences(const Integer what~=~EVERYTHING)}
  \label{CompositeGrid::updateReferences(what)}
    Update references to the reference-counted data.
    It is recommended that this function be called only from derived classes.

  \subsubsection{virtual void setNumberOfGrids(const Integer\&~numberOfGrids\_)}
  \label{CompositeGrid::setNumberOfGrids(numberOfGrids_)}
    Set the number of grids, and add or delete grids to/from this collection until there are \textbf{numberOfGrids\_} grids.
    See also {\bf{}\hyperref{setNumberOfDimensionsAndGrids(numberOfDimensions\_, numberOfGrids\_)}{setNumberOfDimensionsAndGrids(numberOfDimensions\_, numberOfGrids\_) \rm(\S}{)}{CompositeGrid::setNumberOfDimensionsAndGrids(numberOfDimensions_, numberOfGrids_)}}.
    It is recommended that this function be called only from derived classes.

  \subsubsection{virtual void setNumberOfDimensions(const Integer\&~numberOfDimensions\_)}
  \label{CompositeGrid::setNumberOfDimensions(numberOfDimensions)}
    Set the number of dimensions.  This is valid only if the collection does not contain \textbf{MappedGrid}s with a different number of dimensions.
    See also {\bf{}\hyperref{setNumberOfDimensionsAndGrids(numberOfDimensions\_, numberOfGrids\_)}{setNumberOfDimensionsAndGrids(numberOfDimensions\_, numberOfGrids\_) \rm(\S}{)}{CompositeGrid::setNumberOfDimensionsAndGrids(numberOfDimensions_, numberOfGrids_)}}.
    It is recommended that this function be called only from derived classes.

  \subsubsection{virtual void setNumberOfDimensionsAndGrids(const Integer\&~numberOfDimensios\_, const Integer\&~numberOfGrids\_)}
  \label{CompositeGrid::setNumberOfDimensionsAndGrids(numberOfDimensions_, numberOfGrids_)}
    Set the number of dimensions of the grids, and add or delete grids to/from this collection until there are \textbf{numberOfGrids\_} grids.
    Any grids added are marked as belonging to base grid zero, multigrid level zero and refinement level zero.
    The use of this function is not recommended if the collection is intended to contain more than one
    base grid, multigrid level or refinement level.  For example,
    if the collection is intended to contain more than one refinement level, it is recommended that the functions
    {\bf{}\hyperref{addRefinement(range,factor,level,k)}{addRefinement(range,factor,level,k) \rm(\S}{)}{CompositeGrid::addRefinement(range,IntegerArray_factor,level,k)}} and
    {\bf{}\hyperref{deleteRefinementLevels(level)}{deleteRefinementLevels(level) \rm(\S}{)}{CompositeGrid::deleteRefinementLevels(level)}}
    be used instead.
    It is recommended that this function be called only from derived classes.

\subsection{Public data}
\label{CompositeGrid::PublicData}

  \subsubsection{IntegerArray numberOfInterpolationPoints}
  \label{CompositeGrid::numberOfInterpolationPoints}
    Dimensions: $(0\colon2,0\colon\textbf{numberOfGrids}()-1)$ \\*[\parskip]
    The number of interpolation points on each component grid.

  \subsubsection{IntegerArray numberOfInterpoleePoints}
  \label{CompositeGrid::numberOfInterpoleePoints}
    Dimensions: $(0\colon2,0\colon\textbf{numberOfGrids}()-1)$ \\*[\parskip]
    The number of interpolee stencil points on each component grid, in stencils that contain points from more than one interpolee grid.

  \subsubsection{LogicalArray interpolationIsImplicit}
  \label{CompositeGrid::interpolationIsImplicit}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The type of interpolation (to-grid, from-grid, multigrid-level).

  \subsubsection{LogicalArray backupInterpolationIsImplicit}
  \label{CompositeGrid::backupInterpolationIsImplicit}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The type of interpolation (to-grid, from-grid, multigrid-level) when using backup interpolation rules.

  \subsubsection{IntegerArray interpolationWidth}
  \label{CompositeGrid::interpolationWidth}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The width of the interpolation stencil (direction, to-grid, from-grid, multigrid-level).

  \subsubsection{IntegerArray backupInterpolationWidth}
  \label{CompositeGrid::backupInterpolationWidth}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The width of the interpolation stencil (direction, to-grid, from-grid, multigrid-level) when using backup interpolation rules.

  \subsubsection{RealArray interpolationOverlap}
  \label{CompositeGrid::interpolationOverlap}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The minimum overlap for interpolation (direction, to-grid, from-grid, multigrid-level).

  \subsubsection{RealArray backupInterpolationOverlap}
  \label{CompositeGrid::backupInterpolationOverlap}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The minimum overlap for interpolation (direction, to-grid, from-grid, multigrid-level) when using backup interpolation rules.

  \subsubsection{RealArray interpolationConditionLimit}
  \label{CompositeGrid::interpolationConditionLimit}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The maximum interpolation condition number allowed for interpolation (to-grid, from-grid, multigrid-level).

  \subsubsection{RealArray backupInterpolationConditionLimit}
  \label{CompositeGrid::backupInterpolationConditionLimit}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The maximum interpolation condition number allowed for interpolation (to-grid, from-grid, multigrid-level) when using backup interpolation rules.

  \subsubsection{LogicalArray interpolationPreference}
  \label{CompositeGrid::interpolationPreference}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    A list of the indices of component grids from which each component grid may interpolate (list, to-grid, multigrid-level), in increasing order of preference.
    Discretization must be included in this list, and is indicated by the component-grid index ``to-grid.''
    The list is terminated by $-1$ if there are fewer than \textbf{numberOfComponentGrids}() grids in the list.

  \subsubsection{LogicalArray mayInterpolate}
  \label{CompositeGrid::mayInterpolate}
    Dimensions: $(0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    Flags indicating which component grids may interpolate from each other (to-grid, from-grid, multigrid-level).

  \subsubsection{LogicalArray mayBackupInterpolate}
  \label{CompositeGrid::mayBackupInterpolate}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    Flags indicating which grids may interpolate from each other (to-grid, from-grid, multigrid-level) when using backup interpolation rules.

  \subsubsection{LogicalArray mayCutHoles}
  \label{CompositeGrid::mayCutHoles}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1,0\colon\textbf{numberOfComponentGrids}()-1)$ \\*[\parskip]
    Flags indicating which component grids may cut holes in each other (cutting-grid, cut-grid, multigrid-level), where the boundary of one
    grid intersects the interior of another grid and that boundary is labelled as a domain boundary.  Normally, all sides of grids labelled
    as domain boundaries are used to cut holes in all other grids.

  \subsubsection{LogicalArray multigridCoarseningRatio}
  \label{CompositeGrid::multigridCoarseningRatio}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1,0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    \textbf{multigridCoarseningRatio} holds the ratio in each index direction, for each component grid, of the size of cells of that grid
    to the size of cells of the next-finer multigrid level of the same component grid.

  \subsubsection{LogicalArray multigridProlongationWidth}
  \label{CompositeGrid::multigridProlongationWidth}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1,0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    \textbf{multigridProlongationWidth} holds the stencil width in each index direction, for each component grid for the multigrid
    prolongation operator used to transfer data to the next-finer multigrid level of the same component grid.
    For the finest multigrid level (level zero), this parameter has no meaning.

  \subsubsection{LogicalArray multigridRestrictionWidth}
  \label{CompositeGrid::multigridRestrictionWidth}
    Dimensions: $(0\colon2$, $0\colon\textbf{numberOfComponentGrids}()-1,0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    \textbf{multigridRestrictionWidth} holds the stencil width in each index direction, for each component grid for the multigrid
    restriction operator used to transfer data to the next-coarser multigrid level of the same component grid.
    For the coarsest multigrid level, this parameter has no meaning.

  \subsubsection{ListOfRealArray interpolationCoordinates}
  \label{CompositeGrid::interpolationCoordinates}
    Length: {\bf{}\hyperref{numberOfGrids()}{numberOfGrids() \rm(\S}{)}{GenericGridCollection::numberOfGrids() const}} \\*[\parskip]
    Dimensions of \textbf{interpolationCoordinates}[k]:
    $(0\colon\textbf{numberOfInterpolationPoints}(k)-1$, $0\colon\textbf{numberOfDimensions}()-1)$ \\*[\parskip]
    \textbf{interpolationCoordinates} holds the coordinates of each interpolation point in the parameter space of its interpolee grid.

  \subsubsection{ListOfIntegerArray interpoleeGrid}
  \label{CompositeGrid::interpoleeGrid}
    Length: {\bf{}\hyperref{numberOfGrids()}{numberOfGrids() \rm(\S}{)}{GenericGridCollection::numberOfGrids() const}} \\*[\parskip]
    Dimensions of \textbf{interpoleeGrid}[k]: $(0\colon\textbf{numberOfInterpolationPoints}(k)-1)$ \\*[\parskip]
    \textbf{interpoleeGrid} holds the component-grid number of the interpolee grid of each interpolation point.  If the interpolation
    stencil for interpolation point $j$ contains points from more than one interpolee grid, then the expression
    $\textbf{interpoleeGrid}[k](j) \& \textbf{CompositeGrid}\colon\colon\textbf{ISgivenByInterpoleePoint}$ is non-zero, and the
    expression $\textbf{interpoleeGrid}[k](j)\&\textbf{CompositeGrid}\colon\colon\textbf{GRIDnumberBits}$ gives the
    nominal interpolee grid number.  In that case, the interpolation coordinates should be interpreted in the context of the nominal interpolee
    grid.  It may happen that the interpolation coordinates lie outside the interval $[0,1]$.  This is not an error, but indicates only that
    the interpolation point lies outside the nominal interpolee grid even though it lies within the stencil of interpolee points on their
    various respective grids.  For each interpolation stencil that contain points from more than one interpolee grid, the interpolee component-grid
    number of each point in the interpolation stencil is stored in
    {\bf{}\hyperref{interpoleePoint$[k]$}{interpoleePoint$[k]$ \rm(\S}{)}{CompositeGrid::interpoleePoint}}.

  \subsubsection{IntegerArray interpoleeGridRange}
  \label{CompositeGrid::interpoleeGridRange}
    Dimensions: $(0\colon\textbf{numberOfComponentGrids}()$, $0\colon\textbf{numberOfComponentGrids}()-1$, $0\colon\textbf{numberOfMultigridLevels}()-1)$ \\*[\parskip]
    The starting index within \textbf{interpoleeGrid}[$k$], where grid $k$ is component grid $k_2$ at multigrid level $l$, for points interpolated
    from component grid $k_1$ is $\textbf{interpoleeGridRange}(k_1,k_2,l)$, and the ending index is $\textbf{interpoleeGridRange}(k_1+1,k_2,l)-1$.
    For all indices $i$ within this range, $\textbf{interpoleeGrid}[k](i) = k_2$.
    These index ranges do not include the indices of any points whose interpolation stencils contain interpolee points from more than one grid.
    However, as these are always the last interpolation points listed, it is not hard to see that the starting index of such points is
    $\textbf{interpoleeGridRange}(\textbf{numberOfComponentGrids},k_2,l)$, and the ending index is $\textbf{numberOfInterpolationPoints}(k_2)-1$.

  \subsubsection{ListOfIntegerArray interpoleePoint}
  \label{CompositeGrid::interpoleePoint}
    Length: {\bf{}\hyperref{numberOfGrids()}{numberOfGrids() \rm(\S}{)}{GenericGridCollection::numberOfGrids() const}} \\*[\parskip]
    Dimensions of \textbf{interpoleePoint}[k]: $(0\colon\textbf{numberOfInterpoleePoints}(k)-1)$ \\*[\parskip]
    \textbf{interpoleePoint} holds the component-grid number of the interpolee grid of each interpolee point in those interpolation stencils
    which contain points from more than one interpolee grid.  These component-grid numbers are listed in order of increasing $i1$, then increasing
    $i2$, and then increasing $i3$, where $(i1,i2,i3)$ are the indices of the interpolee points in their stencil, and finally, in the order that
    the multiple-interpolee-grid interpolation stencils are encountered in
    {\bf{}\hyperref{interpoleeGrid$[k]$}{interpoleeGrid$[k]$ \rm(\S}{)}{CompositeGrid::interpoleeGrid}}.

  \subsubsection{ListOfIntegerArray interpoleeLocation}
  \label{CompositeGrid::interpoleeLocation}
    Length: {\bf{}\hyperref{numberOfGrids()}{numberOfGrids() \rm(\S}{)}{GenericGridCollection::numberOfGrids() const}} \\*[\parskip]
    Dimensions of \textbf{interpoleeLocation}[k]:
    $(0\colon\textbf{numberOfInterpolationPoints}(k)-1$, $0\colon\textbf{numberOfDimensions}()-1)$ \\*[\parskip]
    \textbf{interpoleeLocation} holds the indices (in the interpolee grid) of the lower-left corner of the interpolation stencil for each interpolation point.

  \subsubsection{ListOfIntegerArray interpolationPoint}
  \label{CompositeGrid::interpolationPoint}
    Length: {\bf{}\hyperref{numberOfGrids()}{numberOfGrids() \rm(\S}{)}{GenericGridCollection::numberOfGrids() const}} \\*[\parskip]
    Dimensions of \textbf{interpolationPoint}[k]:
    $(0\colon\textbf{numberOfInterpolationPoints}(k)-1$, $0\colon\textbf{numberOfDimensions}()-1)$ \\*[\parskip]
    \textbf{interpolationPoint} holds the indices (in the grid of the interpolation point) of each interpolation point.

  \subsubsection{ListOfRealArray interpolationCondition}
  \label{CompositeGrid::interpolationCondition}
    Length: {\bf{}\hyperref{numberOfGrids()}{numberOfGrids() \rm(\S}{)}{GenericGridCollection::numberOfGrids() const}} \\*[\parskip]
    Dimensions of \textbf{interpolationCondition}[k]: $(0\colon\textbf{numberOfInterpolationPoints}(k)-1)$ \\*[\parskip]
    \textbf{interpolationCondition} holds the condition number for interpolation of each interpolation point.

  \subsubsection{ListOfCompositeGrid multigridLevel} 
  \label{CompositeGrid::multigridLevel} 
    \textbf{multigridLevel} is a list of \textbf{CompositeGrid}s containing those \textbf{MappedGrid}s which belong to the same multigrid level.
    \textbf{multigridLevel} overloads
    {\bf{}\hyperref{GridCollection::multigridLevel}{GridCollection::multigridLevel \rm(\S}{)}{GridCollection::multigridLevel}},
    whose \textbf{GridCollection}s contain the same grids as the \textbf{CompositeGrid}s of \textbf{multigridLevel}.
    This data may be updated as in the following example.
%    \beginExample
%      \textbf{CompositeGrid} g;                                        & // Construct a \textbf{CompositeGrid}. \\
%      g.\textbf{update}(\textbf{CompositeGrid::THEmultigridLevel}); & // Update \textbf{multigridLevel}.     \\
%    \endExample

\subsection{Public data used by the Grid Generator Ogen}
\label{CompositeGrid::PublicCgshData}

Data used by class Ogen for optimization of overlap computation.

  \subsubsection{RealCompositeGridFunction inverseCondition}
  \label{CompositeGrid::inverseCondition}
    Dimensions of \textbf{inverseCondition}[$k$]: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12})$,
    where $d_{ij} = \textbf{grid}[$k$].\textbf{dimension}(i,j)$. \\*[\parskip]
    \textbf{inverseCondition} holds the condition number for interpolation of each point, in case that point were to be interpolated from the
    grid whose index is given by {\bf{}\hyperref{inverseGrid}{inverseGrid \rm(\S}{)}{CompositeGrid::inverseGrid}}.

  \subsubsection{RealCompositeGridFunction inverseCoordinates}
  \label{CompositeGrid::inverseCoordinates}
    Dimensions of \textbf{inverseCoordinates}[$k$]: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12},0\colon n_1)$,
    where $d_{ij} = \textbf{grid}[$k$].\textbf{dimension}(i,j)$ and $n_1 = \textbf{numberOfDimensions}() - 1$. \\*[\parskip]
    \textbf{inverseCoordinates} holds the coordinates for interpolation of each point, in case that point were to be interpolated from the
    grid whose index is given by {\bf{}\hyperref{inverseGrid}{inverseGrid \rm(\S}{)}{CompositeGrid::inverseGrid}}.

  \subsubsection{IntegerCompositeGridFunction inverseGrid}
  \label{CompositeGrid::inverseGrid}
    Dimensions of \textbf{inverseGrid}[$k$]: $(d_{00}\colon d_{10},d_{01}\colon d_{11},d_{02}\colon d_{12})$,
    where $d_{ij} = \textbf{grid}[$k$].\textbf{dimension}(i,j)$. \\*[\parskip]
    \textbf{inverseGrid} holds, for each point, the index of a grid for which interpolation coordinates have been computed,
    in case that point were to be interpolated from that grid.
    The index $-1$ is used to indicate the case where interpolation coordinates have not been or cannot be computed.

\subsection{Public data used only by derived classes}
\label{CompositeGrid::PublicDerivedClassData}

It is recommended that these variables be used only by derived classes.

  \subsubsection{CompositeGridData$*$ rcData}
  \label{CompositeGrid::rcData}
    \textbf{rcData} is a pointer to the reference-counted data.
    It is recommended that this variable be used only by derived classes.
    See also the member functions
    {\bf{}\hyperref{operator${-}{>}$()}{operator${-}{>}$() \rm(\S}{)}{CompositeGrid::operator->()}}
    and {\bf{}\hyperref{operator$*$()}{operator$*$() \rm(\S}{)}{CompositeGrid::operator*()}},
    which are provided for access to \textbf{rcData}.

  \subsubsection{Logical isCounted}
  \label{CompositeGrid::isCounted}
    \textbf{isCounted} is
    a flag that indicates whether the data pointed to by {\bf{}\hyperref{rcData}{rcData \rm(\S}{)}{CompositeGrid::rcData}} is known to be reference-counted.
    It is recommended that this variable be used only by derived classes.

\subsection{Public constants}
\label{CompositeGrid::PublicConstants}

  \subsubsection{THEinterpolationCoordinates}
  \label{CompositeGrid::THEinterpolationCoordinates}
    \textbf{THEinterpolationCoordinates} indicates
    {\bf{}\hyperref{interpolationCoordinates}{interpolationCoordinates \rm(\S}{)}{CompositeGrid::interpolationCoordinates}},
    the coordinates of the inteprolation points in the parameter space of the grids from which they interpolate.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{THEinterpoleeGrid}
  \label{CompositeGrid::THEinterpoleeGrid}
    \textbf{THEinterpoleeGrid} indicates {\bf{}\hyperref{interpoleeGrid}{interpoleeGrid \rm(\S}{)}{CompositeGrid::interpoleeGrid}},
    the indices of the grids from which the inteprolation points interpolate.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{THEinterpoleeLocation}
  \label{CompositeGrid::THEinterpoleeLocation}
    \textbf{THEinterpoleeLocation} indicates {\bf{}\hyperref{interpoleeLocation}{interpoleeLocation \rm(\S}{)}{CompositeGrid::interpoleeLocation}},
    the indices of the lower-left corners of the interpolation stencils
    in the grids from which the inteprolation points interpolate.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{THEinterpolationPoint}
  \label{CompositeGrid::THEinterpolationPoint}
    \textbf{THEinterpolationPoint} indicates {\bf{}\hyperref{interpolationPoint}{interpolationPoint \rm(\S}{)}{CompositeGrid::interpolationPoint}},
    the indices of the interpolation points.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{THEinterpolationCondition}
  \label{CompositeGrid::THEinterpolationCondition}
    \textbf{THEinterpolationCondition} indicates
    {\bf{}\hyperref{interpolationCondition}{interpolationCondition \rm(\S}{)}{CompositeGrid::interpolationCondition}},
    the condition numbers for interpolation of the interpolation points.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{THEinverseMap}
  \label{CompositeGrid::THEinverseMap}
    \textbf{THEinverseMap} indicates
    {\bf{}\hyperref{inverseCondition}{inverseCondition \rm(\S}{)}{CompositeGrid::inverseCondition}},
    {\bf{}\hyperref{inverseCoordinates}{inverseCoordinates \rm(\S}{)}{CompositeGrid::inverseCoordinates}} and
    {\bf{}\hyperref{inverseGrid}{inverseGrid \rm(\S}{)}{CompositeGrid::inverseGrid}}.
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{THEusualSuspects}
  \label{CompositeGrid::THEusualSuspects}
    \textbf{THEusualSuspects}
    =      {\bf{}\hyperref{GridCollection::THEusualSuspects}{GridCollection::THEusualSuspects \rm(\S}{)}{GridCollection::THEusualSuspects}}
    $\mid$ {\bf{}\hyperref{THEinterpolationCoordinates}{THEinterpolationCoordinates \rm(\S}{)}{CompositeGrid::THEinterpolationCoordinates}}
    $\mid$ {\bf{}\hyperref{THEinterpoleeGrid}{THEinterpoleeGrid \rm(\S}{)}{CompositeGrid::THEinterpoleeGrid}}
    $\mid$ {\bf{}\hyperref{THEinterpoleeLocation}{THEinterpoleeLocation \rm(\S}{)}{CompositeGrid::THEinterpoleeLocation}}
    $\mid$ {\bf{}\hyperref{THEinterpolationPoint}{THEinterpolationPoint \rm(\S}{)}{CompositeGrid::THEinterpolationPoint}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{EVERYTHING}
  \label{CompositeGrid::EVERYTHING}
    \textbf{EVERYTHING}
    =      {\bf{}\hyperref{GridCollection::EVERYTHING}{GridCollection::EVERYTHING \rm(\S}{)}{GridCollection::EVERYTHING}}
    $\mid$ {\bf{}\hyperref{THEinterpolationCoordinates}{THEinterpolationCoordinates \rm(\S}{)}{CompositeGrid::THEinterpolationCoordinates}}
    $\mid$ {\bf{}\hyperref{THEinterpoleeGrid}{THEinterpoleeGrid \rm(\S}{)}{CompositeGrid::THEinterpoleeGrid}}
    $\mid$ {\bf{}\hyperref{THEinterpoleeLocation}{THEinterpoleeLocation \rm(\S}{)}{CompositeGrid::THEinterpoleeLocation}}
    $\mid$ {\bf{}\hyperref{THEinterpolationPoint}{THEinterpolationPoint \rm(\S}{)}{CompositeGrid::THEinterpolationPoint}}
    $\mid$ {\bf{}\hyperref{THEinterpolationCondition}{THEinterpolationCondition \rm(\S}{)}{CompositeGrid::THEinterpolationCondition}}
    $\mid$ {\bf{}\hyperref{THEinverseMap}{THEinverseMap \rm(\S}{)}{CompositeGrid::THEinverseMap}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{COMPUTEtheUsual}
  \label{CompositeGrid::COMPUTEtheUsual}
    \textbf{COMPUTEtheUsual} =
    {\bf{}\hyperref{GridCollection::COMPUTEtheUsual}{GridCollection::COMPUTEtheUsual \rm(\S}{)}{GridCollection::COMPUTEtheUsual}} \\*[\parskip]
    See also {\bf{}\hyperref{update(what,how)}{update(what,how) \rm(\S}{)}{CompositeGrid::update(what,how)}}
    and {\bf{}\hyperref{destroy(what)}{destroy(what) \rm(\S}{)}{CompositeGrid::destroy(what)}}.

  \subsubsection{ISgivenByInterpoleePoint}
  \label{CompositeGrid::ISgivenByInterpoleePoint}
    \textbf{ISgivenByInterpoleePoint} is used with
    {\bf{}\hyperref{interpoleeGrid$[k]$}{interpoleeGrid$[k]$ \rm(\S}{)}{CompositeGrid::interpoleeGrid}}
    to indicate interpolation points whose interpolation stencils contain points from more than one interpolee grid.

\appendix % Every \section after this is an appendix.

\section{Class ReferenceCounting}
\label{ReferenceCounting}

\subsection{Public member functions}
\label{ReferenceCounting::PublicMemberFunctions}

  \subsubsection{ReferenceCounting()}
  \label{ReferenceCounting::ReferenceCounting()}
    Default constructor.

  \subsubsection{ReferenceCounting(const ReferenceCounting\&~x, const CopyType ct~=~DEEP)}
  \label{ReferenceCounting::ReferenceCounting(x,ct)}
    Copy constructor.  This does a deep copy by default.  In fact, for class \textbf{ReferenceCounting},
    there is no data to be copied, so the arguments $x$ and $ct$ are ignored.

  \subsubsection{virtual $\sim$ReferenceCounting()}
  \label{ReferenceCounting::tilde_ReferenceCounting()}
    Destructor.  This function checks that the actual number of references is zero, as it should be when the object is destroyed.

  \subsubsection{virtual ReferenceCounting\& operator=(const ReferenceCounting\&~x)}
  \label{ReferenceCounting::operator=(x)}
    Assignment operator.  This is also called a deep copy.

  \subsubsection{virtual void reference(const ReferenceCounting\&~x)}
  \label{ReferenceCounting::reference(ReferenceCounting)}
    Make a reference.  This is also called a shallow copy.  This \textbf{ReferenceCounting} shares the data of \textbf{x}.
    In fact, this virtual function does nothing at all in the base class \textbf{ReferenceCounting}, but it should
    have the effect specified above when it is defined in any envelope class that is derived from \textbf{ReferenceCounting}.

  \subsubsection{virtual void breakReference()}
  \label{ReferenceCounting::breakReference()}
    Break a reference.  If this \textbf{ReferenceCounting} shares data with any other \textbf{ReferenceCounting},
    then this function replaces it with a new copy that does not share data.
    In fact, this virtual function does nothing at all in the base class \textbf{ReferenceCounting}, but it should
    have the effect specified above when it is defined in any envelope class that is derived from \textbf{ReferenceCounting}.

  \subsubsection{virtual ReferenceCounting$\sim$ virtualConstructor(const CopyType ct~=~DEEP) const}
  \label{ReferenceCounting::virtualConstructor(ct) const}
    Allocate and return a pointer to a new copy of this \textbf{ReferenceCounting}.  Any class that is derived from
    \textbf{ReferenceCounting} should also define this virtual function, so that this function will allocate a new
    copy of an object of the derived class.

  \subsubsection{Integer incrementReferenceCount()}
  \label{ReferenceCounting::incrementReferenceCount()}
    Increment the reference count and return the resulting value.

  \subsubsection{Integer decrementReferenceCount()}
  \label{ReferenceCounting::decrementReferenceCount()}
    Decrement the reference count and return the resulting value.

  \subsubsection{Logical uncountedReferencesMayExist()}
  \label{ReferenceCounting::uncountedReferencesMayExist()}
    This function determines whether uncounted references may exist.
    If so, it returns a non-zero value; otherwise it returns zero.
    If it is determined that uncounted references may exist, then
    {\bf{}\hyperref{getReferenceCount()}{getReferenceCount() \rm(\S}{)}{ReferenceCounting::getReferenceCount()}}
    thereafter returns one more than the actual number of references.  This is done so that when all of the counted references are destroyed and
    the actual number of references is decremented to zero, \textbf{getReferenceCount()} will still return the value one, to indicate that one
    or more uncounted references to the object may still exist and that the object should still not be deleted.

  \subsubsection{virtual void consistencyCheck() const}
  \label{ReferenceCounting::consistencyCheck() const}
    Check the consistency of this \textbf{ReferenceCounting}.

\subsection{Public Member functions for access to data}
\label{ReferenceCounting::PublicAccessToData}

  \subsubsection{Integer getReferenceCount()}
  \label{ReferenceCounting::getReferenceCount()}
    This function returns the reference count.

  \subsubsection{virtual aString getClassName() const}
  \label{ReferenceCounting::getClassName() const}
    Get the class name of the most-derived class for this object.

  \subsubsection{Integer getGlobalID() const}
  \label{ReferenceCounting::getGlobalID() const}
    Get the unique global identifier for this \textbf{ReferenceCounting}.

\section{Stream I/O}
\label{IOStream}

\subsection{Stream I/O Operators}
\label{IOStream::Operators}

  \subsubsection{ostream\& operator$\ll$(ostream\&~s, const ReferenceCounting\&~x)}
  \label{IOStream::operator<<(s,ReferenceCounting_x)}
    Stream output operator.

  \subsubsection{ostream\& operator$\ll$(ostream\&~s, const GenericGrid\&~g)}
  \label{IOStream::operator<<(s,GenericGrid_g)}
    Stream output operator.

  \subsubsection{ostream\& operator$\ll$(ostream\&~s, const MappedGrid\&~g)}
  \label{IOStream::operator<<(s,MappedGrid_g)}
    Stream output operator.

  \subsubsection{ostream\& operator$\ll$(ostream\&~s, const GenericGridCollection\&~g)}
  \label{IOStream::operator<<(s,GenericGridCollection_g)}
    Stream output operator.

  \subsubsection{ostream\& operator$\ll$(ostream\&~s, const GridCollection\&~g)}
  \label{IOStream::operator<<(s,GridCollection_g)}
    Stream output operator.

  \subsubsection{ostream\& operator$\ll$(ostream\&~s, const CompositeGrid\&~g)}
  \label{IOStream::operator<<(s,CompositeGrid_g)}
    Stream output operator.


\printindex

\end{document}
