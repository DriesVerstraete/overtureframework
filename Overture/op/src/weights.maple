# **********************************************************************
#    Output difference approximations to r,s,t derivatives
# **********************************************************************


# restart; read "weights.maple";
with(StringTools):

read "differenceWeights.maple";

nMax:=9:     # max stencil size
# nMax:=3:     # max stencil size

maxOrder:=6:  # 8
maxDer:=maxOrder:    

nd:=nMax-1:
md:=nd:

# compute difference weights for derivatives to various orders of accuracy, return results in c
computeDifferenceWeights(nd,md,c):



maxOrder := nMax-1:
for orderOfAccuracy from 2 by 2 to maxOrder do
# maxDeriv := nMax-1 - (orderOfAccuracy-2):
 maxDeriv:= md+2-orderOfAccuracy:

 printf("\n **** order of accuracy =%d *****\n",orderOfAccuracy):
 for derivative from 1 to maxDeriv do:
    n:= orderOfAccuracy+ 2*floor((derivative-1)/2):
    nn := n/2:
    printf(" Derivative %d [%d:%d]: ",derivative,-nn,nn);
    for i from -nn to nn do
     printf("%s, ",convert(getWeight(i,derivative,orderOfAccuracy),string));
   end do:
 printf("\n");

 end do:
end do:


# -----------
differenceApproximation :=proc( rDeriv,sDeriv,tDeriv, orderOfAccuracy, rName, drName )

 local i,j,k,n,r,indexName,vv,dn,cn,i1,i2,i3,is,ie,ii,dir,un,ext,e,cc:


 if rDeriv<>0 then
  k:=rDeriv:
  dir:=0:
#  rName:="r":
  ii := i1:
  is := "":
  ie := ",i2,i3$kd":

 elif sDeriv <>0 then
  k:=sDeriv:
  dir:=1:
#  rName:="s":
  ii := i2:
  is := "i1,":
  ie := ",i3$kd":
 else
  k:=tDeriv:
  dir:=2:
#  rName:="t":
  ii := i3:
  is := "i1,i2,":
  ie := "$kd":
 end if: 

 n:= orderOfAccuracy+ 2*floor((k-1)/2):  # order=2 -> nx=3 gives k=1,2  nx=5 gives k=3,4

 dn:=""; # name of the derivative
 for i from 1 to rDeriv do dn:=cat(dn,rName[1]):  end do:
 for i from 1 to sDeriv do dn:=cat(dn,rName[2]):  end do:
 for i from 1 to tDeriv do dn:=cat(dn,rName[3]):  end do:

 un:="u":  # here is the thing we differentitate
 ext:="": 
 if dir=0 then for i from 1 to sDeriv do ext:=cat(ext,rName[2]):  end do: end if:
 if dir=0 or dir=1 then for i from 1 to tDeriv do ext:=cat(ext,rName[3]):  end do: end if:
 if ext <> "" then  un:=cat(un," ## ",ext,orderOfAccuracy):  end if:   # change us -> us2 etc.
 
 e:="(": # holds the expression in a string
  
 r:=1; # find the lowest common multiple of the denominators
 for i from 0 to n do  r:=ilcm(r,denom(c[i,k,n])):  end do:
  
 for i from 0 to n do
   indexName := ii + i-n/2:   # index name "i1-1", "i1+2" etc
   if i>0 and c[i,k,n]>0 then  e:=cat(e,"+"); end if;
   if c[i,k,n] <> 0 then
     cn:=r*c[i,k,n]:
     if cn=-1 then e:=cat(e,"-"); elif cn<>1 then e:=cat(e,sprintf("%s.*",convert(cn,string))); end if;
     e:=cat(e,sprintf("%s(%s%s%s)",un,is,convert(indexName,string),ie));
   end if;
 end do:
 if r<>1 then e:=cat(e,sprintf(")/(%d.*",r)); else e:=cat(e,")/("); end if;
 if k>1 then e:=cat(e,sprintf("%s(%d)**%d)",drName,dir,k)); else e:=cat(e,sprintf("%s(%d))",drName,dir)); end if:

 if outputFile then
   fprintf(file,"  printout \"  u ## %s%d(i1,i2,i3$kd)=%s\\n\";\n",dn,orderOfAccuracy,e);
 end if:
 if components=0 then cc:="": elif components=1 then cc:=",m" elif components=2 then cc:=",m,n" else cc:=",l,m,n"; end if:
 e:= SubstituteAll(e,"$kd",cc):
 fprintf(mfile," #defineMacro u ## %s%d(i1,i2,i3%s) %s\n",dn,orderOfAccuracy,cc,e);

 RETURN(vv):
end:
# -------------

fileName:="defineParametricDeriv.new.pl":
file := fopen( fileName,WRITE ):

fprintf(file,"sub defineParametericDerivatives {\n"):
fprintf(file,"# This file was generated by weights.maple for inclusion in makeDifferenceMacros.p\n"):
fprintf(file,"# Define parametric derivatives ur, urr, us, urs, ...\n\n"):

mfileName:="defineParametricDerivMacros.h":
mfile := fopen( mfileName,WRITE ):

fprintf(mfile,"! This file was generated by weights.maple\n\n"):
fprintf(mfile,"#beginMacro defineParametricDerivativeMacros(u,dr,dx,DIM,ORDER,COMPONENTS,MAXDERIV)\n"):

rName := [ "r", "s", "t" ]:
xName := [ "x", "y", "z" ]:

for components from 0 to 2 do
 fprintf(mfile,"\n! *************** %d components *************\n",components):
 fprintf(mfile,"#If COMPONENTS == %d\n",components):

 if components=0 then outputFile:=true: else outputFile:=false: end if:

for orderOfAccuracy from 2 by 2 to maxOrder do

  printf(" *** order of accuracy = %d, components=%d ***\n",orderOfAccuracy,components):
  maxDerivative:= min(md+2-orderOfAccuracy,maxDer):

 if outputFile then 
   fprintf(file," if( $order eq '%d' )\n",orderOfAccuracy):
   fprintf(file," {\n"):
 end if:
 fprintf(mfile,"#If ORDER == %d\n",orderOfAccuracy):

 for k from 1 to maxDerivative do

   if outputFile then fprintf(file,"  printout \"#If MAXDERIV >= %d \\n\";\n",k): end if:
   fprintf(mfile,"#If MAXDERIV >= %d\n",k):

   for t from 0 to maxDerivative do
   for s from 0 to maxDerivative do
   for r from 0 to maxDerivative do
      if r+s+t = k then
        # printf(" derivative k=%d: r=%d s=%d t=%d\n",k,r,s,t):
        differenceApproximation(r,s,t,orderOfAccuracy,rName,"dr");
        differenceApproximation(r,s,t,orderOfAccuracy,xName,"dx");
      end if:
   end do:
   end do:
   end do:

   if outputFile then fprintf(file,"  printout \"#End\\n\";\n"); end if:
   fprintf(mfile,"#End\n");

 end do:

# for k from 1 to maxDerivative do   # for each derivative
#
#   differenceApproximation(k,orderOfAccuracy,0);
#   differenceApproximation(k,orderOfAccuracy,1);
#   differenceApproximation(k,orderOfAccuracy,2);
#
# end do:
 if outputFile then
   fprintf(file,"} #end order==%d\n",orderOfAccuracy);
 end if:
 fprintf(mfile,"#End\n\n"):
  
end do: # for orderOfAccuracy
fprintf(mfile,"#End\n\n"):
end do: # components

fprintf(file,"} # end sub defineParametericDerivatives\n\n"):
fprintf(file,"return true;\n"):
fprintf(mfile,"#endMacro\n"):


fclose(file):
printf(" **** output written to file [%s] ******\n",fileName);


# restart; read "weights.maple";

# **** now output some other macros for evaluating the derivatives and saving in temporaries

maxDerivative:= maxDer:

pdvars := "": # list of parametric derivative variables to be declared
dvars  :="":  # list of derivative variables to be declared
# -----------
addParVar :=proc( v )
  local w:
  if pdvars<>"" then  w:=cat(pdvars,",",v): else w:=v: end if:
RETURN(w):
end:
addVar :=proc( v )
  local w:
  if dvars<>"" then  w:=cat(dvars,",",v): else w:=v: end if:
RETURN(w):
end:
# -----------

for derivType from 0 to 1 do # r or x derivatives

for components from 0 to 2 do

if components=0 then cc:="": elif components=1 then cc:=",m" elif components=2 then cc:=",m,n" else cc:=",l,m,n"; end if:

if derivType=0 then
  fprintf(mfile,"\n! This next macro will evaluate parametric derivatives and save in temporaries\n"):
  fprintf(mfile,"!   u is the variable name, v is the prefix for the temporaries, e.g.\n"):
  fprintf(mfile,"!   For example, lines of the following form will be generated:\n"):
  fprintf(mfile,"!      v = u(i1,i2,i3) \n"):
  fprintf(mfile,"!      vr = ur4(i1,i2,i3) \n"):
  fprintf(mfile,"#beginMacro evalParametricDerivativesComponents%d(u,i1,i2,i3%s,v,DIM,ORDER,MAXDERIV)\n",components,cc):
  aName:=rName:

  # *** evaluate the function too for parametric derivatives
  fprintf(mfile,"v = u(i1,i2,i3%s)\n",cc):
  if components=0 then pdvars:=addParVar("v"): end if:

else
  fprintf(mfile,"\n! This next macro will evaluate x,y,z derivatives using temporaries already computed \n"):
  fprintf(mfile,"!   u1 is the variable name, aj the jaocbian name and v is the prefix for the temporaries\n"):
  fprintf(mfile,"!   For example, lines of the following form will be generated:\n"):
  fprintf(mfile,"!      getDuDx2(u1,aj,vx) \n"):
  fprintf(mfile,"!      getDuDxy2(u1,aj,vxy) \n"):
  fprintf(mfile,"!      getDuDxxx2(u1,aj,vxxx) \n"):
  fprintf(mfile,"#beginMacro evalDerivativesComponents%d(u,aj,v,DIM,ORDER,MAXDERIV)\n",components):
  aName:=xName:
end if:


 for dim from 2 to 3 do

 fprintf(mfile,"#If DIM == %d\n",dim):

 for k from 1 to maxDerivative do

   fprintf(mfile,"#If MAXDERIV >= %d\n",k):

   if dim=2 then maxDeriv3:=0 else maxDeriv3:=maxDerivative: end if:
   for tDeriv from 0 to maxDeriv3 do
   for sDeriv from 0 to maxDerivative do
   for rDeriv from 0 to maxDerivative do
      if rDeriv+sDeriv+tDeriv = k then

       dn:=""; # name of the derivative
       for i from 1 to rDeriv do dn:=cat(dn,aName[1]):  end do:
       for i from 1 to sDeriv do dn:=cat(dn,aName[2]):  end do:
       for i from 1 to tDeriv do dn:=cat(dn,aName[3]):  end do:
       dn:=convert(dn,string):
       if derivType=0 then
         fprintf(mfile,"v ## %s = u ## %s ## ORDER(i1,i2,i3%s)\n",dn,dn,cc):
         if components=0 and dim=3 then pdvars:=addParVar(sprintf("v ## %s",dn)): end if:
       else
         # fprintf(mfile,"v ## %s = u ## %s ## ORDER ## DIM(i1,i2,i3%s)\n",dn,dn,cc):
         fprintf(mfile,"getDuD%s ## DIM(u,aj,v ## %s)\n",dn,dn):
         if components=0 and dim=3 then dvars:=addVar(sprintf("v ## %s",dn)): end if:
       end if:

      end if:
   end do:
   end do:
   end do:

   fprintf(mfile,"#End\n");

 end do: # end k

 fprintf(mfile,"#End\n");

 end do: # dim 

fprintf(mfile,"#endMacro\n"):

end do: # components
end do: # derivType

rxName := array(1..3,1..3):
rxName[1,1]:="rx":
rxName[2,1]:="sx":
rxName[3,1]:="tx":
rxName[1,2]:="ry":
rxName[2,2]:="sy":
rxName[3,2]:="ty":
rxName[1,3]:="rz":
rxName[2,3]:="sz":
rxName[3,3]:="tz":

fprintf(mfile,"\n! This next macro will evaluate x,y,z derivatives of the jacobian \n"):
fprintf(mfile,"\n! u = jacobian name (rsxy), v=prefix for derivatives: vrxr, vrys, \n"):
fprintf(mfile,"#beginMacro evalJacobianDerivatives(u,i1,i2,i3,v,DIM,ORDER,MAXDERIV)\n",components):

for dim from 2 to 3 do

 fprintf(mfile,"#If DIM == %d\n",dim):

 # NOTE: eval all parametric before computing x,y,z derivatives since there is a dependency
 for m2 from 1 to dim do
 for m1 from 1 to dim do
  fprintf(mfile,"evalParametricDerivativesComponents2(u,i1,i2,i3,%d,%d, v ## %s,DIM,ORDER,MAXDERIV)\n", 
              m1-1,m2-1,rxName[m1,m2]):
 end do:
 end do:

# **************************************** FIX THIS ***************
# for m2 from 1 to dim do
# for m1 from 1 to dim do
#  # This is not correct -- need to do all first derivatives first, then second etc.
#  fprintf(mfile,"evalDerivativesComponents2(v ## %s,v,v ## %s,DIM,ORDER,MAXDERIV)\n",rxName[m1,m2],rxName[m1,m2]):
# end do:
# end do:

# **************************************** FINISH THIS *************** 
#    -- here we compute 
#           (1) first derivatives, x,y,x of (rx,ry,rz,sx,....)
#           (2) second derivatives xx,xy,yy,.. of (rx,ry,rz,sx,....)
 for k from 1 to maxDerivative do
  fprintf(mfile,"#If MAXDERIV >= %d\n",k):
  for m2 from 1 to dim do
  for m1 from 1 to dim do


   if dim=2 then maxDeriv3:=0 else maxDeriv3:=maxDerivative: end if:
   for tDeriv from 0 to maxDeriv3 do
   for sDeriv from 0 to maxDerivative do
   for rDeriv from 0 to maxDerivative do
      if rDeriv+sDeriv+tDeriv = k then

       dn:=""; # name of the derivative
       for i from 1 to rDeriv do dn:=cat(dn,aName[1]):  end do:
       for i from 1 to sDeriv do dn:=cat(dn,aName[2]):  end do:
       for i from 1 to tDeriv do dn:=cat(dn,aName[3]):  end do:
       dn:=convert(dn,string):

       fprintf(mfile,"getDuD%s ## DIM(v ## %s,v,v ## %s ## %s)\n",dn,rxName[m1,m2],rxName[m1,m2],dn):
       #fprintf(mfile,"getDuD%s ## DIM(u,aj,v ## %s)\n",dn,dn):

      end if:
   end do:
   end do:
   end do:

  end do: 
  end do: 
  fprintf(mfile,"#End\n");

 end do: # end k

      # evalParametricDerivativesComponents2(rsxy1,i1,i2,i3,0,0, aj1rx,2,4,1)
      # evalParametricDerivativesComponents2(rsxy1,i1,i2,i3,1,0, aj1sx,2,4,1)
      # evalParametricDerivativesComponents2(rsxy1,i1,i2,i3,0,1, aj1ry,2,4,1)
      # evalParametricDerivativesComponents2(rsxy1,i1,i2,i3,1,1, aj1sy,2,4,1)
      # evalDerivativesComponents1(v1,aj1,u1,2,4,2)

fprintf(mfile,"#End\n"):
end do: # dim 

fprintf(mfile,"#endMacro\n"):

# macros to declare variables
  fprintf(mfile,"#beginMacro declareParametricDerivativeVariables(v,DIM)\n"):
  fprintf(mfile,"real %s\n",convert(pdvars,string)):
  fprintf(mfile,"#endMacro\n"):

  fprintf(mfile,"#beginMacro declareDerivativeVariables(v,DIM)\n"):
  fprintf(mfile,"real %s\n",convert(dvars,string)):
  fprintf(mfile,"#endMacro\n"):

  fprintf(mfile,"#beginMacro declareJacobianDerivativeVariables(v,DIM)\n"):
  fprintf(mfile," declareParametricDerivativeVariables(v ## rx,DIM)\n"):
  fprintf(mfile," declareParametricDerivativeVariables(v ## sx,DIM)\n"):
  fprintf(mfile," declareParametricDerivativeVariables(v ## ry,DIM)\n"):
  fprintf(mfile," declareParametricDerivativeVariables(v ## sy,DIM)\n"):

  fprintf(mfile," declareDerivativeVariables(v ## rx,DIM)\n"):
  fprintf(mfile," declareDerivativeVariables(v ## sx,DIM)\n"):
  fprintf(mfile," declareDerivativeVariables(v ## ry,DIM)\n"):
  fprintf(mfile," declareDerivativeVariables(v ## sy,DIM)\n"):
  fprintf(mfile,"#If DIM == 3\n"):
    fprintf(mfile," declareParametricDerivativeVariables(v ## rz,DIM)\n"):
    fprintf(mfile," declareParametricDerivativeVariables(v ## sz,DIM)\n"):
    fprintf(mfile," declareParametricDerivativeVariables(v ## tx,DIM)\n"):
    fprintf(mfile," declareParametricDerivativeVariables(v ## ty,DIM)\n"):
    fprintf(mfile," declareParametricDerivativeVariables(v ## tz,DIM)\n"):
    fprintf(mfile," declareDerivativeVariables(v ## rz,DIM)\n"):
    fprintf(mfile," declareDerivativeVariables(v ## sz,DIM)\n"):
    fprintf(mfile," declareDerivativeVariables(v ## tx,DIM)\n"):
    fprintf(mfile," declareDerivativeVariables(v ## ty,DIM)\n"):
    fprintf(mfile," declareDerivativeVariables(v ## tz,DIM)\n"):
  fprintf(mfile,"#End\n"):
  fprintf(mfile,"#endMacro\n"):

  fprintf(mfile,"#beginMacro declareTemporaryVariables(DIM,MAXDERIV)\n"):
  fprintf(mfile,"real t0"):
  for m from 1 to 3000 do
    fprintf(mfile,",t%d",m):
  end do:
  fprintf(mfile,"\n#endMacro\n"):

fclose(mfile):

printf(" **** macro output written to file [%s] ******\n",mfileName);





# restart; read "weights.maple";
