# currentdir("/Users/henshaw/overtureFramework/cg/mx/codes");
# currentdir("/home/henshw/overtureFramework/cg/mx/codes");
# restart; read "chirpedPlaneWave.maple";
#
#  Compute the boundary forcing terms for a chirped plane wave
# 

# with(LinearAlgebra);
with(CodeGeneration):
with(StringTools):

kernelopts(printbytes=false): # turn off memory used messages

# Here is how xi is defined -- not needed here except that d(xi)/dt=1
# xi0 = .5*(cpwTa+cpwTb)
# xi = t - (kx*(x-cpwX0)+ky*(y-cpwY0))/cc -xi0

# Here are the names of parameters used in the code (chirpedPlaneWave.h):
alpha:=cpwAlpha:
beta:=cpwBeta:
ta:=cpwTa:
tb:=cpwTb:
amp:=cpwAmp:
# t:=cpwt; 
tau:=cpwTau;

# ft := diff(f,t);

numDeriv:=4:
for d from 2 to 3 do
  # if d=2 then
  #   xi:= t - (kx*x + ky*y)/cc:
  # else
  #   xi:= t - (kx*x + ky*y + kz*z)/cc:
  # end if:

  # ------- Here is the chirped pulse --------
  chi := (tanh(beta*(xi+.5*tau)) - tanh(beta*(xi-.5*tau)) )/2; # smoothed hat function [-tau/2,tau/2]
  ## chi := xi; # test
  phi := cc*xi + alpha*xi^2;
  f := amp*chi*sin(twoPi*phi); 

  for i from 0 to numDeriv do
  
    g := diff(f,[xi$i]);
  
    # mycode := C([chirp = f, chirpt = ft], optimize, defaulttype = float, deducetypes = false,output=string);
    mycode := Fortran([chirp = g], optimize, defaulttype = float,limitvariablelength=false,output=string);
    
    fileName:=sprintf("chirpedPlaneWave%dD%dT.h",d,i):
    file := fopen( fileName,WRITE ):
    
    fprintf(file,"! File generated by overtureFramework/cg/mx/codes/chirpedPlaneWave.maple\n"):
    fprintf(file,"! Here is the %d-th time-derivative of the chirp function in %dD\n",i,d):
    fprintf(file,"! chirp = %s\n",convert(f,string)):
    fprintf(file,"! chirp_t = %s\n",convert(g,string)):
    
    mycode := RegSubs("(\n[ ]*)#"="",mycode): # remove continuation lines 
    mycode := SubstituteAll(mycode," * ","*"):   # remove some blanks
    mycode := SubstituteAll(mycode," + ","+"):   # remove some blanks
    mycode := SubstituteAll(mycode," - ","-"):   # remove some blanks
    mycode := SubstituteAll(mycode," / ","/"):   # remove some blanks
    mycode := SubstituteAll(mycode,"D","E"):
    mycode := SubstituteAll(mycode,"0.5E0",".5"):
    mycode := SubstituteAll(mycode,"0.1E1","1."):
    mycode := SubstituteAll(mycode,"0.2E1","2."):
    mycode := SubstituteAll(mycode,"0.4E1","4."):
    mycode := SubstituteAll(mycode,"0.6E1","6."):
    mycode := SubstituteAll(mycode,"0.8E1","8."):
    mycode := SubstituteAll(mycode,"0.12E2","12."):

    # mycode := SubstituteAll(mycode,"cpwt-(kx*x+ky*y)/cc","xi"):
    # mycode := SubstituteAll(mycode,"cpwt-(kx*x+ky*y+kz*z)/cc","xi"):

    fprintf(file,"%s\n",mycode);
    fclose(file);
    
    printf("Output written to file=[%s]\n",fileName);
  
  end do;
end do;

#- 
#- ex :=-(y-y0-cy*t)*psi; 
#- ey := (x-x0-cx*t)*psi;
#- hz := psi;
#- 
#- fex := diff(ex,t,t)-cSq*( diff(ex,x,x) + diff(ex,y,y)); 
#- fey := diff(ey,t,t)-cSq*( diff(ey,x,x) + diff(ey,y,y)); 
#- fhz := diff(hz,t,t)-cSq*( diff(hz,x,x) + diff(hz,y,y)); 
#- 
#- # mycode := C([PSI = psi, FEX = fex, FEY = fey, FHZ = fhz], defaulttype = float, deducetypes = false,output=string);
#- mycode := C([PSI = psi, FEX = fex, FEY = fey, FHZ = fhz], optimize, defaulttype = float, deducetypes = false,output=string);
#- 
#- 
#- fileName:="manufacturedPulseForcing2d.h":
#- file := fopen( fileName,WRITE ):
#- 
#- fprintf(file,"// File generated by overtureFramework/cg/mx/codes/manufacturedPulse.maple\n"):
#- fprintf(file,"// Ex = %s\n",convert(ex,string)):
#- fprintf(file,"// Ey = %s\n",convert(ey,string)):
#- fprintf(file,"// Hz = %s\n",convert(hz,string)):
#- 
#- fprintf(file,"real t2,t3,t5,t6,t9,PSI,t14,t16,t19,t20,t21,t23,t25,t27,t28,t30,t32,t35,t36,t38,t40,t41,t45,t46,t47,t54,t49,t61,t68,FEX,FEY,FHZ;\n");
#- 
#- fprintf(file,"%s\n",mycode);
#- fclose(file);
#- 
#- printf("Output written to file=[%s]\n",fileName);
#- 
#- 
#- # ----------------------------- 3D -----------------------------------------
#- 
#- psi := amp*exp(-beta*( (x-x0-cx*t)^2 + (y-y0-cy*t)^2 + (z-z0-cy*t)^2  ));
#- 
#- 
#- ex := ((z-z0-cz*t)-(y-y0-cy*t))*psi;
#- ey := ((x-x0-cx*t)-(z-z0-cz*t))*psi;
#- ez := ((y-y0-cy*t)-(x-x0-cx*t))*psi;
#- 
#- fex := diff(ex,t,t)-cSq*( diff(ex,x,x) + diff(ex,y,y) + diff(ex,z,z)); 
#- fey := diff(ey,t,t)-cSq*( diff(ey,x,x) + diff(ey,y,y) + diff(ey,z,z)); 
#- fez := diff(ez,t,t)-cSq*( diff(ez,x,x) + diff(ez,y,y) + diff(ez,z,z)); 
#- 
#- # mycode := C([PSI = psi, FEX = fex, FEY = fey, FHZ = fhz], defaulttype = float, deducetypes = false,output=string);
#- mycode := C([PSI = psi, FEX = fex, FEY = fey, FEZ = fez], optimize, defaulttype = float, deducetypes = false,output=string):
#- 
#- 
#- fileName:="manufacturedPulseForcing3d.h":
#- file := fopen( fileName,WRITE ):
#- 
#- fprintf(file,"// File generated by overtureFramework/cg/mx/codes/manufacturedPulse.maple\n"):
#- fprintf(file,"// Ex = %s\n",convert(ex,string)):
#- fprintf(file,"// Ey = %s\n",convert(ey,string)):
#- fprintf(file,"// Ez = %s\n",convert(ez,string)):
#- 
#- # declare temp variables: t1,t2,...,t99
#- fprintf(file,"real t1"):
#- for m from 2 to 99 do 
#-   fprintf(file,",t%d",m):
#- end do;
#- fprintf(file,";\n"):
#- 
#- fprintf(file,"real PSI,FEX,FEY,FEZ;\n"):
#- 
#- fprintf(file,"%s\n",mycode):
#- fclose(file);
#- 
#- printf("Output written to file=[%s]\n",fileName);
#- 
#- 
