! -----------------------------------------------------------------------------------
! Evaluate the dispersion relation for the generalized dispersion model (GDM)
! -----------------------------------------------------------------------------------
!
!       E_tt - c^2 Delta(E) = -alphaP P_tt
!       P_tt + b1 P_1 + b0 = a0*E + a1*E_t 
!
!  Input:
!      c,k, a0,a1,b0,b1,alphaP
! Output:
!      sr,si : real and imaginary part of s
!      psir,psii : real and imaginary parts of psi : P = psi*E 
!
      subroutine evalGeneralizedDispersionRelation( c,k, a0,a1,b0,b1,alphaP, sr,si, psir,psii )


      ! implicit none
      implicit complex*16 (t)

      real c,k, a0,a1,b0,b1,alphaP, psir,psii
      real ck,ck2,  f ,ap, cki,ck2i 
      real sr,si
      complex*16 ai, ss,s,cComplex, psi

      ! cComplex = dcmplx(c,0.) ! convert c to complex to force complex arithmetic below
      ck=c*k
      ck2=ck*ck
      cki=1/ck
      ck2i=1./ck2 

      ap=alphaP
 
! File generated by overtureFramework/cg/mx/codes/gdm.maple

#Include "generalizedDispersionRelation1.h"

      ! The valid root will have an imaginary part close to I*ck 
      if( abs(dimag(ss)) < .01*ck )then
#Include "generalizedDispersionRelation3.h"     
        write(*,'("evalGDM: Use root 3")')
        if( abs(dimag(ss)) < .01*ck )then
          write(*,'("evalGDM: INVALID root found!?")')
          stop 6666
        end if
      else
        write(*,'("evalGDM: Use root 1")')
      end if

      s =ss*ck

      if( dimag(s)>0. )then
        s=dconjg(s) ! choose right moving wave, imag(s) < 0 
      end if 

      sr= dreal(s)
      si= dimag(s)

      ! P = psi(s)*E
      psi = (a0+a1*s)/(s**2+b1*s+b0)
      psir = dreal(psi)
      psii = dimag(psi)  ! NOTE: CHOOSE RIGHT MOVING WAVE

      ! check root:
      f = cabs((ss**2 + 1)*(ss**2 + cki*b1*ss+ck2i*b0) + ap*ss**2*cki*( a1*ss+ cki*a0 ) )

      write(*,'("evalGDM: c,k,a0,a1,b0,b1=",6(1P,e20.12)," alphaP=",1Pe20.12)') c,k,a0,a1,b0,b1,alphaP
      write(*,'("evalGDM: sr,si=",2(1P,e24.15)," |f|=",e12.4)') sr,si,f
      write(*,'("evalGDM: psir,psii=",2e12.4)') psir,psii


      return
      end   


! Evaluate the dispersion relation for the Drude model 
!
!    E_tt + c^2 k^2 E = -alphaP*P_tt
!
!  Input:
!      c0,eps,gam,omegap,k : 
! Output:
!      reS,imS
!
      subroutine evalDispersionRelation( c0,eps,gam,omegap,k, reS,imS )


      implicit none

      real c0,eps,gam,omegap,k, ck2, epsi, om2, det
      real reS,imS
      complex*16 ai, c, s

      ck2=(c0*k)**2
      epsi=1./eps
      om2=omegap**2

       ! ai=cmplx(0.,1.)  ! i 
       c = cmplx(c0,0.) ! convert c to complex to force complex arithmetic below
! File generated by overtureFramework/cg/mx/codes/dispersion.maple
! Here is root 3 from the dispersion relation exp( i*k*x + s*t) .
! s = -1/12*(36*epsi*gam*om2-72*ck2*gam-8*gam^3+12*(12*epsi^3*om2^3-3*epsi^2*gam^2*om2^2+36*ck2*epsi^2*om2^2-60*ck2*epsi*gam^2*om2+12*ck2*gam^4+36*ck2^2*epsi*om2+24*ck2^2*gam^2+12*ck2^3)^(1/2))^(1/3)+3*(1/3*epsi*om2+1/3*ck2-1/9*gam^2)/(36*epsi*gam*om2-72*ck2*gam-8*gam^3+12*(12*epsi^3*om2^3-3*epsi^2*gam^2*om2^2+36*ck2*epsi^2*om2^2-60*ck2*epsi*gam^2*om2+12*ck2*gam^4+36*ck2^2*epsi*om2+24*ck2^2*gam^2+12*ck2^3)^(1/2))^(1/3)-1/3*gam+1/2*I*3^(1/2)*(1/6*(36*epsi*gam*om2-72*ck2*gam-8*gam^3+12*(12*epsi^3*om2^3-3*epsi^2*gam^2*om2^2+36*ck2*epsi^2*om2^2-60*ck2*epsi*gam^2*om2+12*ck2*gam^4+36*ck2^2*epsi*om2+24*ck2^2*gam^2+12*ck2^3)^(1/2))^(1/3)+6*(1/3*epsi*om2+1/3*ck2-1/9*gam^2)/(36*epsi*gam*om2-72*ck2*gam-8*gam^3+12*(12*epsi^3*om2^3-3*epsi^2*gam^2*om2^2+36*ck2*epsi^2*om2^2-60*ck2*epsi*gam^2*om2+12*ck2*gam^4+36*ck2^2*epsi*om2+24*ck2^2*gam^2+12*ck2^3)^(1/2))^(1/3))
      s = -(((36*epsi*gam*om2)-(72*ck2*gam)-(8*gam ** 3)+12.*sqrt((12*epsi ** 3*om2 ** 3-3*epsi ** 2*om2 ** 2*gam ** 2+36*epsi ** 2*om2 ** 2*ck2-60*epsi*om2*ck2*gam ** 2+12*ck2*gam ** 4+36*epsi*om2*ck2 ** 2+24*ck2 ** 2*gam ** 2+12*ck2 ** 3))) ** (1./3.)/12.)+(3.*((epsi*om2)/3.+(ck2)/3.-(gam ** 2)/0.9E1)*((36*epsi*gam*om2)-(72*ck2*gam)-(8*gam ** 3)+12.*sqrt((12*epsi ** 3*om2 ** 3-3*epsi ** 2*om2 ** 2*gam ** 2+36*epsi ** 2*om2 ** 2*ck2-60*epsi*om2*ck2*gam ** 2+12*ck2*gam ** 4+36*epsi*om2*ck2 ** 2+24*ck2 ** 2*gam ** 2+12*ck2 ** 3))) ** (-1./3.))-((gam)/3.)+cmplx(0, 1./2.)*sqrt(3.)*(((36*epsi*gam*om2)-(72*ck2*gam)-(8*gam ** 3)+12.*sqrt((12*epsi ** 3*om2 ** 3-3*epsi ** 2*om2 ** 2*gam ** 2+36*epsi ** 2*om2 ** 2*ck2-60*epsi*om2*ck2*gam ** 2+12*ck2*gam ** 4+36*epsi*om2*ck2 ** 2+24*ck2 ** 2*gam ** 2+12*ck2 ** 3))) ** (1./3.)/6.+6.*((epsi*om2)/3.+(ck2)/3.-(gam ** 2)/0.9E1)*((36*epsi*gam*om2)-(72*ck2*gam)-(8*gam ** 3)+12.*sqrt((12*epsi ** 3*om2 ** 3-3*epsi ** 2*om2 ** 2*gam ** 2+36*epsi ** 2*om2 ** 2*ck2-60*epsi*om2*ck2*gam ** 2+12*ck2*gam ** 4+36*epsi*om2*ck2 ** 2+24*ck2 ** 2*gam ** 2+12*ck2 ** 3))) ** (-1./3.))

      reS= real(s)
      imS= aimag(s)

      ! check root:
      det = cabs((s**2 + ck2)*(s**2 + gam*s) + om2*s**2*epsi)
      write(*,'("*OLD* evalDisp: eps,omegap=",2e12.4," gam,k=",2e12.4," |det|=",e12.4)') eps,omegap,gam,k,det
      write(*,'("*OLD* evalDisp: reS,imS=",2(1P,e22.15))') reS,imS
      return
      end   



