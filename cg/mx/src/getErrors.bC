#include "Maxwell.h"
#include "CompositeGridOperators.h"
#include "display.h"
#include "UnstructuredMapping.h"
#include "OGPolyFunction.h"
#include "OGTrigFunction.h"
#include "OGPulseFunction.h"
#include "interpPoints.h"
#include "ShowFileReader.h"
#include "ParallelUtility.h"
#include "gridFunctionNorms.h"

#define exmax EXTERN_C_NAME(exmax)
extern "C"
{

 void exmax(double&Ez,double&Bx,double&By,const int &nsources,const double&xs,const double&ys,
            const double&tau,const double&var,const double&amp, const double&a,
            const double&x,const double&y,const double&time);

}


#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

// Define macros for forcing functions:
#Include "forcing.h"
#Include "annulusEigenFunction.h"

// Macros for the plane material interface:
#Include "planeMaterialInterface.h"
 definePlaneMaterialInterfaceMacros(C)

//! local function to compute errors for the staggered grid DSI schemes
void
computeDSIErrors( Maxwell &mx, MappedGrid &mg, realArray &uh, realArray &uhp, realArray &ue, realArray &uep,
		  realArray &errh, realArray &erre, 
		  RealArray &solutionNorm, RealArray &maximumError )
{
  bool skipGhosts = true;
  ArraySimpleFixed<int,6,1,1,1> ml;
  ml = -1;

  real l2h_err,l2e_err;
  real nE, nH;
  l2h_err = l2e_err = 0;
  nE=nH=0;

  real maxDivE = 0, maxDivH = 0;
  if ( mg.getGridType()==MappedGrid::unstructuredGrid )
  {
      
    UnstructuredMapping & umap = (UnstructuredMapping &) mg.mapping().getMapping();
    int rDim = umap.getRangeDimension();

//       const realArray &verts = umap.getNodes();
//       const intArray  &edges = umap.getEntities(UnstructuredMapping::Edge);

    UnstructuredMappingIterator iter,iter_end;
    iter_end = umap.end( UnstructuredMapping::Edge, skipGhosts ); // true means skip ghosts
    for ( iter = umap.begin( UnstructuredMapping::Edge, skipGhosts );
	  iter!=iter_end;
	  iter++ )
    {
      assert(!umap.isGhost(UnstructuredMapping::Edge, *iter));
      int e = *iter;
      //	  if ( !umap.hasTag(UnstructuredMapping::Edge, e, "__bcnum ") )
    {
      for ( int c=0; c<ue.getLength(3); c++ )
      {
	solutionNorm(c) = max(solutionNorm(c), fabs(ue(e,0,0,c)));
	if ( maximumError(c)<fabs(erre(e,0,0,c)) )
	  ml[c] = e;
	maximumError(c) = max(maximumError(c), fabs(erre(e,0,0,c)));
	l2e_err += erre(e,0,0,c)*erre(e,0,0,c);
      }
      nE++;
    }
    //	  cout<<.5*(verts(edges(*iter,0),0)+verts(edges(*iter,1),0))<<"  "<<.5*(verts(edges(*iter,0),1)+verts(edges(*iter,1),1))<<"  "<<erre(*iter,0,0,0)<<endl;
    }
      
    l2e_err /= real(nE);

    int off = ue.getLength(3);
    iter_end = umap.end( UnstructuredMapping::Face, skipGhosts ); // true means skip ghosts
    for ( iter = umap.begin( UnstructuredMapping::Face, skipGhosts );
	  iter!=iter_end;
	  iter++ )
    {
      int f = *iter;
      assert(!umap.isGhost(UnstructuredMapping::Face, *iter));
      //	  if ( !umap.hasTag(UnstructuredMapping::Face, f, "__bcnum ") )
    {
      for ( int c=0; c<uh.getLength(3); c++ )
      {
	solutionNorm(off+c) = max(solutionNorm(off+c), fabs(uh(f,0,0,c)));
	if ( maximumError(off+c)<fabs(errh(f,0,0,c)) )
	  ml[off+c] = f;
	maximumError(off+c) = max(maximumError(off+c), fabs(errh(f,0,0,c)));
	l2h_err += errh(f,0,0,c)*errh(f,0,0,c);
      }
      nH++;
    }
    }
    l2h_err /= real(nH);
    maximumError(0) = sqrt(l2e_err);
    maximumError(off) = sqrt(l2h_err);
      
    iter_end = umap.end(UnstructuredMapping::Vertex);
    for ( iter=umap.begin(UnstructuredMapping::Vertex); iter!=iter_end; iter++ )
    {
      if ( !(iter.isGhost() || iter.isBC()) )
      {
	real divE = 0;
	UnstructuredMappingAdjacencyIterator aiter,aiter_end;
	aiter_end = umap.adjacency_end(iter, UnstructuredMapping::Edge);
	for ( aiter=umap.adjacency_begin(iter, UnstructuredMapping::Edge); aiter!=aiter_end; aiter++ )
	{
	  divE += aiter.orientation()*uep(*aiter,0,0);
	  if ( aiter.isBC() || aiter.isGhost() )
	  {
	    divE = 0;
	    break;
	  }
	}
	maxDivE = max(maxDivE,fabs(divE));
      }
	  
    }

    if (rDim==3)
    {
      iter_end = umap.end(UnstructuredMapping::Region);
      for ( iter=umap.begin(UnstructuredMapping::Region); iter!=iter_end; iter++ )
      {
	if ( !(iter.isGhost() || iter.isBC()) )
	{
	  real divH = 0;
	  UnstructuredMappingAdjacencyIterator aiter,aiter_end;
	  aiter_end = umap.adjacency_end(iter, UnstructuredMapping::Face);
	  for ( aiter=umap.adjacency_begin(iter, UnstructuredMapping::Face); aiter!=aiter_end; aiter++ )
	  {
	    divH += aiter.orientation()*uhp(*aiter,0,0);
	    if ( aiter.isBC() || aiter.isGhost() )
	    {
	      divH = 0;
	      break;
	    }
	  }
	  maxDivH = max(maxDivH,fabs(divH));
	}
	      
      }
    }

  }

  //  cout<<"max error locs "<<ml<<endl;
  //  cout<<"max Div E = "<<maxDivE<<endl;
  //  cout<<"max Div H = "<<maxDivH<<endl;
  mx.divEMax = maxDivE;
  mx.gradEMax = maxDivH; // use this spot for div H in the dsi code
  cout<<"max E error location "<<ml<<endl;
  maximumError.display("maximum error");
}



//! Determine the errors.
/*!

 */
void Maxwell::
getErrors( int current, real t, real dt )
// =================================================================================================================
// =================================================================================================================
{
  if( !checkErrors )
    return;

  real time0=getCPU();
  
  const real cc= c*sqrt( kx*kx+ky*ky+kz*kz);
  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Iav[3], &Ia1=Iav[0], &Ia2=Iav[1], &Ia3=Iav[2]; 
  Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2]; 
  Index Icv[3], &Ic1=Icv[0], &Ic2=Icv[1], &Ic3=Icv[2]; 

  const int prev = (current-1+numberOfTimeLevels) % numberOfTimeLevels;
  const int next = (current+1) % numberOfTimeLevels;
  
  // printF(" >>>>>>>>getErrors: current=%i next=%i <<<<<<<<<<< \n",current,next);
  

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  const int numberOfComponentGrids = cg.numberOfComponentGrids();
  const int numberOfDimensions = cg.numberOfDimensions();

  


  Range C(ex,hz);
  maximumError.redim(numberOfSequences); 
  if( method==nfdtd || method==yee )
  {
    solutionNorm.redim(C);  // for nfdtd
  }
  else if( method==sosup )
  {
    const int numberOfComponents= cgfields[0][0].getLength(3);
    C=numberOfComponents;
    solutionNorm.redim(numberOfComponents);  
  }
  else
  {
    if(numberOfDimensions==2)
    {
      solutionNorm.redim(3);
    }
    else
    {
      solutionNorm.redim(6);
    }
  }

  maximumError=0.;
  solutionNorm=1.;
  
  realCompositeGridFunction *uReference=NULL;
  if( compareToReferenceShowFile )
  {
    // This case is used for comparing absorbing BC's -- we compare the solution to a reference
    // solution that was computed on a bigger grid
    if( referenceShowFileReader==NULL )
    {
      referenceShowFileReader = new ShowFileReader(nameOfReferenceShowFile);
    }
	    
    CompositeGrid cgRef;
    realCompositeGridFunction uRef;
	    
    int solutionNumber = 1 + int( t/tPlot + .5); // fix this ******************************
    printF(" **** compareToReferenceShowFile: t=%f solutionNumber=%i\n",t,solutionNumber);
    
    referenceShowFileReader->getASolution(solutionNumber,cgRef,uRef);        // read in a grid and solution

    // This solution uReference will live on the smaller domain 
    Range all;
    uReference = new realCompositeGridFunction(cg,all,all,all,C);
    cg.update(MappedGrid::THEmask );
    cgRef.update(MappedGrid::THEmask );
    interpolateAllPoints( uRef,*uReference );  // interpolate uReference from uRef
  }

  maximumError=0.;  // max error over all grids
  solutionNorm=0.;
  
  //kkc 040310 moved this assertion outside the following loop
  assert( cgerrp!=NULL || errp!=NULL );

  for( int grid=0; grid<numberOfComponentGrids; grid++ )
  {

    if( method==yee )
    {
      assert( numberOfComponentGrids==1 );
      
      int option=1;
      int iparam[5] = { -1,-1,0,0,0 }; // 
      getValuesFDTD( option, iparam, current, t, dt, cgerrp );

      continue;
    }



    c = cGrid(grid);
    eps = epsGrid(grid);
    mu = muGrid(grid);

    EXTRACT_GFP(ERRORS);    // bpp macro

    bool energyOnly = false;

    const int i0a=mg.gridIndexRange(0,0);
    const int i1a=mg.gridIndexRange(0,1);
    const int i2a=mg.gridIndexRange(0,2);

    const real xa=xab[0][0], dx0=dx[0];
    const real ya=xab[0][1], dy0=dx[1];
    const real za=xab[0][2], dz0=dx[2];

    #define X0(i0,i1,i2) (xa+dx0*(i0-i0a))
    #define X1(i0,i1,i2) (ya+dy0*(i1-i1a))
    #define X2(i0,i1,i2) (za+dz0*(i2-i2a))

    const int numberOfGhost=method==nfdtd ? orderOfAccuracyInSpace/2 : 0;
      
    // Range C(ex,hz);

    real errEx,errEy,errHz;

    // Here is the box where we evaluate the error when there is a PML
    bool usePML = getBoundsForPML( mg,Iv,pmlErrorOffset ); 
    if( usePML )
    { // do NOT include PML region in the bounds: 
      adjustBoundsForPML(mg,Iev,pmlErrorOffset ); 
      adjustBoundsForPML(mg,Ihv,pmlErrorOffset ); 
    }

    errh = 0.;
    erre = 0.;
    // if( initialConditionOption==planeWaveInitialCondition )
    if( knownSolutionOption==planeWaveKnownSolution )
    {
      if( numberOfDimensions==2 )
      {
// 	      err(I1,I2,I3,ex)=u(I1,I2,I3,ex)-exTrue(x,y,t);
// 	      err(I1,I2,I3,ey)=u(I1,I2,I3,ey)-eyTrue(x,y,t);
// 	      err(I1,I2,I3,hz)=u(I1,I2,I3,hz)-hzTrue(x,y,t);
	
	erre(Ie1,Ie2,Ie3,ex)  = ue(Ie1,Ie2,Ie3,ex)-exTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
	erre(Ie1,Ie2,Ie3,ey)  = ue(Ie1,Ie2,Ie3,ey)-eyTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
	errh(Ih1,Ih2,Ih3,hz)  = uh(Ih1,Ih2,Ih3,hz)-hzTrue(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),tH);

	if( method==sosup )
	{
          realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
          // printF(" errLocal = [%i,%i]\n",errLocal.getBase(3),errLocal.getBound(3));

	  errLocal(Ie1,Ie2,Ie3,ext)  = uLocal(Ie1,Ie2,Ie3,ext)-extTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
	  errLocal(Ie1,Ie2,Ie3,eyt)  = uLocal(Ie1,Ie2,Ie3,eyt)-eytTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
	  errLocal(Ih1,Ih2,Ih3,hzt)  = uLocal(Ih1,Ih2,Ih3,hzt)-hztTrue(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),tH);

	}

      }
      else // 3D
      {
// 	      if( solveForElectricField )
// 	      {
// 		err(I1,I2,I3,ex)=u(I1,I2,I3,ex)-exTrue3d(x,y,z,t);
// 		err(I1,I2,I3,ey)=u(I1,I2,I3,ey)-eyTrue3d(x,y,z,t);
// 		err(I1,I2,I3,ez)=u(I1,I2,I3,ez)-ezTrue3d(x,y,z,t);
// 	      }
//               if( solveForMagneticField )
// 	      {
// 		err(I1,I2,I3,hx)=u(I1,I2,I3,hx)-hxTrue3d(x,y,z,t);
// 		err(I1,I2,I3,hy)=u(I1,I2,I3,hy)-hyTrue3d(x,y,z,t);
// 		err(I1,I2,I3,hz)=u(I1,I2,I3,hz)-hzTrue3d(x,y,z,t);
// 	      }
	if( solveForElectricField )
	{
	  erre(Ie1,Ie2,Ie3,ex)=ue(Ie1,Ie2,Ie3,ex)-exTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
	  erre(Ie1,Ie2,Ie3,ey)=ue(Ie1,Ie2,Ie3,ey)-eyTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
	  erre(Ie1,Ie2,Ie3,ez)=ue(Ie1,Ie2,Ie3,ez)-ezTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);

	  if( method==sosup )
	  {
	    realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
	    // printF(" errLocal = [%i,%i]\n",errLocal.getBase(3),errLocal.getBound(3));

	    errLocal(Ie1,Ie2,Ie3,ext)  = uLocal(Ie1,Ie2,Ie3,ext)-extTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
	    errLocal(Ie1,Ie2,Ie3,eyt)  = uLocal(Ie1,Ie2,Ie3,eyt)-eytTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
	    errLocal(Ie1,Ie2,Ie3,ezt)  = uLocal(Ie1,Ie2,Ie3,ezt)-eztTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);

	  }

	}
	if( solveForMagneticField )
	{
	  errh(Ih1,Ih2,Ih3,hx)=uh(Ih1,Ih2,Ih3,hx)-hxTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
	  errh(Ih1,Ih2,Ih3,hy)=uh(Ih1,Ih2,Ih3,hy)-hyTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
	  errh(Ih1,Ih2,Ih3,hz)=uh(Ih1,Ih2,Ih3,hz)-hzTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
	}
      }
	    
    }
    else if( knownSolutionOption==twilightZoneKnownSolution )
    {
      // *****************************************************************
      // ******************* TZ FORCING **********************************
      // *****************************************************************
      assert( tz!=NULL );
      OGFunction & e = *tz;
      realArray & center = mg.center();
      // display(center,"center"); //ok
	    
      // display(ee,"exact solution for error computation");
	    
      Index J1,J2,J3;

      int i1,i2,i3;
      if( mg.numberOfDimensions()==2 )
      {
	J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
	J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
	J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));
	FOR_3D(i1,i2,i3,J1,J2,J3)
	{
	  real x0 = XEP(i1,i2,i3,0);
	  real y0 = XEP(i1,i2,i3,1);
	  ERREX(i1,i2,i3)=UEX(i1,i2,i3)-e(x0,y0,0.,ex,tE);
	  ERREY(i1,i2,i3)=UEY(i1,i2,i3)-e(x0,y0,0.,ey,tE);
	}
	if( method==sosup )
	{
          // Compute errors in the time derivative
          realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    real x0 = XEP(i1,i2,i3,0);
	    real y0 = XEP(i1,i2,i3,1);
	    errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)- e(x0,y0,0.,ext,tE);
	    errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)- e(x0,y0,0.,eyt,tE);
	    errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt)- e(x0,y0,0.,hzt,tH);
	  }
	}
	

	J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
	J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
	J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
	FOR_3(i1,i2,i3,J1,J2,J3)
	{
	  real x0 = XHP(i1,i2,i3,0);
	  real y0 = XHP(i1,i2,i3,1);
	  ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3)-e(x0,y0,0.,hz,tH);
	}
      }
      else // 3D
      {
	if( solveForElectricField ) 
        {
	  J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
	  J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
	  J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));
	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    real x0 = XEP(i1,i2,i3,0);
	    real y0 = XEP(i1,i2,i3,1);
	    real z0 = XEP(i1,i2,i3,2);
	    ERREX(i1,i2,i3)=UEX(i1,i2,i3)-e(x0,y0,z0,ex,tE);
	    ERREY(i1,i2,i3)=UEY(i1,i2,i3)-e(x0,y0,z0,ey,tE);
	    ERREZ(i1,i2,i3)=UEZ(i1,i2,i3)-e(x0,y0,z0,ez,tE);
	  }
	  if( method==sosup )
	  {
            // Compute errors in the time derivative
	    realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
	    FOR_3D(i1,i2,i3,J1,J2,J3)
	    {
	      real x0 = XEP(i1,i2,i3,0);
	      real y0 = XEP(i1,i2,i3,1);
	      real z0 = XEP(i1,i2,i3,2);
	      errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)- e(x0,y0,z0,ext,tE);
	      errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)- e(x0,y0,z0,eyt,tE);
	      errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt)- e(x0,y0,z0,ezt,tE);
	    }
	  }

	}

	if( solveForMagneticField ) 
        {
	  J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
	  J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
	  J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    real x0 = XHP(i1,i2,i3,0);
	    real y0 = XHP(i1,i2,i3,1);
	    real z0 = XHP(i1,i2,i3,2);
	    ERRHX(i1,i2,i3)=UHX(i1,i2,i3)-e(x0,y0,z0,hx,tH);
	    ERRHY(i1,i2,i3)=UHY(i1,i2,i3)-e(x0,y0,z0,hy,tH);
	    ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3)-e(x0,y0,z0,hz,tH);
	  }
	  if( method==sosup )
	  {
            // Compute errors in the time derivative
	    realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
	    FOR_3D(i1,i2,i3,J1,J2,J3)
	    {
	      real x0 = XHP(i1,i2,i3,0);
	      real y0 = XHP(i1,i2,i3,1);
	      real z0 = XHP(i1,i2,i3,2);
	      errLocal(i1,i2,i3,hxt) = uLocal(i1,i2,i3,hxt)- e(x0,y0,z0,hxt,tH);
	      errLocal(i1,i2,i3,hyt) = uLocal(i1,i2,i3,hyt)- e(x0,y0,z0,hyt,tH);
	      errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt)- e(x0,y0,z0,hzt,tH);
	    }
	  }
	}

      }

      if( debug & 4 ) 
      {
        display(erre(J1,J2,J3),sPrintF("getErrors: errE on grid %i at t=%e",grid,t),pDebugFile,"%9.2e "); 
        display(errh(J1,J2,J3),sPrintF("getErrors: errH on grid %i at t=%e",grid,t),pDebugFile,"%9.2e "); 
      }

    }
    else if( knownSolutionOption==gaussianPlaneWaveKnownSolution )
    {
      realSerialArray xei(Ie1,Ie2,Ie3),xhi(Ih1,Ih2,Ih3);
      //xi=kx*(x-x0GaussianPlaneWave)+ky*(y-y0GaussianPlaneWave) -cc*t;
      xei=kx*(xe(Ie1,Ie2,Ie3)-x0GaussianPlaneWave)+ky*(ye(Ie1,Ie2,Ie3)-y0GaussianPlaneWave) -cc*tE;
      xhi=kx*(xh(Ih1,Ih2,Ih3)-x0GaussianPlaneWave)+ky*(yh(Ih1,Ih2,Ih3)-y0GaussianPlaneWave) -cc*tH;

//             err(I1,I2,I3,hz)=hzGaussianPulse(xi);  // save Hz here temporarily

//             err(I1,I2,I3,ex)=u(I1,I2,I3,ex)-err(I1,I2,I3,hz)*(-ky/(eps*cc));
//             err(I1,I2,I3,ey)=u(I1,I2,I3,ey)-err(I1,I2,I3,hz)*( kx/(eps*cc));
// 	    err(I1,I2,I3,hz)-=u(I1,I2,I3,hz);
      realSerialArray hzei(Ie1,Ie2,Ie3);
      hzei = hzGaussianPulse(xei);
      erre(Ie1,Ie2,Ie3,ex)=ue(Ie1,Ie2,Ie3,ex)-hzei(Ie1,Ie2,Ie3)*(-ky/(eps*cc));
      erre(Ie1,Ie2,Ie3,ey)=ue(Ie1,Ie2,Ie3,ey)-hzei(Ie1,Ie2,Ie3)*( kx/(eps*cc));
      errh(Ih1,Ih2,Ih3,hz)=uh(Ih1,Ih2,Ih3,hz) - hzGaussianPulse(xhi(Ih1,Ih2,Ih3));
    }
    else if( knownSolutionOption==squareEigenfunctionKnownSolution )
    {
      real fx=Pi*initialConditionParameters[0];
      real fy=Pi*initialConditionParameters[1];
      real fz=Pi*initialConditionParameters[2];
      real x0=initialConditionParameters[3];
      real y0=initialConditionParameters[4];
      real z0=initialConditionParameters[5];
      real omega;
      real a1=1., a2=-2., a3=1.;  // For 3d, divergence free if a1+a2+a3=0
      if( numberOfDimensions==2 )
      {
	omega=c*sqrt(fx*fx+fy*fy);
	// x0=-.5, y0=-.5;   // for the square [-.5,.5]x[-.5,.5] 
      }
      else
      {
	omega=c*sqrt(fx*fx+fy*fy+fz*fz);
      }
	    
      int i1,i2,i3;
      real xd,yd,zd;
      if( isRectangular )
      {
//  	      const real *up = u.Array_Descriptor.Array_View_Pointer3;
//  	      real *errp = err.Array_Descriptor.Array_View_Pointer3;
//  	      const int uDim0=u.getRawDataSize(0);
//  	      const int uDim1=u.getRawDataSize(1);
//  	      const int uDim2=u.getRawDataSize(2);
//                #undef U
//                #define U(i0,i1,i2,i3) up[i0+uDim0*(i1+uDim1*(i2+uDim2*(i3)))]
//                #undef ERR
//                #define ERR(i0,i1,i2,i3) errp[i0+uDim0*(i1+uDim1*(i2+uDim2*(i3)))]


	if( numberOfDimensions==2 )
	{
	  Index J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
	  Index J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
	  Index J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    xd=X0(i1,i2,i3)-x0;
	    yd=X1(i1,i2,i3)-y0;

	    ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*cos(omega*tH);
	  }

	  J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
	  J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
	  J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

	  FOR_3(i1,i2,i3,J1,J2,J3)
	  {
	    xd=X0(i1,i2,i3)-x0;
	    yd=X1(i1,i2,i3)-y0;
	    ERREX(i1,i2,i3)=UEX(i1,i2,i3) - (-fy/omega)*cos(fx*xd)*sin(fy*yd)*sin(omega*tE);  // Ex.t = Hz.y
	    ERREY(i1,i2,i3)=UEY(i1,i2,i3) - ( fx/omega)*sin(fx*xd)*cos(fy*yd)*sin(omega*tE);  // Ey.t = - Hz.x
	  }

	  if( method==sosup )
	  {
            // Compute errors in the time derivative
	    realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
	    FOR_3(i1,i2,i3,J1,J2,J3)
	    {
	      real xde=X0(i1,i2,i3)-x0;
	      real yde=X1(i1,i2,i3)-y0;
	      // time derivatives: 
	      errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-fy)*cos(fx*xde)*sin(fy*yde)*cos(omega*tE);  // Ex.t
	      errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - ( fx)*sin(fx*xde)*cos(fy*yde)*cos(omega*tE);  // Ey.t
	      errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt) - (-omega)*cos(fx*xde)*cos(fy*yde)*sin(omega*tH);  // Hz.t 
	    }
	  }
	} 
	else // 3D
	{

	  Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
	  Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
	  Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

	  FOR_3D(i1,i2,i3,I1,I2,I3)
	  {
	    xd=X0(i1,i2,i3)-x0;
	    yd=X1(i1,i2,i3)-y0;
	    zd=X2(i1,i2,i3)-z0;

	    ERREX(i1,i2,i3)=UEX(i1,i2,i3) -  (a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
	    ERREY(i1,i2,i3)=UEY(i1,i2,i3) -  (a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
	    ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) -  (a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*cos(omega*tE);  // 
	  }

	  if( method==sosup )
	  {
	    OV_ABORT("finish me");
	  }
	  
	}
      }
      else // curvilinear 
      {
	// curvilinear
	if( numberOfDimensions==2 )
	{
	  Index J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
	  Index J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
	  Index J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));

	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    xd=XHP(i1,i2,i3,0)-x0;
	    yd=XHP(i1,i2,i3,1)-y0;
	    ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*cos(omega*tH);
	  }

	  J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
	  J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
	  J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

	  FOR_3(i1,i2,i3,J1,J2,J3)
	  {
	    xd=XEP(i1,i2,i3,0)-x0;
	    yd=XEP(i1,i2,i3,1)-y0;
	    ERREX(i1,i2,i3)=UEX(i1,i2,i3) - (-fy/omega)*cos(fx*xd)*sin(fy*yd)*sin(omega*tE);  // Ex.t = Hz.y
	    ERREY(i1,i2,i3)=UEY(i1,i2,i3) - ( fx/omega)*sin(fx*xd)*cos(fy*yd)*sin(omega*tE);  // Ey.t = - Hz.x
	  }

	  if( method==sosup )
	  {
            // Compute errors in the time derivative
	    realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
	    FOR_3(i1,i2,i3,J1,J2,J3)
	    {
	      xd=XEP(i1,i2,i3,0)-x0;
	      yd=XEP(i1,i2,i3,1)-y0;
	      // time derivatives: 
	      errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-fy)*cos(fx*xd)*sin(fy*yd)*cos(omega*tE);  // Ex.t
	      errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - ( fx)*sin(fx*xd)*cos(fy*yd)*cos(omega*tE);  // Ey.t
	      errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt) - (-omega)*cos(fx*xd)*cos(fy*yd)*sin(omega*tH);  // Hz.t 
	    }
	  }

	} 
	else // 3D
	{
	  if( method==sosup )
	  {
	    OV_ABORT("finish me");
	  }

	  Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
	  Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
	  Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    xd=XEP(i1,i2,i3,0)-x0;
	    yd=XEP(i1,i2,i3,1)-y0;
	    zd=XEP(i1,i2,i3,2)-z0;

	    ERREX(i1,i2,i3)=UEX(i1,i2,i3) -  (a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
	    ERREY(i1,i2,i3)=UEY(i1,i2,i3) -  (a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
	    ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) -  (a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*cos(omega*tE);  // 
	  }
	}

      }

    }
    else if( knownSolutionOption==annulusEigenfunctionKnownSolution )
    {
      //kkc XXX not implemented for dsi schemes
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

      Index J1 = Range(max(I1.getBase(),uLocal.getBase(0)),min(I1.getBound(),uLocal.getBound(0)));
      Index J2 = Range(max(I2.getBase(),uLocal.getBase(1)),min(I2.getBound(),uLocal.getBound(1)));
      Index J3 = Range(max(I3.getBase(),uLocal.getBase(2)),min(I3.getBound(),uLocal.getBound(2)));

      annulusEigenFunction(error,J1,J2,J3);
            
    }
    else if( knownSolutionOption==planeMaterialInterfaceKnownSolution )
    {
      if( method==nfdtd )
      { 
	// adjust array dimensions for local arrays
	Index J1 = Range(max(I1.getBase(),uel.getBase(0)),min(I1.getBound(),uel.getBound(0)));
	Index J2 = Range(max(I2.getBase(),uel.getBase(1)),min(I2.getBound(),uel.getBound(1)));
	Index J3 = Range(max(I3.getBase(),uel.getBase(2)),min(I3.getBound(),uel.getBound(2)));

	setPlaneMaterialInterfaceMacro(error,J1,J2,J3);
      }
    }
    else if( knownSolutionOption==gaussianIntegralKnownSolution )
    {
	    
      // adjust array dimensions for local arrays
      Index J1 = Range(max(I1.getBase(),uel.getBase(0)),min(I1.getBound(),uel.getBound(0)));
      Index J2 = Range(max(I2.getBase(),uel.getBase(1)),min(I2.getBound(),uel.getBound(1)));
      Index J3 = Range(max(I3.getBase(),uel.getBase(2)),min(I3.getBound(),uel.getBound(2)));

      getGaussianIntegralSolution(error,UEX,UEY,UHZ,tE,J1,J2,J3);

	    
    }
    else if( compareToReferenceShowFile )
    {
      //kkc XXX not implemented for dsi schemes

      assert( uReference!=NULL );
	    
      realMappedGridFunction & ur = (*uReference)[grid];
	    
#ifdef USE_PPP
      realSerialArray urLocal;  getLocalArrayWithGhostBoundaries(ur,urLocal);
#else
      const realSerialArray & urLocal  =  ur;
#endif

      //            err(I1,I2,I3,C)=fabs(u(I1,I2,I3,C)-ur(I1,I2,I3,C));
      Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
      errh(Ih1,Ih2,Ih3,Ch)=fabs(uh(I1,I2,I3,Ch)-urLocal(I1,I2,I3,Ch));
      Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
      erre(Ie1,Ie2,Ie3,Ce)=fabs( ue(Ie1,Ie2,Ie3,Ce) - urLocal(Ie1,Ie2,Ie3,Ce));
    }

//     else if (forcingOption==planeWaveBoundaryForcing ||
// 	     initialConditionOption==planeWaveScatteredFieldInitialCondition )
    else if( knownSolutionOption==scatteringFromADiskKnownSolution ||
             knownSolutionOption==scatteringFromADielectricDiskKnownSolution ||
             knownSolutionOption==scatteringFromASphereKnownSolution ||
             knownSolutionOption==scatteringFromADielectricSphereKnownSolution )
    {
      //kkc XXX not implemented for dsi schemes

      const real cc0= cGrid(0)*sqrt( kx*kx+ky*ky ); // NOTE: use grid 0 values for multi-materials

      if( knownSolution==NULL )
      {
	initializeKnownSolution();
      }
      const realArray & ug = (*knownSolution)[grid];
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

      // The analytic solution assumed incident field was Ei = exp(i*k*x-i*w*t) 
      //     This gives solution
      //           Re(E)*cos(w*t) - Im(E)*sin(w*t) for Ei=cos(w*t)
      //      or   Re(E)*cos(w*t-pi/2) - Im(E)*sin(w*t-pi/2) for Ei=cos(w*t-pi/2)               
      //      i.e. Re(E)*sin(w*t) + Im(E)*cos(w*t) for Ei=sin(w*t)
      // Ex:
      Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
      Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);

//             real cost = cos(-twoPi*cc0*tH);  // *wdh* 040626 add "-"
// 	    real sint = sin(-twoPi*cc0*tH);
//             errh(Ih1,Ih2,Ih3,Ch)=fabs( uh(Ih1,Ih2,Ih3,Ch) - 
// 				       (ug(Ih1,Ih2,Ih3,Ch)*sint+ug(Ih1,Ih2,Ih3,Ch+3)*cost) );

//             cost = cos(-twoPi*cc0*tE);  // *wdh* 040626 add "-"
// 	    sint = sin(-twoPi*cc0*tE);  // *wdh* 040626 add "-"
//             erre(Ie1,Ie2,Ie3,Ce)=fabs( ue(Ie1,Ie2,Ie3,Ce) - (ug(Ie1,Ie2,Ie3,Ce)*sint+ug(Ie1,Ie2,Ie3,Ce+3)*cost) );

#ifdef USE_PPP
      const realSerialArray & ugLocal = ug.getLocalArrayWithGhostBoundaries();
#else
      const realSerialArray & ugLocal = ug; 
#endif
      if( method==nfdtd || method==sosup )
      { // do this with scalar indexing to avoid a possible bug in P++
	real *ugp = ugLocal.Array_Descriptor.Array_View_Pointer3;
	const int ugDim0=ugLocal.getRawDataSize(0);
	const int ugDim1=ugLocal.getRawDataSize(1);
	const int ugDim2=ugLocal.getRawDataSize(2);
#undef UG
#define UG(i0,i1,i2,i3) ugp[i0+ugDim0*(i1+ugDim1*(i2+ugDim2*(i3)))]

	// *wdh* 050731 real cost = cos(-twoPi*cc*tH);  
	// *wdh* 050731 real sint = sin(-twoPi*cc*tH);
	const real cost = cos(-twoPi*cc0*tH);  // *wdh* 050731 -- use cc0 
	const real sint = sin(-twoPi*cc0*tH);
	const real dcost =  twoPi*cc0*sint;  // d(sin(..))/dt 
	const real dsint = -twoPi*cc0*cost;  // d(sin(..))/dt 

	// adjust array dimensions for local arrays
	Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
	Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
	Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

	int i1,i2,i3;
	if( numberOfDimensions==2 )
	{
	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    ERREX(i1,i2,i3) = fabs(UEX(i1,i2,i3)-(UG(i1,i2,i3,ex)*sint+UG(i1,i2,i3,ex+3)*cost));
	    ERREY(i1,i2,i3) = fabs(UEY(i1,i2,i3)-(UG(i1,i2,i3,ey)*sint+UG(i1,i2,i3,ey+3)*cost));
	    ERRHZ(i1,i2,i3) = fabs(UHZ(i1,i2,i3)-(UG(i1,i2,i3,hz)*sint+UG(i1,i2,i3,hz+3)*cost));
	    if( method==sosup )
	    { // errors in time derivatives:
              errLocal(i1,i2,i3,ext) = fabs(uLocal(i1,i2,i3,ext)-(UG(i1,i2,i3,ex)*dsint+UG(i1,i2,i3,ex+3)*dcost));
              errLocal(i1,i2,i3,eyt) = fabs(uLocal(i1,i2,i3,eyt)-(UG(i1,i2,i3,ey)*dsint+UG(i1,i2,i3,ey+3)*dcost));
              errLocal(i1,i2,i3,hzt) = fabs(uLocal(i1,i2,i3,hzt)-(UG(i1,i2,i3,hz)*dsint+UG(i1,i2,i3,hz+3)*dcost));
	    }
	    
	  }
	}
	else 
	{
	  if( solveForElectricField )
	  {
	    FOR_3D(i1,i2,i3,J1,J2,J3)
	    {
	      ERREX(i1,i2,i3) =fabs(UEX(i1,i2,i3)-(UG(i1,i2,i3,ex)*sint+UG(i1,i2,i3,ex+3)*cost));
	      ERREY(i1,i2,i3) =fabs(UEY(i1,i2,i3)-(UG(i1,i2,i3,ey)*sint+UG(i1,i2,i3,ey+3)*cost));
	      ERREZ(i1,i2,i3) =fabs(UEZ(i1,i2,i3)-(UG(i1,i2,i3,ez)*sint+UG(i1,i2,i3,ez+3)*cost));
	      if( method==sosup )
	      { // errors in time derivatives:
		errLocal(i1,i2,i3,ext) = fabs(uLocal(i1,i2,i3,ext)-(UG(i1,i2,i3,ex)*dsint+UG(i1,i2,i3,ex+3)*dcost));
		errLocal(i1,i2,i3,eyt) = fabs(uLocal(i1,i2,i3,eyt)-(UG(i1,i2,i3,ey)*dsint+UG(i1,i2,i3,ey+3)*dcost));
		errLocal(i1,i2,i3,ezt) = fabs(uLocal(i1,i2,i3,ezt)-(UG(i1,i2,i3,ez)*dsint+UG(i1,i2,i3,ez+3)*dcost));
	      }
	    }
	  }
	  if( solveForMagneticField )
	  {
	    FOR_3D(i1,i2,i3,J1,J2,J3)
	    {
	      ERRHX(i1,i2,i3) =fabs(UHX(i1,i2,i3)-(UG(i1,i2,i3,hx)*sint+UG(i1,i2,i3,hx+3)*cost));
	      ERRHY(i1,i2,i3) =fabs(UHY(i1,i2,i3)-(UG(i1,i2,i3,hy)*sint+UG(i1,i2,i3,hy+3)*cost));
	      ERRHZ(i1,i2,i3) =fabs(UHZ(i1,i2,i3)-(UG(i1,i2,i3,hz)*sint+UG(i1,i2,i3,hz+3)*cost));
	    }
	  }
	}
#undef UG
	      
      }
      else
      {
	real cost = cos(-twoPi*cc*tH);  // *wdh* 040626 add "-"
	real sint = sin(-twoPi*cc*tH);
	errh(Ih1,Ih2,Ih3,Ch)=fabs( uh(Ih1,Ih2,Ih3,Ch) - 
				   (ugLocal(Ih1,Ih2,Ih3,Ch)*sint+ugLocal(Ih1,Ih2,Ih3,Ch+3)*cost) );

	cost = cos(-twoPi*cc*tE);  // *wdh* 040626 add "-"
	sint = sin(-twoPi*cc*tE);  // *wdh* 040626 add "-"
	erre(Ie1,Ie2,Ie3,Ce)=fabs( ue(Ie1,Ie2,Ie3,Ce) - (ugLocal(Ie1,Ie2,Ie3,Ce)*sint+ugLocal(Ie1,Ie2,Ie3,Ce+3)*cost) );
	    
//              // err(I1,I2,I3,C)=fabs( u(I1,I2,I3,C) - (ug(I1,I2,I3,C)*sint+ug(I1,I2,I3,C+3)*cost) );
//              // ok err(I1,I2,I3,hz)=fabs( u(I1,I2,I3,hz) - (-ug(I1,I2,I3,hz)*sint)+ug(I1,I2,I3,hz+3)*cost));

//              err(I1,I2,I3,ex)=fabs( u(I1,I2,I3,ex) + (ug(I1,I2,I3,ex)*sint+ug(I1,I2,I3,ex+3)*cost) );
//              err(I1,I2,I3,ey)=fabs( u(I1,I2,I3,ey) + (ug(I1,I2,I3,ey)*sint+ug(I1,I2,I3,ey+3)*cost) );
//              // ok err(I1,I2,I3,ey)=fabs( u(I1,I2,I3,ey) - (-ug(I1,I2,I3,ey+3)*cost) );

//              err(I1,I2,I3,hz)=fabs( u(I1,I2,I3,hz) - (ug(I1,I2,I3,hz)*sint+ug(I1,I2,I3,hz+3)*cost));
      }
    }
    else if( knownSolutionOption==userDefinedKnownSolution )
    {
      realCompositeGridFunction & cgerr = (*cgerrp);
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);      

      // save exact solution in cgrerr: 
      int numberOfTimeDerivatives=0;
      getUserDefinedKnownSolution(   t, cg,grid, cgerr[grid],I1,I2,I3,numberOfTimeDerivatives);

      errLocal(I1,I2,I3,C) = errLocal(I1,I2,I3,C) -  uLocal(I1,I2,I3,C);

    }
    else if( knownSolutionOption!=noKnownSolution )
    {
      printF("Maxwell::getErrors: unexpected value for knownSolutionOption=%i\n",(int)knownSolutionOption);
      Overture::abort("Maxwell::getErrors");
    }
    else
    {
      energyOnly = true;
    }

    getIndex(mg.gridIndexRange(),I1,I2,I3);
    RealArray errMax(C);
    errMax=0.;  // max error on this grid
	
    if ( method==dsiMatVec && !energyOnly )
    { // punt here and use a special function that knows how to exclude uns. ghost points
      #ifdef USE_PPP
        Overture::abort("Error: finish me");
      #else
        computeDSIErrors( *this,mg, uh, uhpp, ue, uepp, errh, erre, solutionNorm, maximumError );
      #endif
    }
    else if( radiusForCheckingErrors<= 0. && (method==nfdtd || method==sosup) && !energyOnly) 
    {
      Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
      Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
      if( true )
      {
	const int ng=orderOfAccuracyInSpace/2;
	const int ng3 = mg.numberOfDimensions()==2 ? 0 : ng;
 
	Index J1 = Range(max(I1.getBase(),uel.getBase(0)+ng ),min(I1.getBound(),uel.getBound(0)-ng ));
	Index J2 = Range(max(I2.getBase(),uel.getBase(1)+ng ),min(I2.getBound(),uel.getBound(1)-ng ));
	Index J3 = Range(max(I3.getBase(),uel.getBase(2)+ng3),min(I3.getBound(),uel.getBound(2)-ng3));

	int i1,i2,i3;
	FOR_3D(i1,i2,i3,J1,J2,J3)
	{
	  if( MASK(i1,i2,i3)!=0 )
	  {
	    for( int c=C.getBase(); c<=C.getBound(); c++ )
	    {
#undef ERR
#define ERR(i0,i1,i2,i3) errep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]
#undef U
#define U(i0,i1,i2,i3) uep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]

	      errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
	      solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
#undef ERR
#undef U	    
	    }
	  }
	}
	if( debug & 2 )
	{
	  fprintf(pDebugFile," *** Max errors on this processor for grid %i at t=%8.2e: ",grid,t);
	  for( int c=C.getBase(); c<=C.getBound(); c++ )
	    fprintf(pDebugFile,"%10.4e,",errMax(c));
          fprintf(pDebugFile,"\n");
	}
	for( int c=C.getBase(); c<=C.getBound(); c++ )
	{
// 	  errMax(c)=getMaxValue(errMax(c));
// 	  solutionNorm(c)=getMaxValue(solutionNorm(c));
	      
	  maximumError(c)=max(maximumError(c),errMax(c));  // max error over all grids
	}
	    
      }
    }
    else // check inside radius
    {
      // printF(" Check errors within the sphere of radius %10.2e\n",radiusForCheckingErrors);
	  
      // new way
      const int ng=orderOfAccuracyInSpace/2;
      const int ng3 = mg.numberOfDimensions()==2 ? 0 : ng;
 
      Index J1 = Range(max(I1.getBase(),uLocal.getBase(0)+ng ),min(I1.getBound(),uLocal.getBound(0)-ng ));
      Index J2 = Range(max(I2.getBase(),uLocal.getBase(1)+ng ),min(I2.getBound(),uLocal.getBound(1)-ng ));
      Index J3 = Range(max(I3.getBase(),uLocal.getBase(2)+ng3),min(I3.getBound(),uLocal.getBound(2)-ng3));

      Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
      Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
	    
      if ( method==nfdtd )
      {
	const real radiusForCheckingErrorsSquared=SQR(radiusForCheckingErrors);
		
	real radius;
	int i1,i2,i3;
#undef ERR
#define ERR(i0,i1,i2,i3) errep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]
#undef U
#define U(i0,i1,i2,i3) uep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]

	if( isRectangular )
	{
	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    radius = SQR(X0(i1,i2,i3))+SQR(X1(i1,i2,i3));
	    if( numberOfDimensions==3 ) radius+=SQR(X2(i1,i2,i3));
			
	    if( radius<radiusForCheckingErrorsSquared && MASK(i1,i2,i3)!=0 )
	    {
	      for( int c=C.getBase(); c<=C.getBound(); c++ )
	      {
		errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
		solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
				
	      }
	    }
	    else
	    {
	      for( int c=C.getBase(); c<=C.getBound(); c++ )
		ERR(i1,i2,i3,c)=0.;
	    }
			
	  }
	}
	else // curvilinear
	{
	  FOR_3D(i1,i2,i3,J1,J2,J3)
	  {
	    radius = SQR(X(i1,i2,i3,0))+SQR(X(i1,i2,i3,1));
	    if( numberOfDimensions==3 ) radius+=SQR(X(i1,i2,i3,2));
			
	    if( radius<radiusForCheckingErrorsSquared && MASK(i1,i2,i3)!=0 )
	    {
	      for( int c=C.getBase(); c<=C.getBound(); c++ )
	      {
		errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
		solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
				
	      }
	    }
	    else
	    {
	      for( int c=C.getBase(); c<=C.getBound(); c++ )
		ERR(i1,i2,i3,c)=0.;
	    }
			
	  }
	}
#undef ERR
#undef U		
	if( debug & 2 )
	{
	  fprintf(pDebugFile," *** Max errors on this processor for grid %i at t=%8.2e: ",grid,t);
	  for( int c=C.getBase(); c<=C.getBound(); c++ )
	    fprintf(pDebugFile,"%10.4e,",errMax(c));
          fprintf(pDebugFile,"\n");
	}
	
	
 	for( int c=C.getBase(); c<=C.getBound(); c++ )
 	{
// 	  errMax(c)=getMaxValue(errMax(c));
// 	  solutionNorm(c)=getMaxValue(solutionNorm(c));
		    
 	  maximumError(c)=max(maximumError(c),errMax(c));  // max error over all grids
 	}
      }
    } // end else if inside radius

    bool computeErrorsAtGhost=true;
#ifdef USE_PPP
    computeErrorsAtGhost=false;
#endif
    if( computeErrorsAtGhost && !usePML && (method==nfdtd || method==sosup) )
    {
	      
      // compute error including ghost points
      // *** this is wrong ==> only check ghost points where mask on boundary !=0 
      realMappedGridFunction & err = mgp==NULL ? (*cgerrp)[grid] : *errp;
      #ifdef USE_PPP
        realSerialArray errLocal;  getLocalArrayWithGhostBoundaries(err,errLocal);
      #else
        const realSerialArray & errLocal  =  err;
      #endif	    
      
	      
      RealArray ghostError(C,Range(1,numberOfGhost));
      ghostError=0.;
      int c,ghost;
      Index Ig1,Ig2,Ig3;
      for( int axis=0; axis<mg.numberOfDimensions(); axis++)
      {
	for( int side=0; side<=1; side++ )
	{
	  getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
          bool ok = ParallelUtility::getLocalArrayBounds(mask,maskLocal,I1,I2,I3);
          if( !ok ) continue;
	  for( ghost=1; ghost<=numberOfGhost; ghost++ )
	  {
	    getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,ghost);
	    bool ok = ParallelUtility::getLocalArrayBounds(mask,maskLocal,Ig1,Ig2,Ig3);
	    if( !ok ) continue;

	    Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
	    Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
			
	    where( maskLocal(I1,I2,I3)!=0 && maskLocal(Ig1,Ig2,Ig3)!=0 )
	    {
	      for( c=C.getBase(); c<=C.getBound(); c++ )
		ghostError(c,ghost)=max(ghostError(c,ghost),max(fabs(errLocal(Ig1,Ig2,Ig3,c))));
			    
	      for( c=C.getBase(); c<=C.getBound(); c++ )
	      {
		if( max(fabs(errLocal(Ig1,Ig2,Ig3,c)))>1.e+1 )
		{
		  fprintf(pDebugFile," *** grid=%i side,axis=%i,%i ghost=%i c=%i ****\n",grid,side,axis,ghost,c);
		  display(errLocal(Ig1,Ig2,Ig3,c),"ERROR on the ghost line",pDebugFile);
		}
	      }
			    
	    }
	  }
	}
      }

      if( debug & 2 )
      {
	for( ghost=1; ghost<=numberOfGhost; ghost++ )
	{
	  printF(" t=%9.3e: grid=%i: Errors at ghost line %i: ",t,grid,ghost);
	  for( c=C.getBase(); c<=C.getBound(); c++ )
	    printF("%8.2e, ",ghostError(c,ghost));
	  printF("\n");
	}
      }
      
    } // end if compute error at ghost

  
    EXTRACT_GFP_END(ERRORS);
  } // end for grid
  

  for( int c=C.getBase(); c<=C.getBound(); c++ )
  {
    solutionNorm(c)=getMaxValue(solutionNorm(c));
    maximumError(c)=getMaxValue(maximumError(c));
  }

  if( debug & 2 )
  {
    fprintf(pDebugFile,"\n --> t=%10.4e dt=%7.1e Errors: ",t,dt);
    for( int c=C.getBase(); c<=C.getBound(); c++ )
      fprintf(pDebugFile,"%10.4e,",maximumError(c));
    fprintf(pDebugFile,"\n");
  }

  if( method==nfdtd || method==yee || method==sosup )
  {
    realCompositeGridFunction & cgerr = *cgerrp;
    realCompositeGridFunction & cgu = cgfields[current];

    // We print the max norm and optionally some lp norms
    // const int errorNorm = parameters.dbase.get<int >("errorNorm");
    int numberOfNormsToPrint=1;
    if( errorNorm<10000 ) numberOfNormsToPrint+=errorNorm;

    for( int norm=0; norm<numberOfNormsToPrint; norm++ )
    { // norm==0 : max-norm, otherwise Lp-norm with p=norm
      int pNorm = norm==0 ? INT_MAX : norm;

      if( norm!=0 ) // max-norm values are already computed -- we could avoid doing this above --
      {
	// compute the Lp norm
	maximumError=0.;
	for( int c=C.getBase(); c<=C.getBound(); c++ )
	{
	  const int maskOption=0;  // check points where mask != 0
          const int checkErrorsAtGhostPoints=0;
	  if( pNorm<10000 )
	  {
	    maximumError(c)=lpNorm(pNorm,cgerr,c,maskOption,checkErrorsAtGhostPoints);
	    solutionNorm(c)=lpNorm(pNorm,cgu  ,c,maskOption,checkErrorsAtGhostPoints);
	  }
	  else
	  { // assume this is the max-norm
	    maximumError(c)=maxNorm(cgerr,c,maskOption,checkErrorsAtGhostPoints);
	    solutionNorm(c)=maxNorm(cgu  ,c,maskOption,checkErrorsAtGhostPoints);
	  }
	}
      }
      
      aString normName;
      if( pNorm<1000 )
	sPrintF(normName,"l%i-norm",pNorm);
      else
	normName="maxNorm";

      for( int fileio=0; fileio<2; fileio++ )
      {
	FILE *output = fileio==0 ? logFile : stdout;

	if( radiusForCheckingErrors>0 && radiusForCheckingErrors<10. )
	  fPrintF(output,"                t=%8.2e dt=%7.1e %s errors(r=%3.2f):[",
                   t,dt,radiusForCheckingErrors,(const char*)normName);
	else
	  fPrintF(output,"                t=%8.2e dt=%7.1e %s errors:[",t,dt,(const char*)normName);

	for( int c=C.getBase(); c<=C.getBound(); c++ )
	  fPrintF(output,"%10.4e,",maximumError(c));

	fPrintF(output,"], %s (u):[",(const char*)normName);

	for( int c=C.getBase(); c<=C.getBound(); c++ )
	  fPrintF(output,"%8.2e,",solutionNorm(c));

	fPrintF(output,"] (%i steps)\n",numberOfStepsTaken);
      }
    } // end for norm 
  }
  
  timing(timeForGetError)+=getCPU()-time0;
}

