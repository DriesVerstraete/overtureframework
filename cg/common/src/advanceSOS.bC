#include "DomainSolver.h"
#include "CompositeGridOperators.h"
#include "GridCollectionOperators.h"
#include "interpPoints.h"
#include "ExposedPoints.h"
#include "PlotStuff.h"
#include "InterpolateRefinements.h"
#include "Regrid.h"
#include "Ogen.h"
#include "MatrixTransform.h"
#include "updateOpt.h"
#include "App.h"
#include "ParallelUtility.h"
#include "Oges.h"
#include "AdamsPCData.h"

static bool useNewExposedPoints=true;

int
checkForSymmetry(realCompositeGridFunction & u, Parameters & parameters, const aString & label,
                 int numberOfGhostLinesToCheck);


// here are some bpp macros that are used for the explicit and implicit predictor-corrector methods
#Include pcMacros.h 


// ==============================================================================================
//  Macro: outputDebugInfoAdamsAfterDuDt
// ==============================================================================================
#beginMacro outputDebugInfoAdamsAfterDuDt(LABEL)
if( debug() & 4 || debug() & 64 )
{
  if( parameters.dbase.get<int >("myid")==0 )
  {
    fprintf(parameters.dbase.get<FILE* >("debugFile"),"\n ----------------------------------------------------------------\n"); 
    fprintf(parameters.dbase.get<FILE* >("debugFile"),LABEL);
  }
}

if( debug() & 64 )
{
  for( grid=0; grid<gf[mab0].cg.numberOfComponentGrids(); grid++ )
  {
    aString buff;
    display(ua[grid],sPrintF(buff,"\n ****ua grid=%i : du/dt(t)",grid),parameters.dbase.get<FILE* >("debugFile"),"%7.1e ");
    display(ub[grid],sPrintF(buff,"\n ****ub grid=%i: du/dt(t-dt)",grid),parameters.dbase.get<FILE* >("debugFile"),"%7.1e ");
  }
}
if( debug() & 4 || debug() & 64 )
{
  determineErrors( gf[mCur].u,gf[mCur].gridVelocity, gf[mCur].t, 0, error,
      sPrintF(" adams: errors in u at t=%e \n",gf[mCur].t) );


  determineErrors( ua,gf[mCur].gridVelocity, t0, 1, error,
                   sPrintF(" adams: errors in ut (ua) at t=%e \n",t0) );
  determineErrors( ub,gf[mOld].gridVelocity, t0-dtb, 1, error,
                  sPrintF(" adams: errors in ut (ub) at t=%e \n",t0-dtb) );
  if( parameters.dbase.get<int >("orderOfPredictorCorrector")==4 )
  {
    determineErrors( uc,gf[mOld].gridVelocity, t0-2.*dtb, 1, error,
		     sPrintF(" adams: errors in ut (uc) at t=%e \n",t0-2*dtb) );
    determineErrors( ud,gf[mOld].gridVelocity, t0-3.*dtb, 1, error,
              sPrintF(" adams: errors in ut (ud) at t=%e \n",t0-3*dtb) );
  }
  
  if( debug() & 16 )
  {
    label=sPrintF(" ***************** ab1=%8.2e ab2=%8.2e  *****************\n"
                  " ***Adams PC: gf[mOld] before advance interior t=%e\n",ab1,ab2,gf[mab1].t);
    if( twilightZoneFlow() )
      determineErrors( gf[mOld],label );
    else
      outputSolution( gf[mOld].u,gf[mOld].t,label );

    label=sPrintF(" ***Adams PC: gf[mCur] before advance interior t=%e\n",gf[mab0].t);
    if( twilightZoneFlow() )
      determineErrors( gf[mCur],label );
    else
      outputSolution( gf[mCur].u,gf[mCur].t,label );
  }

}
#endMacro



//\begin{>>CompositeGridSolverInclude.tex}{\subsection{advanceSecondOrderSystem}} 
void DomainSolver::
advanceSecondOrderSystem( real & t0, real & dt0, int & numberOfSubSteps, int & init, int initialStep  )
//=====================================================================================================
// /Description:
//   Advance some time steps of a Second-order-system (such as the equations of solid-mechanics)
//
// /t0,dt0 (input) : current time and time step.
// /numberOfSubSteps (input) : take this many steps
// /init (input) : if TRUE this is the first time step in whcih case this routine will initialize itself.
//
// /Notes:
//
//  At the start of each subStep in this function: 
//             gf[mab0]  ==  u(t)
//             gf[mab1]  ==  u(t-dt)   if numberOfGridFunctions==2, mab2==mab1
//             gf[mab2]  ==  u(t-2*dt) if numberOfGridFunctions==3 
//
//
// By the end of each subStep
//             gf[mab2]  ==  u(t+dt) : if numberOfGridFunctions==2 then mab2==mab1
//             gf[mab0]  ==  u(t)   
//             gf[mab1]  ==  u(t-dt) if numberOfGridFunctions==3 
//
//   
//\end{CompositeGridSolverInclude.tex}  
//================================================================================================
{
  FILE *& debugFile = parameters.dbase.get<FILE* >("debugFile");

  if( !parameters.dbase.get<DataBase >("modelData").has_key("AdvanceSOSData") )
    parameters.dbase.get<DataBase >("modelData").put<AdamsPCData>("AdvanceSOSData");
  AdamsPCData & sosData = parameters.dbase.get<DataBase >("modelData").get<AdamsPCData>("AdvanceSOSData");
  
  real & dtb=sosData.dtb;
  int &mab0 =sosData.mab0, &mab1=sosData.mab1, &mab2=sosData.mab2;
  int &nab0 =sosData.nab0, &nab1=sosData.nab1, &nab2=sosData.nab2, &nab3=sosData.nab3;
  int &ndt0=sosData.ndt0;
  real *dtp = sosData.dtp;


  aString method,label;
  int numberOfCorrections;
  assert( parameters.dbase.get<Parameters::TimeSteppingMethod >("timeSteppingMethod")==Parameters::adamsBashforth2 ||
          parameters.dbase.get<Parameters::TimeSteppingMethod >("timeSteppingMethod")==Parameters::adamsPredictorCorrector2 ||
          parameters.dbase.get<Parameters::TimeSteppingMethod >("timeSteppingMethod")==Parameters::adamsPredictorCorrector4 );

  assert( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 ||
          parameters.dbase.get<int >("orderOfPredictorCorrector")==4 );

  const int orderOfAccuracy = parameters.dbase.get<int >("orderOfAccuracy"); 
  const int predictorOrder = parameters.dbase.get<int >("orderOfPredictorCorrector"); // is this correct? 

  if( parameters.dbase.get<Parameters::TimeSteppingMethod >("timeSteppingMethod")==Parameters::adamsBashforth2 )
    numberOfCorrections=0;  // adams predictor only
  else
    numberOfCorrections=1; // predictor corrector
 
  // numberOfCorrections=2;
  
  if( debug() & 2 && parameters.dbase.get<int >("myid")==0 )
    fprintf(parameters.dbase.get<FILE* >("debugFile")," *** Entering advanceAdamsPredictorCorrector: t0=%e, dt0=%e *** \n",t0,dt0);
 
  int mInitial=mab0;  // save initial value
  
  // For moving grids we keep gf[mab0], gf[mab1] and gf[mab2]
  // For non-moving grids we keep gf[mab0], gf[mab1] and we set mab2==mab1

  const int numberOfGridFunctions =  movingGridProblem() ? 3 : 2; 

  mab2 = (mab0 -1 + numberOfGridFunctions) % numberOfGridFunctions;

  // 
  int mNew = mab2;    // new     : gf[mNew] : will hold u(t+dt)
  int mCur = mab0;    // current : gf[mCur] : holds u(t) 
  int mOld = mab1;    // old     : gf[mOld] : holds u(t-dt) if numberOfGridFunctions==3 otherwise mOld=mNew
  
  int nNew = nab1;    // new :    ut(t+dt)
  int nCur = nab0;    // current: ut(t)
  int nOld = nab1;    // old :    ut(t-dt)


  int grid;
  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];  
  Range N = parameters.dbase.get<Range >("Rt");   // time dependent variables
  RealArray error(numberOfComponents()+3); 
  Range C=parameters.dbase.get<int >("numberOfComponents");
  int iparam[10];
  real rparam[10];
  
  int numberOfExtraPressureTimeLevels=0;

  // real time0=getCPU();
  checkArrays(" adamsPC, start"); 
  
  if( debug() & 4 )
  {
    determineErrors( gf[mCur].u,gf[mCur].gridVelocity, gf[mCur].t, 0, error,
           sPrintF("\n ---> adams:START errors in u at t=%e \n",gf[mCur].t) );
  }
  
  if( init )
  {
    // **** To initialize the method we need to compute du/dt at times t and t-dt *****

    // this is a macro (pcMacros.h):
    const int numberOfPastTimes=1;                            // PC needs u(t-dt)
    const int numberOfPastTimeDerivatives=orderOfAccuracy-1;  // PC needs u_t(t-dt), u_t(t-2*dt), ...
    initializePredictorCorrector(adamsPC,gf[mab0].u);
    
  }
  else
  {
    // this is not an initialization step

  }
  

  if( debug() & 16 )
  {
    if( twilightZoneFlow() )
    {
      determineErrors( gf[mCur],sPrintF("\n ---> AdamsPC: Errors at start t=%e  \n",gf[mCur].t) );
    }
    else
    {
      outputSolution( gf[mCur].u,gf[mCur].t,sPrintF(" AdamsPC: Solution at start t=%e  \n",gf[mCur].t) );
    }
  }

  for( int mst=1; mst<=numberOfSubSteps; mst++ )
  {
    //       ---Adams-Bashforth Predictor
    //           u(*) <- u(t) + ab1*du/dt +ab2*du(t-dtb)/dt
    //  i.e.     gf[1]<- gf[mCur]+ ab1*ua    +ab2*ub
    //      
    //            The constants ab1 and ab2 are
    //                 ab1 = dt*( 1.+dt/(2*dtb) )   = (3/2)*dt if dtb=dt
    //                 ab2 = -dt*(  dt/(2*dtb) )    =-(1/2)*dt if dtb=dt
    //            Determined by extrapolation to time t+dt/2 from the
    //            times of ua and ub
    //
    parameters.dbase.get<int >("globalStepNumber")++;
    
    realCompositeGridFunction & ua = fn[nab0];   // pointer to du/dt
    realCompositeGridFunction & ub = fn[nab1];   // pointer to du(t-dt)/dt

    if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 ) 
    {
      nab2 =  nab0;
      nab3 =  nab1;
    }
    
    realCompositeGridFunction & uc = fn[nab2];
    realCompositeGridFunction & ud = fn[nab3];

    realCompositeGridFunction & uNew = fn[nab3]; // Here is where we put u.t(t+dt)


    // -------------------------------------------------
    // --------------- adaptive grids ------------------
    // -------------------------------------------------

    bool useNew=false;

    const int regridFrequency = parameters.dbase.get<int >("amrRegridFrequency")>0 ? parameters.dbase.get<int >("amrRegridFrequency") :
                                parameters.dbase.get<Regrid* >("regrid")==NULL ? 2 : parameters.dbase.get<Regrid* >("regrid")->getRefinementRatio();
    bool gridWasAdapted=false; // set to true if we have performed an AMR regrid on this step
    if( parameters.isAdaptiveGridProblem() && ((parameters.dbase.get<int >("globalStepNumber") % regridFrequency) == 0) )
    {
      gridWasAdapted=true;

      if( parameters.dbase.get<int >("myid")==0 )
      {
	printf("\n ***** AdamsPC: AMR regrid at step %i ***** \n\n",parameters.dbase.get<int >("globalStepNumber"));
	if( debug() & 2 )
	  fprintf(parameters.dbase.get<FILE* >("debugFile"),"\n ***** AdamsPC: AMR regrid at step %i ***** \n\n",parameters.dbase.get<int >("globalStepNumber"));
      }
      
      real timea=getCPU();


      GridFunction & gf0= gf[mCur];
      GridFunction & gf1= gf[mOld];
      
      if( parameters.useConservativeVariables() )
	gf0.primitiveToConservative();  // *wdh* 010318  -- do amr interpolation on conservative variables.

      const int numberToUpdate=1; // we update one extra grid-function to live on the new AMR grid

      if( !useNew || !parameters.isMovingGridProblem() )  // 
      { // for non-moving grids we interpolate uNew=du/dt(t-dt)
	
	// we need to extrapolate values on uNew since the interpolator may use these values
	uNew.setOperators(*gf[mCur].u.getOperators());
	uNew.interpolate(); // we need to interpolate uNew since we may use these values.
	uNew.applyBoundaryCondition(C,BCTypes::extrapolate,BCTypes::allBoundaries,0.);
	uNew.finishBoundaryConditions();

	adaptGrids( gf0, numberToUpdate,&uNew ); 
        gf1.updateToMatchGrid(gf0.cg);  // *wdh* 040928
      }
      else
      { // for moving grids we interpolate gf1 = u(t-dt)
        // du/dt(t-dt) will be recomputed below in the moving grid section

        // gf1.u.setOperators(*gf[mCur].u.getOperators());

/* ------

        // I think gf1.u has the wrong operators for moving grids
        printf(" **** gf1.cg.numberOfComponentGrids=%i ****\n",gf1.cg.numberOfComponentGrids());
	
        CompositeGrid & cg1 = *gf1.u.getCompositeGrid();
        printf(" **** cg1.numberOfComponentGrids=%i ****\n",cg1.numberOfComponentGrids());
	
        CompositeGridOperators op(gf1.cg);
	gf1.u.setOperators(op);
	

	// gf1.u.getOperators()->updateToMatchGrid(gf1.cg);

	realCompositeGridFunction & u = gf1.u;
        C=Range(u.getComponentBase(0),u.getComponentBound(0));

        u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours);
-------- */

	adaptGrids( gf0, numberToUpdate,&gf1.u ); 
        gf1.updateToMatchGrid(gf0.cg);
      }
      
      
      // the next has been moved into adaptGrids 070706
      // real time1=getCPU();
      // gf0.cg.rcData->interpolant->updateToMatchGrid( gf0.cg ); 
      // parameters.dbase.get<RealArray>("timing")(Parameters::timeForUpdateInterpolant)+=getCPU()-time1;
      // time1=getCPU();
      real time1=getCPU();
     
      if( debug() & 2 ) printf("adams:adapt step: update gf0 for moving grids...\n");
      updateForMovingGrids(gf0);  // ****

      // do here for now -- we shouldn't do this in updateForMovingGrids since this is not correct below
      // when the grids are moved
      gf0.gridVelocityTime=gf0.t -1.e10; 

      // we need to recompute the grid velocity on AMR grids -- really only need to do refinements***
      if( parameters.isMovingGridProblem() )
      {
        // recompute the grid velocity
        getGridVelocity( gf0, gf0.t );
      }

      interpolateAndApplyBoundaryConditions( gf0 );
      parameters.dbase.get<RealArray>("timing")(parameters.dbase.get<int>("timeForAmrBoundaryConditions"))+=getCPU()-time1;
      
      if( debug() & 16 )
      {
	if( parameters.dbase.get<bool >("twilightZoneFlow") )
	{
	  determineErrors( gf0,sPrintF(" AdamsPC: errors after regrid, t=%e \n",gf0.t) ) ;
	}
	else
	{
	  outputSolution( gf0.u,gf0.t,sPrintF(" ***after regrid: solution ***\n") );
	}
      }

      ua.updateToMatchGrid(gf0.cg);

      gf1.updateToMatchGrid(gf0.cg);
      if( !useNew || !parameters.isMovingGridProblem() )
        gf1.u.updateToMatchGrid(gf1.cg);
      // gf1.u=0.;
      gf1.u.setOperators(*gf0.u.getOperators());
      
      if( debug() & 2 ) printf("adams:adapt step: update gf1 for moving grids...\n");
      updateForMovingGrids(gf1);
      // do here for now -- we shouldn't do this in updateForMovingGrids since this is not correct below
      // when the grids are moved
      gf1.gridVelocityTime=gf1.t -1.e10;

      
      if( numberOfGridFunctions==3 )
      { 
	// update gf2
        // ***note: if we want to retain u(t-dt) then we must interpolate here instead, as was done
        //          for uNew in the call to adaptGrids

        GridFunction & gf2= gf[mNew];

	if( parameters.isMovingGridProblem() )
	{
	  gf2.cg=gf0.cg;  // we make a copy in this case
	}
	else
	{
	  gf2.updateToMatchGrid(gf0.cg);
	}
	gf2.u.updateToMatchGrid(gf2.cg);
	gf2.u=0.;
	gf2.u.setOperators(*gf0.u.getOperators());
      
	updateForMovingGrids(gf2);
	gf2.gridVelocityTime=gf2.t -1.e10;

      }
      

      // p has actually been interpolated ok ?? maybe ghost points are wrong?
      // **** solveForTimeIndependentVariables( gf0 ); 

      if( true )
      {

	if( parameters.useConservativeVariables() )
	  gf0.conservativeToPrimitive();  // *wdh* 010318

	real dtNew= getTimeStep( gf0 ); //       ===Choose time step====


        int numberOfSteps;
        real nextTimeToPrint=gf0.t+(numberOfSubSteps-mst+1)*dt;
	real tFinal=nextTimeToPrint;
        computeNumberOfStepsAndAdjustTheTimeStep(gf0.t,tFinal,nextTimeToPrint,numberOfSteps,dtNew);
	
        numberOfSubSteps=mst+numberOfSteps-1;

        if( true || debug() & 1 )
   	  printf("AdamsPC:recompute dt: dt(old)=%8.3e, dtNew = %8.3e, t=%9.3e (step=%i)\n",dt,dtNew,gf0.t,
                 parameters.dbase.get<int >("globalStepNumber"));
	dt=dtNew;  // *********************** should this be dt0 ???????????????????????????????????
      }
      parameters.dbase.get<RealArray>("timing")(parameters.dbase.get<int>("timeForAmrRegrid"))+=getCPU()-timea;

    }


    // moveTheGridsMacro(adamsPC,gf[mCur].u); // *wdh* 090804 

    const real ab1= dt0*(1.+dt0/(2.*dtb));  // becomes 1.5*dt0  if dt0==dtb
    const real ab2= -dt0*dt0/(2.*dtb);      //         -.5*dt0
  
    dtp[ndt0]=dt0;
    real dt1=dtp[(ndt0+1)%5];
    real dt2=dtp[(ndt0+2)%5];
    real dt3=dtp[(ndt0+3)%5];
    real dt4=dtp[(ndt0+4)%5];

    // ------------------------------------------------------
    // ----------------- Moving Grids -----------------------
    // ------------------------------------------------------
    real tb=gf[mCur].t-dt1, tc=tb-dt2, td=tc-dt3; // check me 
    const int numberOfPastTimes=0;
    const int numberOfPastTimeDerivatives=predictorOrder-1; 
    moveTheGridsMacro(adamsPC,gf[mCur].u, predictorOrder,tb,ub,tc,uc,td,ud);

    // coefficients for the 4th-order AdamsBashforth predictor for variable dt (from ab.maple)
    // For dt=fixed these would be
    // ab41 = ( 55./24.)*dt0;    
    // ab42 = (-59./24.)*dt0;
    // ab43 = ( 37./24.)*dt0;
    // ab44 = ( -9./24.)*dt0;
    const real ab41 = (6.0*dt0*dt2*dt2+12.0*dt2*dt2*dt1+8.0*dt0*dt0*dt2+24.0*dt2*dt0*dt1+
                       12.0*dt2*dt1*dt3+6.0*dt3*dt2*dt0+24.0*dt1*dt1*dt2+12.0*dt0*dt3*dt1+18.0*dt0*dt1
		       *dt1+4.0*dt0*dt0*dt3+12.0*dt1*dt1*dt3+3.0*dt0*dt0*dt0+12.0*dt0*dt0*dt1+12.0*dt1
		       *dt1*dt1)*dt0/(dt1+dt2+dt3)/dt1/(dt1+dt2)/12.0;
    const real ab42 = -dt0*dt0*(6.0*dt1*dt1+6.0*dt3*dt1+12.0*dt2*dt1+8.0*dt0*dt1+3.0*dt0*
				dt0+6.0*dt2*dt3+4.0*dt0*dt3+8.0*dt2*dt0+6.0*dt2*dt2)/dt1/(dt2+dt3)/dt2/12.0;
    const real ab43 = dt0*dt0*(6.0*dt1*dt1+6.0*dt2*dt1+6.0*dt3*dt1+8.0*dt0*dt1+3.0*dt0*dt0
			       +4.0*dt2*dt0+4.0*dt0*dt3)/dt3/dt2/(dt1+dt2)/12.0;
    const real ab44 = -(6.0*dt1*dt1+6.0*dt2*dt1+8.0*dt0*dt1+4.0*dt2*dt0+3.0*dt0*dt0)*dt0*
                        dt0/(dt1+dt2+dt3)/(dt2+dt3)/dt3/12.0;

    // coefficients for the 3rd-order AdamsBashforth predictor for variable dt (from ab.maple)
    // For dt=fixed these would be 
    // ab31 = (23/12.)*dt0; 
    // ab32 = ( -4/3.)*dt0; 
    // ab33 = ( 5/12.)*dt0; 
    const real ab31 = dt0*(2.0*dt0*dt0+6.0*dt0*dt1+3.0*dt2*dt0+6.0*dt1*dt1+6.0*dt2*dt1)/(dt1+dt2)/dt1/6.0;
    const real ab32 = -(3.0*dt1+3.0*dt2+2.0*dt0)*dt0*dt0/dt2/dt1/6.0;
    const real ab33 = dt0*dt0*(2.0*dt0+3.0*dt1)/(dt1+dt2)/dt2/6.0;


    // coefficients for 2nd order extrap:
    const real cex2a=1.+dt0/dtb;       // -> 2.
    const real cex2b=-dt0/dtb;         // -> -1.
    // coefficients for third order extrapolation (from ab.maple)
    //   These reduce to 3, -3, 1 for dt=constant
    const real cex30= (dt0+dt1+dt2)*(dt0+dt1)/(dt1+dt2)/dt1;
    const real cex31= -(dt0+dt1+dt2)/dt2*dt0/dt1;
    const real cex32= (dt0+dt1)*dt0/dt2/(dt1+dt2);

    // coefficients for 4th order extrapolation 
    //   (corresponds to   4 -6 4 1 for dt=fixed)
    const real cex40= (dt0+dt1+dt2+dt3)*(dt0+dt1+dt2)*(dt0+dt1)/(dt1+dt2+dt3)/(dt1+dt2)/dt1;
    const real cex41= -(dt0+dt1+dt2+dt3)/(dt2+dt3)*(dt0+dt1+dt2)/dt2*dt0/dt1;
    const real cex42= (dt0+dt1+dt2+dt3)*(dt0+dt1)*dt0/dt3/dt2/(dt1+dt2);
    const real cex43= -(dt0+dt1+dt2)*(dt0+dt1)*dt0/dt3/(dt2+dt3)/(dt1+dt2+dt3);

    // coefficients for fixth order extrapolation (exact for 4th order poly's)
    // These reduce to 5, -10, 10, -5, 1 for dt=constant
//    const real cex50=5., cex51=-10., cex52=10., cex53=-5., cex54=1.;
//  const real cex50=4., cex51=-6., cex52=4., cex53=-1., cex54=0.;

    const real cex50=(dt0+dt1+dt2+dt3+dt4)*(dt0+dt1+dt2+dt3)*(dt0+dt1+dt2)*(dt0+dt1)/
      (dt1+dt2+dt3+dt4)/(dt1+dt2+dt3)/(dt1+dt2)/dt1;
    const real cex51= -(dt0+dt1+dt2+dt3+dt4)/(dt2+dt3+dt4)*(dt0+dt1+dt2+dt3)/(dt2+dt3)*(
      dt0+dt1+dt2)/dt2*dt0/dt1;
    const real cex52= (dt0+dt1+dt2+dt3+dt4)*(dt0+dt1+dt2+dt3)*(dt0+dt1)*dt0/(dt3+dt4)/dt3/dt2/(dt1+dt2);
    const real cex53= -(dt0+dt1+dt2+dt3+dt4)*(dt0+dt1+dt2)*(dt0+dt1)*dt0/dt4/dt3/(dt2+dt3)/(dt1+dt2+dt3);
    const real cex54= (dt0+dt1+dt2+dt3)*(dt0+dt1+dt2)*(dt0+dt1)*dt0/dt4/(dt3+dt4)/
      (dt2+dt3+dt4)/(dt1+dt2+dt3+dt4);
    
    // ********************************************************************
    // ************  Compute ua = d(u(t)/dt  ******************************
    // ********************************************************************

    if( parameters.useConservativeVariables() )    // *wdh* 010318 convert here. Should be do before interpExposed?
      gf[mCur].primitiveToConservative();
    for( grid=0; grid<gf[mCur].cg.numberOfComponentGrids(); grid++ )
    {
	rparam[0]=gf[mCur].t;
	rparam[1]=gf[mCur].t;
	rparam[2]=gf[mCur].t; // tImplicit
	iparam[0]=grid;
        iparam[1]=gf[mCur].cg.refinementLevelNumber(grid);
        iparam[2]=numberOfStepsTaken;

// 	mappedGridSolver[grid]->getUt(gf[mCur].u[grid],gf[mCur].getGridVelocity(grid),ua[grid],iparam,rparam,
//                      Overture::nullRealMappedGridFunction(),&gf[mNew].cg[grid]);
	getUt(gf[mCur].u[grid],gf[mCur].getGridVelocity(grid),ua[grid],iparam,rparam,
                     Overture::nullRealMappedGridFunction(),&gf[mNew].cg[grid]);

    }
    
    outputDebugInfoAdamsAfterDuDt("After compute du/dt in predictor");

    if( debug() & 64 )
    {
      for( grid=0; grid<gf[mCur].cg.numberOfComponentGrids(); grid++ )
	::display(gf[mCur].u[grid],sPrintF(" ***Adams PC: u for predictor"
                   " t=%9.4e grid=%i\n",gf[mCur].t,grid),parameters.dbase.get<FILE* >("debugFile"),"%10.7f ");
      for( grid=0; grid<gf[mCur].cg.numberOfComponentGrids(); grid++ )
	::display(ua[grid],sPrintF(" ***Adams PC: du/dt (ua) for predictor"
                   " t=%9.4e grid=%i\n",gf[mCur].t,grid),parameters.dbase.get<FILE* >("debugFile"),"%10.7f ");
    }


    addArtificialDissipation(gf[mCur].u,dt0);  // add "implicit" dissipation to u 

    if( Parameters::checkForFloatingPointErrors )
      checkSolution(gf[mCur].u,"AdamsPC: u0 before adding ut",true);

    const bool useOptUpdate=true;  // use new optimized updates

    real cpu0=getCPU();
    //  gf[1].u <- gf[mCur].u + dt*( 1.5* du(t)/dt - .5 du(t-dt)/dt
    for( grid=0; grid<gf[mNew].cg.numberOfComponentGrids(); grid++ )
    {
     #ifdef USE_PPP
      RealArray u0;  getLocalArrayWithGhostBoundaries(gf[mCur].u[grid],u0);
      RealArray u1;  getLocalArrayWithGhostBoundaries(gf[mNew].u[grid],u1);
      RealArray uta; getLocalArrayWithGhostBoundaries(ua[grid],uta);
      RealArray utb; getLocalArrayWithGhostBoundaries(ub[grid],utb);
      RealArray utc; getLocalArrayWithGhostBoundaries(uc[grid],utc);
      const intSerialArray & mask1 = gf[mNew].cg[grid].mask().getLocalArray();
     #else
      const RealArray & u0 = gf[mCur].u[grid];
      const RealArray & u1 = gf[mNew].u[grid];
      const RealArray & uta= ua[grid];
      const RealArray & utb= ub[grid];
      const RealArray & utc= uc[grid];
      const intSerialArray & mask1 = gf[mNew].cg[grid].mask(); 
     #endif

      getIndex(gf[mNew].cg[grid].extendedIndexRange(),I1,I2,I3);
      // ******************************** note: may need du/dt(t-dt) at more exposed points than we have ************

      if( useOptUpdate )
      {
        const int n1a=max(u1.getBase(0),I1.getBase()), n1b=min(u1.getBound(0),I1.getBound());  
        const int n2a=max(u1.getBase(1),I2.getBase()), n2b=min(u1.getBound(1),I2.getBound());
        const int n3a=max(u1.getBase(2),I3.getBase()), n3b=min(u1.getBound(2),I3.getBound());
	
        int ierr=0;
        const int maskOption=0; // assign pts where mask>0
        int ipar[]={0,maskOption,n1a,n1b,n2a,n2b,n3a,n3b,N.getBase(),N.getBound()}; //
        real rpar[5]={0.,0.,0.,0.,0.};
	if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 )
	{
	  // u1(I1,I2,I3,N)=u0(I1,I2,I3,N) + ab1*uta(I1,I2,I3,N) + ab2*utb(I1,I2,I3,N);
          ipar[0]=2;
	  rpar[0]=ab1; rpar[1]=ab2;
	}
	else if( parameters.dbase.get<int >("orderOfPredictorCorrector")==4 )
	{
	  // here is the 4th-order predictor
	  //  gf[mNew].u[grid](I1,I2,I3,N)=gf[mCur].u[grid](I1,I2,I3,N) + 
	  //  ab41*ua[grid](I1,I2,I3,N) + ab42*ub[grid](I1,I2,I3,N) + ab43*uc[grid](I1,I2,I3,N) + ab44*ud[grid](I1,I2,I3,N);

	  // Here is the 3rd order predictor
	  // gf[mNew].u[grid](I1,I2,I3,N)=gf[mCur].u[grid](I1,I2,I3,N) + 
	  //   ab31*ua[grid](I1,I2,I3,N) + ab32*ub[grid](I1,I2,I3,N) + ab33*uc[grid](I1,I2,I3,N);

	  // u1(I1,I2,I3,N)=u0(I1,I2,I3,N) + ab31*uta(I1,I2,I3,N) + ab32*utb(I1,I2,I3,N) + ab33*utc(I1,I2,I3,N);
          ipar[0]=3;
	  rpar[0]=ab31; rpar[1]=ab32; rpar[2]=ab33;
	}
	else
	{
	  Overture::abort();
	}
	updateOpt(u0.getBase(0),u0.getBound(0),u0.getBase(1),u0.getBound(1),
		  u0.getBase(2),u0.getBound(2),u0.getBase(3),u0.getBound(3),
		  *mask1.getDataPointer(),  
		  *u0.getDataPointer(),*u1.getDataPointer(), 
		  *uta.getDataPointer(),*utb.getDataPointer(),*utc.getDataPointer(),*utc.getDataPointer(),
		  ipar[0], rpar[0], ierr );

      }
      else
      {
	if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 ) 
	{
	  // gf[mNew].u[grid](I1,I2,I3,N)=gf[mCur].u[grid](I1,I2,I3,N) + 
	  //   ab1*ua[grid](I1,I2,I3,N) + ab2*ub[grid](I1,I2,I3,N);

	  u1(I1,I2,I3,N)=u0(I1,I2,I3,N) + ab1*uta(I1,I2,I3,N) + ab2*utb(I1,I2,I3,N);
	}
	else if( parameters.dbase.get<int >("orderOfPredictorCorrector")==4 )
	{
	  // here is the 4th-order predictor
	  //  gf[mNew].u[grid](I1,I2,I3,N)=gf[mCur].u[grid](I1,I2,I3,N) + 
	  //  ab41*ua[grid](I1,I2,I3,N) + ab42*ub[grid](I1,I2,I3,N) + ab43*uc[grid](I1,I2,I3,N) + ab44*ud[grid](I1,I2,I3,N);

	  // Here is the 3rd order predictor
	  // gf[mNew].u[grid](I1,I2,I3,N)=gf[mCur].u[grid](I1,I2,I3,N) + 
	  //   ab31*ua[grid](I1,I2,I3,N) + ab32*ub[grid](I1,I2,I3,N) + ab33*uc[grid](I1,I2,I3,N);

	  u1(I1,I2,I3,N)=u0(I1,I2,I3,N) + ab31*uta(I1,I2,I3,N) + ab32*utb(I1,I2,I3,N) + ab33*utc(I1,I2,I3,N);
	}
	else
	{
	  Overture::abort();
	}
      }
      
    }
    gf[mNew].t=t0+dt0;  // gf[mNew] now lives at this time
    gf[mNew].form=gf[mCur].form;

    if( Parameters::checkForFloatingPointErrors )
      checkSolution(gf[mNew].u,"AdamsPC: u1 after adding ut",true);

    if( debug() & 16 )
    {
      for( grid=0; grid<gf[mCur].cg.numberOfComponentGrids(); grid++ )
	::display(gf[mNew].u[grid],sPrintF(" ***Adams PC: uNew after predictor update"
                   " t=%9.4e grid=%i\n",gf[mNew].t,grid),parameters.dbase.get<FILE* >("debugFile"),"%10.7f ");
    }


    if( parameters.dbase.get<int >("orderOfAccuracy")==4 )
    {
      // ******************************************
      // **********4th Order in Space**************
      // ******************************************

      if( debug() & 16  )
      {
	if( twilightZoneFlow() )
	{
	  gf[mNew].u.display(sPrintF("adamsPC: order4  gf[mNew].u before extrap p and u(ghost) (t=%8.2e)",
				     gf[mNew].t),parameters.dbase.get<FILE* >("debugFile"),"%8.5f ");
	  determineErrors( gf[mNew],sPrintF(" ***Adams PC: before extrapolate t=%e\n",gf[mNew].t) );
	}
	
	else
	  outputSolution( gf[mNew].u,gf[mNew].t,sPrintF(" ***Adams PC: before extrapolate t=%e\n",gf[mNew].t) );
      }

      // extrapolate pressure in time for BC's
      if( debug () & 1 && parameters.dbase.get<int >("myid")==0 ) 
        fprintf(parameters.dbase.get<FILE* >("debugFile")," Extrapolate the pressure to t=%e for fourth-order\n",gf[mNew].t);
      const int & pc = parameters.dbase.get<int >("pc");
      assert( pc>= 0 );
      const int numberOfGhostLines=2;

      const int orderOfExtrapForP=4;  // -1 : means use exact soln
      const int orderOfExtrapForU=4; 


      for( grid=0; grid<gf[mCur].cg.numberOfComponentGrids(); grid++ )
      {
        // ***** only need near the boundary -> to compute grad p <- --- fix this ---
        // We just need to extraolate grad(p) ON the boundary

        MappedGrid & mg0=gf[mCur].cg[grid];
        MappedGrid & mg1=gf[mNew].cg[grid];
	const IntegerArray & gridIndexRange = mg0.gridIndexRange();

	getIndex(gridIndexRange,I1,I2,I3,numberOfGhostLines);

//  	if( twilightZoneFlow() )
//  	{
//  	  fprintf(parameters.dbase.get<FILE* >("debugFile")," ***Adams PC: before interpolate Errors in p=%e\n",gf[mNew].t);
//  	  determineErrors( gf[mNew] );
//  	}
	
        OGFunction & e = *parameters.dbase.get<OGFunction* >("exactSolution");

        realArray & u0=gf[mCur].u[grid];
	realArray & u1=gf[mNew].u[grid];   // *** check this -- should be mOld ??

        #ifdef USE_PPP
        if( false )
        #else
        if( debug() & 2 && twilightZoneFlow() )
        #endif
	{
          // **** fix this for P++

	  real errMax0 = max(fabs(u0(I1,I2,I3,pc)-e(mg0,I1,I2,I3,pc,t0)));
	  real errMax1 = max(fabs(u1(I1,I2,I3,pc)-e(mg1,I1,I2,I3,pc,t0-dt1)));
          if(orderOfExtrapForP<=2 )
	  {
	    if( parameters.dbase.get<int >("myid")==0 )
	      fprintf(parameters.dbase.get<FILE* >("debugFile"),"*** Before extrap p: error in p(t-dt1=%e)=%e error in p(t=%e)=%e\n"
		    ,t0-dt1,errMax1,t0,errMax0);
	  }
	  else
	  {
	    real errMax2 = max(fabs(ua[grid](I1,I2,I3,pc)-e(mg1,I1,I2,I3,pc,t0-dt1-dt2)));
	    if( parameters.dbase.get<int >("myid")==0 )
	    {
	      fprintf(parameters.dbase.get<FILE* >("debugFile"),"*** Before extrap p: err-p(t-dt1-dt2=%e)=%e err-p(t-dt1=%e)=%e err-p(t=%e)=%e\n"
		      ,t0-dt1-dt2,errMax2,t0-dt1,errMax1,t0,errMax0);

	      fprintf(parameters.dbase.get<FILE* >("debugFile"),"*** Before extrap p: cex30,cex31,cex32=%16.14e, %16.14e, %16.14e\n",cex30,cex31,cex32);
	      fprintf(parameters.dbase.get<FILE* >("debugFile"),"*** Before extrap p: dt0,dt1,dt2=%16.14e, %16.14e, %16.14e\n",dt0,dt1,dt2);
	    }
	    
	  }
	  
	}
	
	if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 )
	{
          if( false )
	  {
	    u1(I1,I2,I3,pc)=cex2a*u0(I1,I2,I3,pc)+cex2b*u1(I1,I2,I3,pc);
	  }
	  else
	  {
            // for the next time step ua should be equal to u1 of this time step
            // but ua of the next time step equals ub of the time step ... therefore save u1 in ub
            if( parameters.dbase.get<int >("myid")==0 ) fprintf(parameters.dbase.get<FILE* >("debugFile")," *** extrap in time (3-points)\n");
	    
            #ifdef USE_PPP
   	      realSerialArray u1Local; getLocalArrayWithGhostBoundaries(u1,u1Local);
   	      realSerialArray u0Local; getLocalArrayWithGhostBoundaries(u0,u0Local);
   	      realSerialArray uaLocal; getLocalArrayWithGhostBoundaries(ua[grid],uaLocal);
   	      realSerialArray ubLocal; getLocalArrayWithGhostBoundaries(ub[grid],ubLocal);

               Index J1=I1, J2=I2, J3=I3;
               bool ok = ParallelUtility::getLocalArrayBounds(u0,u0Local,J1,J2,J3);               
               if( ok )
	       {
                 ubLocal(J1,J2,J3,pc)=u1Local(J1,J2,J3,pc);
		 u1Local(J1,J2,J3,pc)=cex30*u0Local(J1,J2,J3,pc)+cex31*u1Local(J1,J2,J3,pc)+cex32*uaLocal(J1,J2,J3,pc);
	       }

//            ub[grid](I1,I2,I3,pc)=u1(I1,I2,I3,pc);
// 	      u1(I1,I2,I3,pc)=cex30*u0(I1,I2,I3,pc)+cex31*u1(I1,I2,I3,pc)+cex32*ua[grid](I1,I2,I3,pc);

	    #else
              ub[grid](I1,I2,I3,pc)=u1(I1,I2,I3,pc);
	      u1(I1,I2,I3,pc)=cex30*u0(I1,I2,I3,pc)+cex31*u1(I1,I2,I3,pc)+cex32*ua[grid](I1,I2,I3,pc);
            #endif

            if( parameters.dbase.get<int >("myid")==0 ) fprintf(parameters.dbase.get<FILE* >("debugFile")," *** extrap in time (3-points) DONE.\n");

	  }
	  
	}
	else
	{
          if( orderOfExtrapForP==-1 )
	  {
	    assert( twilightZoneFlow() );
	    u1(I1,I2,I3,pc)=e(mg0,I1,I2,I3,pc,t0+dt0); // **** do this for now ****
	  }
	  else
	  {
            // for the next time step ua should be equal to u1 of this time step
            // but ua of the next time step equals ud of this time step ... therefore save u1 in ud
	    
            ud[grid](I1,I2,I3,pc)=u1(I1,I2,I3,pc);
//            u1(I1,I2,I3,pc)=cex2a*u0(I1,I2,I3,pc)+cex2b*u1(I1,I2,I3,pc);
//            u1(I1,I2,I3,pc)=cex30*u0(I1,I2,I3,pc)+cex31*u1(I1,I2,I3,pc)+cex32*ua[grid](I1,I2,I3,pc);
	    
	    
            if( orderOfExtrapForP==2 )
	    {
	      u1(I1,I2,I3,pc)=cex2a*u0(I1,I2,I3,pc)+cex2b*u1(I1,I2,I3,pc);
	    }
            else if( orderOfExtrapForP==3 )
	    {
	      u1(I1,I2,I3,pc)=cex30*u0(I1,I2,I3,pc)+cex31*u1(I1,I2,I3,pc)+cex32*ua[grid](I1,I2,I3,pc);
	    }
	    else if( orderOfExtrapForP==4 )
	    {
              // 4th order extrap
	      u1(I1,I2,I3,pc)=(cex40*u0(I1,I2,I3,pc)+
			       cex41*u1(I1,I2,I3,pc)+
			       cex42*ua[grid](I1,I2,I3,pc)+
			       cex43*ub[grid](I1,I2,I3,pc));
	    }
	    else
	    {
	      u1(I1,I2,I3,pc)=(cex50*u0(I1,I2,I3,pc)+
			       cex51*u1(I1,I2,I3,pc)+
			       cex52*ua[grid](I1,I2,I3,pc)+
			       cex53*ub[grid](I1,I2,I3,pc)+
			       cex54*uc[grid](I1,I2,I3,pc));
	    }
	    

            if( false )
	    {
	      real maxErr=max(fabs(u1(I1,I2,I3,pc)-e(mg0,I1,I2,I3,pc,t0+dt0)));
	      fprintf(parameters.dbase.get<FILE* >("debugFile")," $$$$ Max error in extrapolating p at t=%8.2e is %8.2e\n",t0+dt0,maxErr);
	    
	      // u1(I1,I2,I3,pc)=e(mg0,I1,I2,I3,pc,t0+dt0); // **** do this for now ****
	    }
	    
	  }
	  
	}
	
    
        // We also extrapolate in time the ghost values of u -- used in the BC's
	getIndex(gridIndexRange,I1,I2,I3,numberOfGhostLines);
        Range V(parameters.dbase.get<int >("uc"),parameters.dbase.get<int >("uc")+parameters.dbase.get<int >("numberOfDimensions")-1);
        int side,axis;
        for( axis=0; axis<parameters.dbase.get<int >("numberOfDimensions"); axis++ )
	{
	  for( side=0; side<=1; side++ )
	  {
            const int is=1-2*side;
            if( mg0.boundaryCondition(side,axis)>0 )
	    {
              // set the two ghost points
              if( side==0 )
  	        Iv[axis]=Range(gridIndexRange(side,axis)-2,gridIndexRange(side,axis)-1);
	      else
  	        Iv[axis]=Range(gridIndexRange(side,axis)+1,gridIndexRange(side,axis)+2);
		
	      if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 )
	      {
		if( false )
		{
		  u1(I1,I2,I3,V)=cex2a*u0(I1,I2,I3,V)+cex2b*u1(I1,I2,I3,V);
		}
		else
		{
		  // for the next time step ua should be equal to u1 of this time step
		  // but ua of the next time step equals ub of the time step ... therefore save u1 in ub
                  if( parameters.dbase.get<int >("myid")==0 ) fprintf(parameters.dbase.get<FILE* >("debugFile")," *** extrap U in time (3-points)\n");
                #ifdef USE_PPP
       	          realSerialArray u1Local; getLocalArrayWithGhostBoundaries(u1,u1Local);
       	          realSerialArray u0Local; getLocalArrayWithGhostBoundaries(u0,u0Local);
       	          realSerialArray uaLocal; getLocalArrayWithGhostBoundaries(ua[grid],uaLocal);
   	          realSerialArray ubLocal; getLocalArrayWithGhostBoundaries(ub[grid],ubLocal);

                  Index J1=I1, J2=I2, J3=I3;
                  bool ok = ParallelUtility::getLocalArrayBounds(u0,u0Local,J1,J2,J3);               
                  if( ok )
 	          {
                    ubLocal(J1,J2,J3,V)=u1Local(J1,J2,J3,V);
 	            u1Local(J1,J2,J3,V)=cex30*u0Local(J1,J2,J3,V)+cex31*u1Local(J1,J2,J3,V)+cex32*uaLocal(J1,J2,J3,V);
 	          }

// 		  ub[grid](I1,I2,I3,V)=u1(I1,I2,I3,V);
// 		  u1(I1,I2,I3,V)=cex30*u0(I1,I2,I3,V)+cex31*u1(I1,I2,I3,V)+cex32*ua[grid](I1,I2,I3,V);

	        #else
		  ub[grid](I1,I2,I3,V)=u1(I1,I2,I3,V);
		  u1(I1,I2,I3,V)=cex30*u0(I1,I2,I3,V)+cex31*u1(I1,I2,I3,V)+cex32*ua[grid](I1,I2,I3,V);
                #endif

                  if( parameters.dbase.get<int >("myid")==0 ) fprintf(parameters.dbase.get<FILE* >("debugFile")," *** extrap U in time (3-points) DONE\n");

		}

	      }
	      else // fourth order in time
	      {
                if( orderOfExtrapForU==-1 )
		{
		  assert( twilightZoneFlow() );
		  u1(I1,I2,I3,V)=e(mg0,I1,I2,I3,V,t0+dt0); // **** do this for now ****
		}
                else if( orderOfExtrapForU==2 )
		{
                  // printf(" $$$$ extrap u ghost at t=%8.2e $$$$$\n",gf[mNew].t);
  		  ud[grid](I1,I2,I3,V)=u1(I1,I2,I3,V);
	  	  u1(I1,I2,I3,V)= cex2a*u0(I1,I2,I3,V)
		                 +cex2b*u1(I1,I2,I3,V);
		}
                else if( orderOfExtrapForU==3 )
		{
                  // printf(" $$$$ extrap u ghost at t=%8.2e $$$$$\n",gf[mNew].t);
  		  ud[grid](I1,I2,I3,V)=u1(I1,I2,I3,V);
	  	  u1(I1,I2,I3,V)= cex30*u0(I1,I2,I3,V)
			         +cex31*u1(I1,I2,I3,V)
		                 +cex32*ua[grid](I1,I2,I3,V);

		}
                else if( orderOfExtrapForU==4 )
		{
                  // printf(" $$$$ extrap u ghost at t=%8.2e $$$$$\n",gf[mNew].t);
  		  ud[grid](I1,I2,I3,V)=u1(I1,I2,I3,V);
	  	  u1(I1,I2,I3,V)= cex40*u0(I1,I2,I3,V)
			         +cex41*u1(I1,I2,I3,V)
			         +cex42*ua[grid](I1,I2,I3,V)
		                 +cex43*ub[grid](I1,I2,I3,V);
		}
                else if( orderOfExtrapForU==5 )
		{
                  // printf(" $$$$ extrap u ghost at t=%8.2e $$$$$\n",gf[mNew].t);

  		  ud[grid](I1,I2,I3,V)=u1(I1,I2,I3,V);
	  	  u1(I1,I2,I3,V)= cex50*u0(I1,I2,I3,V)
			         +cex51*u1(I1,I2,I3,V)
			         +cex52*ua[grid](I1,I2,I3,V)
			         +cex53*ub[grid](I1,I2,I3,V)
		                 +cex54*uc[grid](I1,I2,I3,V);
		}
	      }
	    }
	  }
	  // set back to gridIndexRange to avoid re-doing corners: *** is this ok for 3D ???
	  Iv[axis]=Range(gridIndexRange(0,axis),gridIndexRange(1,axis));
	}
	

	// we need initial guesses for \uv at all ghost points
        // Could use div(u) here

        // *** fix this ***
//          Range V(parameters.dbase.get<int >("uc"),parameters.dbase.get<int >("uc")+parameters.dbase.get<int >("numberOfDimensions")-1);
//          u1.applyBoundaryCondition(V,BCTypes::dirichlet,Parameters::noSlipWall,0,gf[mNew].t);

//          BoundaryConditionParameters extrapParams;
//  	extrapParams.dbase.get< >("ghostLineToAssign")=1;
//  	extrapParams.dbase.get< >("orderOfExtrapolation")=parameters.dbase.get<int >("orderOfAccuracy")+1;
//  	u1.applyBoundaryCondition(V,BCTypes::extrapolate,BCTypes::allBoundaries,0.,gf[mNew].t,extrapParams);

//  	extrapParams.dbase.get< >("ghostLineToAssign")=2;
//  	extrapParams.dbase.get< >("orderOfExtrapolation")=parameters.dbase.get<int >("orderOfAccuracy")+1; // 3;
//  	u1.applyBoundaryCondition(V,BCTypes::extrapolate,BCTypes::allBoundaries,0.,gf[mNew].t,extrapParams);
//          u1.finishBoundaryConditions();
	
        #ifndef USE_PPP
        if( debug() & 2 && parameters.dbase.get<bool >("twilightZoneFlow") )
	{
	  getIndex(gridIndexRange,I1,I2,I3,numberOfGhostLines);
	  real errMax0 = max(fabs(u1(I1,I2,I3,V)-e(mg1,I1,I2,I3,V,gf[mNew].t)));
          if( parameters.dbase.get<int >("myid")==0 )
	    fprintf(parameters.dbase.get<FILE* >("debugFile"),"*** After extrap ghost error in uv(t=%e)=%e\n",gf[mNew].t,errMax0);
	}
	if( debug() & 8  && parameters.dbase.get<bool >("twilightZoneFlow") )
	{
          Range PV(parameters.dbase.get<int >("pc"),parameters.dbase.get<int >("uc")+parameters.dbase.get<int >("numberOfDimensions")-1);
	  display(fabs(u1(I1,I2,I3,PV)-e(mg1,I1,I2,I3,PV,gf[mNew].t)),"ERROR after extrap ghost u in time",
		  parameters.dbase.get<FILE* >("debugFile"),"%8.2e ");
	}
        #endif
	
        // *set to true* u1(I1,I2,I3,pc)=e(gf[mNew].cg[grid],I1,I2,I3,pc,gf[mNew].t);
	
      }
    }

    if( debug() & 16  )
    {
      label=sPrintF(" ***Adams PC: predictor: before interpolate t=%e\n",gf[mNew].t);
      if( twilightZoneFlow() )
	determineErrors( gf[mNew],label );
      else
	outputSolution( gf[mNew].u,gf[mNew].t,label );
    }
    parameters.dbase.get<RealArray>("timing")(parameters.dbase.get<int>("timeForAddUt"))+=getCPU()-cpu0;


    interpolateAndApplyBoundaryConditions( gf[mNew],&gf[mCur],dt0 );


    if( debug() & 8 )
    {
      label=sPrintF(" ***Adams PC: after boundary conditions in predictor, t=%e\n",gf[mNew].t);
      if( twilightZoneFlow() )
	determineErrors( gf[mNew],label );
      else
	outputSolution( gf[mNew].u,gf[mNew].t,label );
    }
    if( debug() & 4 || debug() & 64 )
    {
      for( grid=0; grid<gf[mNew].cg.numberOfComponentGrids(); grid++ )
	::display(gf[mNew].u[grid],sPrintF(" ***Adams PC: after apply boundary conditions in predictor"
                   " t=%9.4e grid=%i\n",gf[mNew].t,grid),parameters.dbase.get<FILE* >("debugFile"),"%10.7f ");
    }

    cpu0=getCPU();
    if( poisson!=NULL && poisson->isSolverIterative() && parameters.dbase.get<int >("orderOfAccuracy")!=4 )
    {
      // extrapolate p in time as an initial guess for iterative solvers
      const int & pc = parameters.dbase.get<int >("pc");
      assert( pc>= 0 );
      for( grid=0; grid<gf[mCur].cg.numberOfComponentGrids(); grid++ )
      {
	getIndex(gf[mCur].cg[grid].dimension(),I1,I2,I3);
        // note that initially gf[mNew](.,.,.,pc) = p(t-dt)
        // **** check this -- it's doesn't seem to make much difference whether we
        // extrpolate or use the old value ??
        #ifdef USE_PPP
	  realSerialArray uNew; getLocalArrayWithGhostBoundaries(gf[mNew].u[grid],uNew);
	  realSerialArray uCur; getLocalArrayWithGhostBoundaries(gf[mCur].u[grid],uCur);
	  realSerialArray uOld; getLocalArrayWithGhostBoundaries(gf[mOld].u[grid],uOld);
          bool ok = ParallelUtility::getLocalArrayBounds(gf[mNew].u[grid],uNew,I1,I2,I3); 
          if( !ok ) continue;
	#else
          const realSerialArray & uNew=gf[mNew].u[grid];
          const realSerialArray & uCur=gf[mCur].u[grid];
          const realSerialArray & uOld=gf[mOld].u[grid];
        #endif

        uNew(I1,I2,I3,pc)=cex2a*uCur(I1,I2,I3,pc)+cex2b*uOld(I1,I2,I3,pc);
       	//  gf[mNew].u[grid](I1,I2,I3,pc)=cex2a*gf[mCur].u[grid](I1,I2,I3,pc)+cex2b*gf[mOld].u[grid](I1,I2,I3,pc);

	if( debug() & 4 )
	{
	  Range all;
	  for( grid=0; grid<gf[mNew].cg.numberOfComponentGrids(); grid++ )
	    ::display(gf[mNew].u[grid](all,all,all,pc),sPrintF(" ***Adams PC: after extrap p in time"
					       " t=%9.4e grid=%i\n",gf[mNew].t,grid),parameters.dbase.get<FILE* >("debugFile"),"%10.7f ");
	}

// **	gf[mNew].u[grid](I1,I2,I3,pc)=gf[mCur].u[grid](I1,I2,I3,pc);
      }
    }
    parameters.dbase.get<RealArray>("timing")(parameters.dbase.get<int>("timeForAddUt"))+=getCPU()-cpu0;

    
    solveForTimeIndependentVariables( gf[mNew] ); 

    // correct for forces on moving bodies
    if( movingGridProblem() )
      correctMovingGrids( t0,t0+dt0,gf[mCur],gf[mNew] ); 


    if( debug() & 4 )
    {
      real max1=max(fabs(gf[mNew].u)), max2=max(fabs(gf[mCur].u));
      if( parameters.dbase.get<int >("myid")==0 )
      {
	fprintf(parameters.dbase.get<FILE* >("debugFile"),
		"AdamsPredictorCorrector After solve for time indep. vars: "
		"max(fabs(gf[mNew]))=%e, max(fabs(gf[mCur]))=%e \n",
		max1,max2); 
      }
    }
    if( debug() & 8 )
    {
      label=sPrintF(" AdamsPC: After Predictor, t0+dt0: t0=%e, dt0=%e  \n",t0,dt0);
      if( twilightZoneFlow() )
	determineErrors( gf[mNew],label );
      else
	outputSolution( gf[mNew].u,gf[mNew].t,label );
    }

    // For constant dt the coefficients would be
    //    am41=(9./24.)*dt0, am42=(19./24.)*dt0, am43=(-5./24.)*dt0, am44=(1./24.)*dt0;
    // Here are the coeff for variable dt: (from ab.maple)
    const real am41 = (6.0*dt1*dt1+6.0*dt2*dt1+8.0*dt0*dt1+4.0*dt2*dt0+3.0*dt0*dt0)*dt0/(
                       dt0+dt1+dt2)/(dt0+dt1)/12.0;
    const real am42 = dt0*(dt0*dt0+4.0*dt0*dt1+2.0*dt2*dt0+6.0*dt1*dt1+6.0*dt2*dt1)/(dt1+dt2)/dt1/12.0;
    const real am43 = -dt0*dt0*dt0*(dt0+2.0*dt1+2.0*dt2)/(dt0+dt1)/dt2/dt1/12.0;
    const real am44 = (dt0+2.0*dt1)*dt0*dt0*dt0/(dt0+dt1+dt2)/(dt1+dt2)/dt2/12.0;

    for( int correction=0; correction<numberOfCorrections; correction++ )
    {
      //       ---Adams Moulton Corrector
      //          u(t+dt) <- u(t) + dt* ( (1/2) du(*)/dt + (1/2) du(t)/dt )
      //          gf[mNew]  gf[mCur]              ub               ua
      real am1=.5*dt0;
      real am2=.5*dt0;

      // real am41=(9./24.)*dt0, am42=(19./24.)*dt0, am43=(-5./24.)*dt0, am44=(1./24.)*dt0;

      //       --- f(*) <- du(*)/dt(t)
      //           uNew      d gf[mNew].u/dt
      if( parameters.useConservativeVariables() )    // *wdh* 010318 convert here. 
      {
        gf[mCur].primitiveToConservative();
        gf[mNew].primitiveToConservative();
      }
      
      for( grid=0; grid<gf[mNew].cg.numberOfComponentGrids(); grid++ )
      {
	rparam[0]=gf[mNew].t;
	rparam[1]=gf[mNew].t;
	rparam[2]=gf[mNew].t; // tImplicit
	iparam[0]=grid;
        iparam[1]=gf[mNew].cg.refinementLevelNumber(grid);
        iparam[2]=numberOfStepsTaken;
// 	mappedGridSolver[grid]->getUt(gf[mNew].u[grid],gf[mNew].getGridVelocity(grid),uNew[grid],iparam,rparam,
//                          Overture::nullRealMappedGridFunction(),&gf[mNew].cg[grid]);
	getUt(gf[mNew].u[grid],gf[mNew].getGridVelocity(grid),uNew[grid],iparam,rparam,
                         Overture::nullRealMappedGridFunction(),&gf[mNew].cg[grid]);
      }

      if( debug() & 8 || debug() & 64 )
      {
	determineErrors( ua,gf[mCur].gridVelocity, t0, 1, error,
           sPrintF(" adams:corrector: errors in ut (ua) at t=%e \n",t0) );

	if( parameters.dbase.get<int >("myid")==0 )
	  fprintf(parameters.dbase.get<FILE* >("debugFile")," ****>> &uNew=%i &ub=%i\n",&uNew,&ub);
	
        display(uNew[0],sPrintF("uNew[0] at t=%e\n",gf[mNew].t),parameters.dbase.get<FILE* >("debugFile"),"%5.2f ");
        if( parameters.isMovingGridProblem() )
          display(gf[mNew].getGridVelocity(0),sPrintF("gridVelocity[0] at t=%e\n",gf[mNew].t),
                                                      parameters.dbase.get<FILE* >("debugFile"),"%5.2f ");
	
	determineErrors( uNew,gf[mNew].gridVelocity, gf[mNew].t, 1, error,
               sPrintF(" adams:corrector: errors in ut (uNew) at t=%e \n",gf[mNew].t) );

	if( parameters.dbase.get<int >("orderOfPredictorCorrector")==4 )
	{
	  if( parameters.isMovingGridProblem() )
            determineErrors( uc,gf[mNew].gridVelocity, t0-2.*dtb, 1, error,
                 sPrintF(" adams:corrector: errors in ut (uc) at t=%e \n",t0-2*dtb) );

	  determineErrors( ud,gf[mNew].gridVelocity, t0+dtb, 1, error,
                      sPrintF(" adams:corrector: errors in ut (ud) at t=%e \n",t0+dt) );
	}
      }
    
      addArtificialDissipation(gf[mNew].u,dt0);  // add "implicit" dissipation to u 
     
      if( Parameters::checkForFloatingPointErrors )
	checkSolution(gf[mNew].u,"AdamsPC: u1 before corrector",true);

      real cpu0=getCPU();
      for( grid=0; grid<gf[mNew].cg.numberOfComponentGrids(); grid++ )
      {
	getIndex(gf[mNew].cg[grid].extendedIndexRange(),I1,I2,I3);

	if( useOptUpdate )
	{
         #ifdef USE_PPP
          RealArray u0;  getLocalArrayWithGhostBoundaries(gf[mCur].u[grid],u0);
          RealArray u1;  getLocalArrayWithGhostBoundaries(gf[mNew].u[grid],u1);
          RealArray uta; getLocalArrayWithGhostBoundaries(ua[grid],uta);
          RealArray utb; getLocalArrayWithGhostBoundaries(ub[grid],utb);
          RealArray utc; getLocalArrayWithGhostBoundaries(uc[grid],utc);
          RealArray utd; getLocalArrayWithGhostBoundaries(ud[grid],utd);
          const intSerialArray & mask1 = gf[mNew].cg[grid].mask().getLocalArray();

        #else
          const RealArray & u0 = gf[mCur].u[grid];
          const RealArray & u1 = gf[mNew].u[grid];
          const RealArray & uta= ua[grid];
          const RealArray & utb= ub[grid];
          const RealArray & utc= uc[grid];
          const RealArray & utd= ud[grid];
          const intSerialArray & mask1 = gf[mNew].cg[grid].mask(); 
         #endif

          const int n1a=max(u1.getBase(0),I1.getBase()), n1b=min(u1.getBound(0),I1.getBound());  
          const int n2a=max(u1.getBase(1),I2.getBase()), n2b=min(u1.getBound(1),I2.getBound());
          const int n3a=max(u1.getBase(2),I3.getBase()), n3b=min(u1.getBound(2),I3.getBound());
	
	  int ierr=0;
          const int maskOption=0; // assign pts where mask>0
	  int ipar[]={0,maskOption,n1a,n1b,n2a,n2b,n3a,n3b,N.getBase(),N.getBound()}; //
	  real rpar[5]={0.,0.,0.,0.,0.};
          real *ut1p, *ut2p, *ut3p, *ut4p;
	  if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 )
	  {
	    ipar[0]=2;
	    rpar[0]=am1; rpar[1]=am2;
            ut1p=utb.getDataPointer();
	    ut2p=uta.getDataPointer();
            ut3p=ut2p;  // not used
	    ut4p=ut2p;  // not used
	  }
	  else if( parameters.dbase.get<int >("orderOfPredictorCorrector")==4 )
	  {
	    ipar[0]=4;
	    rpar[0]=am41; rpar[1]=am42; rpar[2]=am43; rpar[3]=am44;
            ut1p=utd.getDataPointer();
            ut2p=uta.getDataPointer();
            ut3p=utb.getDataPointer();
            ut4p=utc.getDataPointer();
	  }
	  else
	  {
	    Overture::abort();
	  }
	  updateOpt(u0.getBase(0),u0.getBound(0),u0.getBase(1),u0.getBound(1),
		    u0.getBase(2),u0.getBound(2),u0.getBase(3),u0.getBound(3),
		    *mask1.getDataPointer(),  
		    *u0.getDataPointer(),*u1.getDataPointer(), 
		    *ut1p, *ut2p, *ut3p, *ut4p,
		    ipar[0], rpar[0], ierr );

	}
	else
	{
	  if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 )
	  {
	    gf[mNew].u[grid](I1,I2,I3,N)=gf[mCur].u[grid](I1,I2,I3,N)+am1*ub[grid](I1,I2,I3,N) 
	      + am2*ua[grid](I1,I2,I3,N);
	  }
	  else if( parameters.dbase.get<int >("orderOfPredictorCorrector")==4 )
	  {
	    gf[mNew].u[grid](I1,I2,I3,N)=gf[mCur].u[grid](I1,I2,I3,N)+am41*ud[grid](I1,I2,I3,N) 
	      +am42*ua[grid](I1,I2,I3,N) 
	      +am43*ub[grid](I1,I2,I3,N) 
	      +am44*uc[grid](I1,I2,I3,N);

	  }
	}
	
      }
      // * gf[mNew].t=t0+dt0;  //  gf[mNew] now lives at this time
      parameters.dbase.get<RealArray>("timing")(parameters.dbase.get<int>("timeForAddUt"))+=getCPU()-cpu0;

      if( Parameters::checkForFloatingPointErrors )
	checkSolution(gf[mNew].u,"AdamsPC: u1 after corrector",true);

      if( debug() & 16  )
      {
	label=sPrintF(" ***Adams PC: corrector: before interpolate t=%e\n",gf[mNew].t);
	if( twilightZoneFlow() )
	  determineErrors( gf[mNew],label );
	else
	  outputSolution( gf[mNew].u,gf[mNew].t,label );
      }

      interpolateAndApplyBoundaryConditions( gf[mNew],&gf[mCur],dt0 );

      if( debug() & 8 )
      {
	label=sPrintF("======advance2 After boundary conditions in corrector, t=%e \n",t0+dt0);
	if( twilightZoneFlow() )
	  determineErrors( gf[mNew],label );
	else
          outputSolution( gf[mNew].u,gf[mNew].t,label );
      }
    
      solveForTimeIndependentVariables( gf[mNew] ); 

      // correct for forces on moving bodies if we have more corrections.
      if( movingGridProblem() && (correction+1)<numberOfCorrections)
	correctMovingGrids( t0,t0+dt0,gf[mCur],gf[mNew] ); 
    
      if( debug() & 4 )
	printf("AdamsPredictorCorrector After correction: max(fabs(gf[mNew]))=%e, max(fabs(gf[mCur]))=%e \n",
	       max(fabs(gf[mNew].u)),max(fabs(gf[mCur].u)));

      if( debug() & 8 )
      {
	if( twilightZoneFlow() )
	{
	  determineErrors( gf[mNew],sPrintF("======advance2 Errors After PECE, t0+dt0=%e \n",t0+dt0) );
	}
	else
	{
          outputSolution( gf[mNew].u,gf[mNew].t,sPrintF( " ======advance2 solution after PECE, t0+dt0=%e \n",t0+dt0));
	}
      }
    }// end for correction.
    
    
    
    // permute (mab0,mab1,mab2) 
    mab0 = (mab0-1 + numberOfGridFunctions) % numberOfGridFunctions;
    mab1 = (mab1-1 + numberOfGridFunctions) % numberOfGridFunctions;
    mab2 = (mab0-1 + numberOfGridFunctions) % numberOfGridFunctions;

    mNew=mab2;
    mCur=mab0;
    mOld=mab1;

    if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 ) 
    {
      nab0 = (nab0+1) % 2;
      nab1 = (nab1+1) % 2;
    }
    else
    {
      nab0 = (nab0-1 +4) % 4;
      nab1 = (nab1-1 +4) % 4;
      nab2 = (nab2-1 +4) % 4;
      nab3 = (nab3-1 +4) % 4;
    }

    ndt0=(ndt0-1 +5)%5;  // for dtp[]
    
    dtb=dt0;
    t0+=dt0;

    if( (mst-1) % parameters.dbase.get<int >("frequencyToSaveSequenceInfo") == 0 )
      saveSequenceInfo(t0,fn[nab1]);

    output( gf[mab0],initialStep+mst-1 ); // output to files, user defined output
    
  }

  if( parameters.useConservativeVariables() )
    gf[mab0].conservativeToPrimitive();
  
  // update the current solution:  
  current = mab0;
  
//   if( mab0!=mInitial || parameters.isAdaptiveGridProblem() )
//   {
//     solution.u.reference(gf[mab0].u);
//     solution.t=gf[mab0].t;
    
//     if( movingGridProblem()  || parameters.isAdaptiveGridProblem() )  // 990826
//     {
//       solution.cg.reference(gf[mab0].cg);
//       // solution.gridVelocity.reference(gf[mab0].gridVelocity);

//       solution.updateGridVelocityArrays();
//       solution.referenceGridVelocity(gf[mab0]);

//       if( false )
//       {
// 	for( grid=0; grid<solution.cg.numberOfComponentGrids(); grid++ )
// 	{
// 	  if( parameters.gridIsMoving(grid) )
// 	  {
//             display(solution.getGridVelocity(grid),sPrintF("adams: solution.gridVelocity grid=%i time t=%8.2e",grid,solution.t),parameters.dbase.get<FILE* >("debugFile"),"%5.2f ");
//             display(gf[mab0].getGridVelocity(grid),sPrintF("adams: gf[mab0].gridVelocity grid=%i time t=%8.2e",grid,solution.t),parameters.dbase.get<FILE* >("debugFile"),"%5.2f ");
// 	  }
// 	}
//       }
      
// //        if( true ) // *** is this needed ???
// //        {
// //  	solution.cg.setMaskAtRefinements();
// //        }
      
//       if( false && movingGridProblem() )
//       {
//         // This is for testing
//         CompositeGrid & cg = solution.cg;

//         // Do this for now:
//         cg.destroy(MappedGrid::THEcenter | MappedGrid::THEvertex );
//         cg.update(MappedGrid::THEcenter | MappedGrid::THEvertex,MappedGrid::COMPUTEgeometry);

// 	for( grid=0; grid<solution.cg.numberOfBaseGrids(); grid++ )
// 	{
// 	  if( parameters.gridIsMoving(grid) )
// 	  {
//             display(cg[grid].vertex(),sPrintF("adams: vertex at time t=%8.2e",solution.t),parameters.dbase.get<FILE* >("moveFile"),"%5.2f ");
            
//             Mapping & map = cg[grid].mapping().getMapping();
//             Mapping & map2 = gf[mab0].cg[grid].mapping().getMapping();
	    
//             if( map.getClassName()=="MatrixTransform" )
// 	    {
	      
// 	      MatrixTransform & transform = (MatrixTransform&)map;
// 	      MatrixTransform & transform2 = (MatrixTransform&)map2;
// 	      if( debug() & 4 )
// 	      {
// 		if( parameters.dbase.get<int >("myid")==0 )
// 		  fprintf(parameters.dbase.get<FILE* >("moveFile")," **advance:adams: solution.t=%8.2e grid=%i (%s)\n",
// 			  solution.t,grid,(const char*)solution.cg[grid].getName());

// 		display(transform.matrix->matrix,"** advance:adams:matrix from solution transform",parameters.dbase.get<FILE* >("moveFile"),"%5.3f ");
// 		display(transform2.matrix->matrix,"** advance:adams:matrix from gf[mab0] transform",parameters.dbase.get<FILE* >("moveFile"),"%5.3f ");
// 	      }
// 	    }
// 	    else
// 	    {
//               printf("Adams:ERROR: grid=%i map.getClassName()=[%s]\n",grid,(const char*)map.getClassName());
// 	    }
	    
// 	  }
//         }
//       }
//     }
//   }
//   solution.t=gf[mab0].t;

  checkArrayIDs("advancePC:end");
//   if( TRUE )
//   {
//     int ng;
//     for( int i=0; i<2; i++ )
//     {
//       ng=gf[i].u.getCompositeGrid()->numberOfComponentGrids();
//       printf("Adams: gf[%i].u.getCompositeGrid()->numberOfComponentGrids()=%i \n",i,ng);
//     }
//     ng=solution.u.getCompositeGrid()->numberOfComponentGrids();
//     printf("Adams: solution.u.getCompositeGrid()->numberOfComponentGrids()=%i \n",ng);  
//   }
  
}

